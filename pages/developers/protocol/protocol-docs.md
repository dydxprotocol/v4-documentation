
# dYdX Chain - gRPC Gateway docs v1.0.0

> Scroll down for code samples, example requests and responses. Select a language for code samples from the tabs above or the mobile navigation menu.

A REST interface for state queries, legacy transactions

# Query

## AllAssets

<a id="opIdAllAssets"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/assets/asset', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/assets/asset',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/assets/asset`

*Queries a list of Asset items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllAssetsResponse is response type for the AllAssets RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» asset|[object]|false|none|none|
|»» id|integer(int64)|false|none|Unique, sequentially-generated.|
|»» symbol|string|false|none|The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).<br />Must be uppercase, unique and correspond to the canonical symbol of the<br />full coin.|
|»» denom|string|false|none|The name of base denomination unit of the `Asset` (e.g. `uatom`,<br />'ibc/xxxxx'). Must be unique and match the `denom` used in the `sdk.Coin`<br />type in the `x/bank` module.|
|»» denom_exponent|integer(int32)|false|none|none|
|»» has_market|boolean|false|none|`true` if this `Asset` has a valid `MarketId` value.|
|»» market_id|integer(int64)|false|none|The `Id` of the `Market` associated with this `Asset`. It acts as the<br />oracle price for the purposes of calculating collateral<br />and margin requirements.|
|»» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (1 'quantum')<br />to a full coin. For example, if `atomic_resolution = -8`<br />then an `asset_position` with `base_quantums = 1e8` is equivalent to<br />a position size of one full coin.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Asset

<a id="opIdAsset"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/assets/asset/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/assets/asset/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/assets/asset/{id}`

*Queries a Asset by id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAssetResponse is response type for the Asset RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» asset|object|false|none|Asset defines a single exchangable asset.|
|»» id|integer(int64)|false|none|Unique, sequentially-generated.|
|»» symbol|string|false|none|The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).<br />Must be uppercase, unique and correspond to the canonical symbol of the<br />full coin.|
|»» denom|string|false|none|The name of base denomination unit of the `Asset` (e.g. `uatom`,<br />'ibc/xxxxx'). Must be unique and match the `denom` used in the `sdk.Coin`<br />type in the `x/bank` module.|
|»» denom_exponent|integer(int32)|false|none|none|
|»» has_market|boolean|false|none|`true` if this `Asset` has a valid `MarketId` value.|
|»» market_id|integer(int64)|false|none|The `Id` of the `Market` associated with this `Asset`. It acts as the<br />oracle price for the purposes of calculating collateral<br />and margin requirements.|
|»» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (1 'quantum')<br />to a full coin. For example, if `atomic_resolution = -8`<br />then an `asset_position` with `base_quantums = 1e8` is equivalent to<br />a position size of one full coin.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AllDowntimeInfo

<a id="opIdAllDowntimeInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/blocktime/all_downtime_info', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/blocktime/all_downtime_info',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/blocktime/all_downtime_info`

*Queries all recorded downtime info.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllDowntimeInfoResponse is a request type for the AllDowntimeInfo
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» info|object|false|none|AllDowntimeInfo stores information for all downtime durations.|
|»» infos|[object]|false|none|The downtime information for each tracked duration. Sorted by duration,<br />ascending. (i.e. the same order as they appear in DowntimeParams).|
|»»» duration|string|false|none|none|
|»»» block_info|object|false|none|none|
|»»»» height|integer(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DowntimeParams

<a id="opIdDowntimeParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/blocktime/downtime_params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/blocktime/downtime_params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/blocktime/downtime_params`

*Queries the DowntimeParams.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDowntimeParamsResponse is a response type for the DowntimeParams
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|DowntimeParams defines the parameters for downtime.|
|»» durations|[string]|false|none|Durations tracked for downtime. The durations must be sorted from<br />shortest to longest and must all be positive.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AcknowledgedEventInfo

<a id="opIdAcknowledgedEventInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/bridge/acknowledged_event_info', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/bridge/acknowledged_event_info',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/bridge/acknowledged_event_info`

*Queries the AcknowledgedEventInfo.
An "acknowledged" event is one that is in-consensus and has been stored
in-state.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAcknowledgedEventInfoResponse is a response type for the
AcknowledgedEventInfo RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» info|object|false|none|BridgeEventInfo stores information about the most recently processed bridge<br />event.|
|»» next_id|integer(int64)|false|none|The next event id (the last processed id plus one) of the logs from the<br />Ethereum contract.|
|»» eth_block_height|string(uint64)|false|none|The Ethereum block height of the most recently processed bridge event.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DelayedCompleteBridgeMessages

<a id="opIdDelayedCompleteBridgeMessages"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/bridge/delayed_complete_bridge_messages', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/bridge/delayed_complete_bridge_messages',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/bridge/delayed_complete_bridge_messages`

*Queries all `MsgCompleteBridge` messages that are delayed (not yet
executed) and corresponding block heights at which they will execute.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|query|string|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelayedCompleteBridgeMessagesResponse is a response type for the
DelayedCompleteBridgeMessages RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» messages|[object]|false|none|none|
|»» message|object|false|none|MsgCompleteBridge is the Msg/CompleteBridgeResponse request type.|
|»»» authority|string|false|none|none|
|»»» event|object|false|none|The event to complete.|
|»»»» id|integer(int64)|false|none|The unique id of the Ethereum event log.|
|»»»» coin|object|false|none|The tokens bridged.|
|»»»»» denom|string|false|none|none|
|»»»»» amount|string|false|none|none|
|»»»» address|string|false|none|The account address or module address to bridge to.|
|»»»» eth_block_height|string(uint64)|false|none|The Ethereum block height of the event.|
|»» block_height|integer(int64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## EventParams

<a id="opIdEventParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/bridge/event_params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/bridge/event_params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/bridge/event_params`

*Queries the EventParams.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryEventParamsResponse is a response type for the EventParams RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|EventParams stores parameters about which events to recognize and which<br />tokens to mint.|
|»» denom|string|false|none|The denom of the token to mint.|
|»» eth_chain_id|string(uint64)|false|none|The numerical chain ID of the Ethereum chain to query.|
|»» eth_address|string|false|none|The address of the Ethereum contract to monitor for logs.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ProposeParams

<a id="opIdProposeParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/bridge/propose_params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/bridge/propose_params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/bridge/propose_params`

*Queries the ProposeParams.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryProposeParamsResponse is a response type for the ProposeParams RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|ProposeParams stores parameters for proposing to the module.|
|»» max_bridges_per_block|integer(int64)|false|none|The maximum number of bridge events to propose per block.<br />Limits the number of events to propose in a single block<br />in-order to smooth out the flow of events.|
|»» propose_delay_duration|string|false|none|The minimum duration to wait between a finalized bridge and<br />proposing it. This allows other validators to have enough time to<br />also recognize its occurence. Therefore the bridge daemon should<br />pool for new finalized events at least as often as this parameter.|
|»» skip_rate_ppm|integer(int64)|false|none|Do not propose any events if a [0, 1_000_000) random number generator<br />generates a number smaller than this number.<br />Setting this parameter to 1_000_000 means always skipping proposing events.|
|»» skip_if_block_delayed_by_duration|string|false|none|Do not propose any events if the timestamp of the proposal block is<br />behind the proposers' wall-clock by at least this duration.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## RecognizedEventInfo

<a id="opIdRecognizedEventInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/bridge/recognized_event_info', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/bridge/recognized_event_info',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/bridge/recognized_event_info`

*Queries the RecognizedEventInfo.
A "recognized" event is one that is finalized on the Ethereum blockchain
and has been identified by the queried node. It is not yet in-consensus.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryRecognizedEventInfoResponse is a response type for the
RecognizedEventInfo RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» info|object|false|none|BridgeEventInfo stores information about the most recently processed bridge<br />event.|
|»» next_id|integer(int64)|false|none|The next event id (the last processed id plus one) of the logs from the<br />Ethereum contract.|
|»» eth_block_height|string(uint64)|false|none|The Ethereum block height of the most recently processed bridge event.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SafetyParams

<a id="opIdSafetyParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/bridge/safety_params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/bridge/safety_params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/bridge/safety_params`

*Queries the SafetyParams.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySafetyParamsResponse is a response type for the SafetyParams RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|SafetyParams stores safety parameters for the module.|
|»» is_disabled|boolean|false|none|True if bridging is disabled.|
|»» delay_blocks|integer(int64)|false|none|The number of blocks that bridges accepted in-consensus will be pending<br />until the minted tokens are granted.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## BlockRateLimitConfiguration

<a id="opIdBlockRateLimitConfiguration"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/clob/block_rate', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/clob/block_rate',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/clob/block_rate`

*Queries BlockRateLimitConfiguration.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryBlockRateLimitConfigurationResponse is a response message that contains
the BlockRateLimitConfiguration.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» block_rate_limit_config|object|false|none|Defines the block rate limits for CLOB specific operations.|
|»» max_short_term_orders_per_n_blocks|[object]|false|none|How many short term order attempts (successful and failed) are allowed for<br />an account per N blocks. Note that the rate limits are applied<br />in an AND fashion such that an order placement must pass all rate limit<br />configurations.<br /><br />Specifying 0 values disables this rate limit.<br />Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`<br />for v5.x onwards.|
|»»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|»» max_stateful_orders_per_n_blocks|[object]|false|none|How many stateful order attempts (successful and failed) are allowed for<br />an account per N blocks. Note that the rate limits are applied<br />in an AND fashion such that an order placement must pass all rate limit<br />configurations.<br /><br />Specifying 0 values disables this rate limit.|
|»»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|»» max_short_term_order_cancellations_per_n_blocks|[object]|false|none|How many short term order cancellation attempts (successful and failed) are<br />allowed for an account per N blocks. Note that the rate limits are<br />applied in an AND fashion such that an order cancellation must pass all<br />rate limit configurations.<br /><br />Specifying 0 values disables this rate limit.<br />Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`<br />for v5.x onwards.|
|»»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|»» max_short_term_orders_and_cancels_per_n_blocks|[object]|false|none|How many short term order place and cancel attempts (successful and failed)<br />are allowed for an account per N blocks. Note that the rate limits are<br />applied in an AND fashion such that an order placement must pass all rate<br />limit configurations.<br /><br />Specifying 0 values disables this rate limit.|
|»»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ClobPairAll

<a id="opIdClobPairAll"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/clob/clob_pair', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/clob/clob_pair',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/clob/clob_pair`

*Queries a list of ClobPair items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClobPairAllResponse is response type for the ClobPairAll method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» clob_pair|[object]|false|none|none|
|»» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|»» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|»» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|»» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|»» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|»» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|»» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ClobPair

<a id="opIdClobPair"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/clob/clob_pair/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/clob/clob_pair/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/clob/clob_pair/{id}`

*Queries a ClobPair by id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClobPairResponse is response type for the ClobPair method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» clob_pair|object|false|none|ClobPair represents a single CLOB pair for a given product<br />in state.|
|»» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|»» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|»» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|»» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|»» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|»» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|»» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## EquityTierLimitConfiguration

<a id="opIdEquityTierLimitConfiguration"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/clob/equity_tier', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/clob/equity_tier',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/clob/equity_tier`

*Queries EquityTierLimitConfiguration.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryEquityTierLimitConfigurationResponse is a response message that contains
the EquityTierLimitConfiguration.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» equity_tier_limit_config|object|false|none|Defines the set of equity tiers to limit how many open orders<br />a subaccount is allowed to have.|
|»» short_term_order_equity_tiers|[object]|false|none|How many short term stateful orders are allowed per equity tier.<br />Specifying 0 values disables this limit.|
|»»» usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|»»» limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|
|»» stateful_order_equity_tiers|[object]|false|none|How many open stateful orders are allowed per equity tier.<br />Specifying 0 values disables this limit.|
|»»» usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|»»» limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## LiquidationsConfiguration

<a id="opIdLiquidationsConfiguration"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/clob/liquidations_config', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/clob/liquidations_config',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/clob/liquidations_config`

*Queries LiquidationsConfiguration.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryLiquidationsConfigurationResponse is a response message that contains
the LiquidationsConfiguration.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» liquidations_config|object|false|none|LiquidationsConfig stores all configurable fields related to liquidations.|
|»» max_liquidation_fee_ppm|integer(int64)|false|none|The maximum liquidation fee (in parts-per-million). This fee goes<br />100% to the insurance fund.|
|»» position_block_limits|object|false|none|Limits around how much of a single position can be liquidated<br />within a single block.|
|»»» min_position_notional_liquidated|string(uint64)|false|none|The minimum amount of quantums to liquidate for each message (in<br />quote quantums).<br />Overridden by the maximum size of the position.|
|»»» max_position_portion_liquidated_ppm|integer(int64)|false|none|The maximum portion of the position liquidated (in parts-per-<br />million). Overridden by min_position_notional_liquidated.|
|»» subaccount_block_limits|object|false|none|Limits around how many quote quantums from a single subaccount can<br />be liquidated within a single block.|
|»»» max_notional_liquidated|string(uint64)|false|none|The maximum notional amount that a single subaccount can have<br />liquidated (in quote quantums) per block.|
|»»» max_quantums_insurance_lost|string(uint64)|false|none|The maximum insurance-fund payout amount for a given subaccount<br />per block. I.e. how much it can cover for that subaccount.|
|»» fillable_price_config|object|false|none|Config about how the fillable-price spread from the oracle price<br />increases based on the adjusted bankruptcy rating of the subaccount.|
|»»» bankruptcy_adjustment_ppm|integer(int64)|false|none|The rate at which the Adjusted Bankruptcy Rating increases.|
|»»» spread_to_maintenance_margin_ratio_ppm|integer(int64)|false|none|The maximum value that the liquidation spread can take, as<br />a ratio against the position's maintenance margin.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## MevNodeToNodeCalculation

<a id="opIdMevNodeToNodeCalculation"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/dydxprotocol/clob/mev_node_to_node_calculation', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "block_proposer_matches": {
    "matches": [
      {
        "taker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "taker_fee_ppm": 0,
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ],
    "liquidation_matches": [
      {
        "liquidated_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "insurance_fund_delta_quote_quantums": "string",
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ]
  },
  "validator_mev_metrics": {
    "validator_mev_matches": {
      "matches": [
        {
          "taker_order_subaccount_id": {},
          "taker_fee_ppm": 0,
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ],
      "liquidation_matches": [
        {
          "liquidated_subaccount_id": {},
          "insurance_fund_delta_quote_quantums": "string",
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ]
    },
    "clob_mid_prices": [
      {
        "clob_pair": {
          "id": 0,
          "perpetual_clob_metadata": {},
          "spot_clob_metadata": {},
          "step_base_quantums": "string",
          "subticks_per_tick": 0,
          "quantum_conversion_exponent": 0,
          "status": "["
        },
        "subticks": "string"
      }
    ],
    "bp_mev_matches": {
      "matches": [
        {
          "taker_order_subaccount_id": {},
          "taker_fee_ppm": 0,
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ],
      "liquidation_matches": [
        {
          "liquidated_subaccount_id": {},
          "insurance_fund_delta_quote_quantums": "string",
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ]
    },
    "proposal_receive_time": "string"
  }
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/dydxprotocol/clob/mev_node_to_node_calculation',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /dydxprotocol/clob/mev_node_to_node_calculation`

*Runs the MEV node <> node calculation with the provided parameters.*

> Body parameter

```json
{
  "block_proposer_matches": {
    "matches": [
      {
        "taker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "taker_fee_ppm": 0,
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ],
    "liquidation_matches": [
      {
        "liquidated_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "insurance_fund_delta_quote_quantums": "string",
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ]
  },
  "validator_mev_metrics": {
    "validator_mev_matches": {
      "matches": [
        {
          "taker_order_subaccount_id": {},
          "taker_fee_ppm": 0,
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ],
      "liquidation_matches": [
        {
          "liquidated_subaccount_id": {},
          "insurance_fund_delta_quote_quantums": "string",
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ]
    },
    "clob_mid_prices": [
      {
        "clob_pair": {
          "id": 0,
          "perpetual_clob_metadata": {},
          "spot_clob_metadata": {},
          "step_base_quantums": "string",
          "subticks_per_tick": 0,
          "quantum_conversion_exponent": 0,
          "status": "["
        },
        "subticks": "string"
      }
    ],
    "bp_mev_matches": {
      "matches": [
        {
          "taker_order_subaccount_id": {},
          "taker_fee_ppm": 0,
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ],
      "liquidation_matches": [
        {
          "liquidated_subaccount_id": {},
          "insurance_fund_delta_quote_quantums": "string",
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ]
    },
    "proposal_receive_time": "string"
  }
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|object|true|none|
|» block_proposer_matches|body|object|false|Represents the matches on the "block proposer". Note that this field|
|»» matches|body|[object]|false|none|
|»»» taker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»» taker_fee_ppm|body|integer(int32)|false|none|
|»»» maker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»» maker_order_subticks|body|string(uint64)|false|none|
|»»» maker_order_is_buy|body|boolean|false|none|
|»»» maker_fee_ppm|body|integer(int32)|false|none|
|»»» clob_pair_id|body|integer(int64)|false|none|
|»»» fill_amount|body|string(uint64)|false|none|
|»» liquidation_matches|body|[object]|false|none|
|»»» liquidated_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»» insurance_fund_delta_quote_quantums|body|string(int64)|false|none|
|»»» maker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»» maker_order_subticks|body|string(uint64)|false|none|
|»»» maker_order_is_buy|body|boolean|false|none|
|»»» maker_fee_ppm|body|integer(int32)|false|none|
|»»» clob_pair_id|body|integer(int64)|false|none|
|»»» fill_amount|body|string(uint64)|false|none|
|» validator_mev_metrics|body|object|false|Represents the matches and mid-prices on the validator.|
|»» validator_mev_matches|body|object|false|ValidatorMevMatches contains all matches from the validator's local|
|»»» matches|body|[object]|false|none|
|»»»» taker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» taker_fee_ppm|body|integer(int32)|false|none|
|»»»» maker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» maker_order_subticks|body|string(uint64)|false|none|
|»»»» maker_order_is_buy|body|boolean|false|none|
|»»»» maker_fee_ppm|body|integer(int32)|false|none|
|»»»» clob_pair_id|body|integer(int64)|false|none|
|»»»» fill_amount|body|string(uint64)|false|none|
|»»» liquidation_matches|body|[object]|false|none|
|»»»» liquidated_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» insurance_fund_delta_quote_quantums|body|string(int64)|false|none|
|»»»» maker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» maker_order_subticks|body|string(uint64)|false|none|
|»»»» maker_order_is_buy|body|boolean|false|none|
|»»»» maker_fee_ppm|body|integer(int32)|false|none|
|»»»» clob_pair_id|body|integer(int64)|false|none|
|»»»» fill_amount|body|string(uint64)|false|none|
|»» clob_mid_prices|body|[object]|false|none|
|»»» clob_pair|body|object|false|ClobPair represents a single CLOB pair for a given product|
|»»»» id|body|integer(int64)|false|ID of the orderbook that stores all resting liquidity for this CLOB.|
|»»»» perpetual_clob_metadata|body|object|false|PerpetualClobMetadata contains metadata for a `ClobPair`|
|»»»»» perpetual_id|body|integer(int64)|false|Id of the Perpetual the CLOB allows trading of.|
|»»»» spot_clob_metadata|body|object|false|PerpetualClobMetadata contains metadata for a `ClobPair`|
|»»»»» base_asset_id|body|integer(int64)|false|Id of the base Asset in the trading pair.|
|»»»»» quote_asset_id|body|integer(int64)|false|Id of the quote Asset in the trading pair.|
|»»»» step_base_quantums|body|string(uint64)|false|Minimum increment in the size of orders on the CLOB, in base quantums.|
|»»»» subticks_per_tick|body|integer(int64)|false|Defines the tick size of the orderbook by defining how many subticks|
|»»»» quantum_conversion_exponent|body|integer(int32)|false|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum|
|»»»» status|body|string|false|Status of the CLOB.|
|»»» subticks|body|string(uint64)|false|none|
|»» bp_mev_matches|body|object|false|ValidatorMevMatches contains all matches from the validator's local|
|»»» matches|body|[object]|false|none|
|»»»» taker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» taker_fee_ppm|body|integer(int32)|false|none|
|»»»» maker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» maker_order_subticks|body|string(uint64)|false|none|
|»»»» maker_order_is_buy|body|boolean|false|none|
|»»»» maker_fee_ppm|body|integer(int32)|false|none|
|»»»» clob_pair_id|body|integer(int64)|false|none|
|»»»» fill_amount|body|string(uint64)|false|none|
|»»» liquidation_matches|body|[object]|false|none|
|»»»» liquidated_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» insurance_fund_delta_quote_quantums|body|string(int64)|false|none|
|»»»» maker_order_subaccount_id|body|object|false|SubaccountId defines a unique identifier for a Subaccount.|
|»»»»» owner|body|string|false|The address of the wallet that owns this subaccount.|
|»»»»» number|body|integer(int64)|false|The unique number of this subaccount for the owner.|
|»»»» maker_order_subticks|body|string(uint64)|false|none|
|»»»» maker_order_is_buy|body|boolean|false|none|
|»»»» maker_fee_ppm|body|integer(int32)|false|none|
|»»»» clob_pair_id|body|integer(int64)|false|none|
|»»»» fill_amount|body|string(uint64)|false|none|
|»» proposal_receive_time|body|string(uint64)|false|none|

#### Detailed descriptions

**» block_proposer_matches**: Represents the matches on the "block proposer". Note that this field
does not need to be the actual block proposer's matches for a block, since
the MEV calculation logic is run with this nodes matches as the "block
proposer" matches.

**»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»» validator_mev_matches**: ValidatorMevMatches contains all matches from the validator's local
operations queue.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»» clob_pair**: ClobPair represents a single CLOB pair for a given product
in state.

**»»»» perpetual_clob_metadata**: PerpetualClobMetadata contains metadata for a `ClobPair`
representing a Perpetual product.

**»»»» spot_clob_metadata**: PerpetualClobMetadata contains metadata for a `ClobPair`
representing a Spot product.

**»»»» subticks_per_tick**: Defines the tick size of the orderbook by defining how many subticks
are in one tick. That is, the subticks of any valid order must be a
multiple of this value. Generally this value should start `>= 100`to
allow room for decreasing it.

**»»»» quantum_conversion_exponent**: `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
per Subtick.

**»»»» status**: Status of the CLOB.

 - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.
 - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.
 - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.
TODO(DEC-600): update this documentation.
 - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.
TODO(DEC-600): update this documentation.
 - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.
TODO(DEC-600): update this documentation.
 - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.
Clob pairs in this state only accept orders which are
both short-term and post-only.
 - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated
and trading has ceased. All open positions will be closed by the
protocol. Open stateful orders will be cancelled. Open short-term
orders will be left to expire.

**»» bp_mev_matches**: ValidatorMevMatches contains all matches from the validator's local
operations queue.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

**»»»»» number**: The unique number of this subaccount for the owner.
Currently limited to 128*1000 subaccounts per owner.

#### Enumerated Values

|Parameter|Value|
|---|---|
|»»»» status|STATUS_UNSPECIFIED|
|»»»» status|STATUS_ACTIVE|
|»»»» status|STATUS_PAUSED|
|»»»» status|STATUS_CANCEL_ONLY|
|»»»» status|STATUS_POST_ONLY|
|»»»» status|STATUS_INITIALIZING|
|»»»» status|STATUS_FINAL_SETTLEMENT|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*MevNodeToNodeCalculationResponse is a response message that contains the
MEV node <> node calculation result.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» results|[object]|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» mev|number(float)|false|none|none|
|»» volume|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## BlockMessageIds

<a id="opIdBlockMessageIds"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/delaymsg/block/message_ids/{block_height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/delaymsg/block/message_ids/{block_height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/delaymsg/block/message_ids/{block_height}`

*Queries the DelayedMessages at a given block height.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|block_height|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGetBlockMessageIdsResponse is the response type for the BlockMessageIds
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» message_ids|[integer]|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Message

<a id="opIdMessage"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/delaymsg/message/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/delaymsg/message/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/delaymsg/message/{id}`

*Queries the DelayedMessage by id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGetMessageResponse is the response type for the Message RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» message|object|false|none|DelayedMessage is a message that is delayed until a certain block height.|
|»» id|integer(int64)|false|none|The ID of the delayed message.|
|»» msg|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» block_height|integer(int64)|false|none|The block height at which the message should be executed.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## NextDelayedMessageId

<a id="opIdNextDelayedMessageId"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/delaymsg/next_id', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/delaymsg/next_id',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/delaymsg/next_id`

*Queries the next DelayedMessage's id.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryNextDelayedMessageIdResponse is the response type for the
NextDelayedMessageId RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» next_delayed_message_id|integer(int64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## EpochInfoAll

<a id="opIdEpochInfoAll"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/epochs/epoch_info', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/epochs/epoch_info',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/epochs/epoch_info`

*Queries a list of EpochInfo items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryEpochInfoAllResponse is response type for the AllEpochInfo RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» epoch_info|[object]|false|none|none|
|»» name|string|false|none|name is the unique identifier.|
|»» next_tick|integer(int64)|false|none|next_tick indicates when the next epoch starts (in Unix Epoch seconds),<br />if `EpochInfo` has been initialized.<br />If `EpochInfo` is not initialized yet, `next_tick` indicates the earliest<br />initialization time (see `is_initialized` below).|
|»» duration|integer(int64)|false|none|duration of the epoch in seconds.|
|»» current_epoch|integer(int64)|false|none|current epoch is the number of the current epoch.<br />0 if `next_tick` has never been reached, positive otherwise.|
|»» current_epoch_start_block|integer(int64)|false|none|current_epoch_start_block indicates the block height when the current<br />epoch started. 0 if `current_epoch` is 0.|
|»» is_initialized|boolean|false|none|none|
|»» fast_forward_next_tick|boolean|false|none|fast_forward_next_tick specifies whether during initialization, `next_tick`<br />should be fast-forwarded to be greater than the current block time.<br />If `false`, the original `next_tick` value is<br />unchanged during initialization.<br />If `true`, `next_tick` will be set to the smallest value `x` greater than<br />the current block time such that `(x - next_tick) % duration = 0`.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## EpochInfo

<a id="opIdEpochInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/epochs/epoch_info/{name}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/epochs/epoch_info/{name}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/epochs/epoch_info/{name}`

*Queries a EpochInfo by name.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|name|path|string|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryEpochInfoResponse is response type for the GetEpochInfo RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» epoch_info|object|false|none|EpochInfo stores metadata of an epoch timer.|
|»» name|string|false|none|name is the unique identifier.|
|»» next_tick|integer(int64)|false|none|next_tick indicates when the next epoch starts (in Unix Epoch seconds),<br />if `EpochInfo` has been initialized.<br />If `EpochInfo` is not initialized yet, `next_tick` indicates the earliest<br />initialization time (see `is_initialized` below).|
|»» duration|integer(int64)|false|none|duration of the epoch in seconds.|
|»» current_epoch|integer(int64)|false|none|current epoch is the number of the current epoch.<br />0 if `next_tick` has never been reached, positive otherwise.|
|»» current_epoch_start_block|integer(int64)|false|none|current_epoch_start_block indicates the block height when the current<br />epoch started. 0 if `current_epoch` is 0.|
|»» is_initialized|boolean|false|none|none|
|»» fast_forward_next_tick|boolean|false|none|fast_forward_next_tick specifies whether during initialization, `next_tick`<br />should be fast-forwarded to be greater than the current block time.<br />If `false`, the original `next_tick` value is<br />unchanged during initialization.<br />If `true`, `next_tick` will be set to the smallest value `x` greater than<br />the current block time such that `(x - next_tick) % duration = 0`.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## PerpetualFeeParams

<a id="opIdPerpetualFeeParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/feetiers/perpetual_fee_params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/feetiers/perpetual_fee_params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/feetiers/perpetual_fee_params`

*Queries the PerpetualFeeParams.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPerpetualFeeParamsResponse is a response type for the PerpetualFeeParams
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|PerpetualFeeParams defines the parameters for perpetual fees.|
|»» tiers|[object]|false|none|Sorted fee tiers (lowest requirements first).|
|»»» A fee tier for perpetuals|object|false|none|none|
|»»»» name|string|false|none|Human-readable name of the tier, e.g. "Gold".|
|»»»» absolute_volume_requirement|string(uint64)|false|none|The trader's absolute volume requirement in quote quantums.|
|»»»» total_volume_share_requirement_ppm|integer(int64)|false|none|The total volume share requirement.|
|»»»» maker_volume_share_requirement_ppm|integer(int64)|false|none|The maker volume share requirement.|
|»»»» maker_fee_ppm|integer(int32)|false|none|The maker fee once this tier is reached.|
|»»»» taker_fee_ppm|integer(int32)|false|none|The taker fee once this tier is reached.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## UserFeeTier

<a id="opIdUserFeeTier"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/feetiers/user_fee_tier', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/feetiers/user_fee_tier',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/feetiers/user_fee_tier`

*Queries a user's fee tier*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|user|query|string|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUserFeeTierResponse is a request type for the UserFeeTier RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» index|integer(int64)|false|none|Index of the fee tier in the list queried from PerpetualFeeParams.|
|» tier|object|false|none|none|
|»» name|string|false|none|Human-readable name of the tier, e.g. "Gold".|
|»» absolute_volume_requirement|string(uint64)|false|none|The trader's absolute volume requirement in quote quantums.|
|»» total_volume_share_requirement_ppm|integer(int64)|false|none|The total volume share requirement.|
|»» maker_volume_share_requirement_ppm|integer(int64)|false|none|The maker volume share requirement.|
|»» maker_fee_ppm|integer(int32)|false|none|The maker fee once this tier is reached.|
|»» taker_fee_ppm|integer(int32)|false|none|The taker fee once this tier is reached.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AllLiquidityTiers

<a id="opIdAllLiquidityTiers"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/perpetuals/liquidity_tiers', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/perpetuals/liquidity_tiers',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/perpetuals/liquidity_tiers`

*Queries a list of LiquidityTiers.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllLiquidityTiersResponse is response type for the AllLiquidityTiers RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» liquidity_tiers|[object]|false|none|none|
|»» id|integer(int64)|false|none|Unique id.|
|»» name|string|false|none|The name of the tier purely for mnemonic purposes, e.g. "Gold".|
|»» initial_margin_ppm|integer(int64)|false|none|The margin fraction needed to open a position.<br />In parts-per-million.|
|»» maintenance_fraction_ppm|integer(int64)|false|none|The fraction of the initial-margin that the maintenance-margin is,<br />e.g. 50%. In parts-per-million.|
|»» base_position_notional|string(uint64)|false|none|The maximum position size at which the margin requirements are<br />not increased over the default values. Above this position size,<br />the margin requirements increase at a rate of sqrt(size).<br /><br />Deprecated since v3.x.|
|»» impact_notional|string(uint64)|false|none|The impact notional amount (in quote quantums) is used to determine impact<br />bid/ask prices and its recommended value is 500 USDC / initial margin<br />fraction.<br />- Impact bid price = average execution price for a market sell of the<br />impact notional value.<br />- Impact ask price = average execution price for a market buy of the<br />impact notional value.|
|»» open_interest_lower_cap|string(uint64)|false|none|Lower cap for Open Interest Margin Fracton (OIMF), in quote quantums.<br />IMF is not affected when OI <= open_interest_lower_cap.|
|»» open_interest_upper_cap|string(uint64)|false|none|Upper cap for Open Interest Margin Fracton (OIMF), in quote quantums.<br />IMF scales linearly to 100% as OI approaches open_interest_upper_cap.<br />If zero, then the IMF does not scale with OI.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## PerpetualParams

<a id="opIdPerpetualParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/perpetuals/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/perpetuals/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/perpetuals/params`

*Queries the perpetual params.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|Params defines the parameters for x/perpetuals module.|
|»» funding_rate_clamp_factor_ppm|integer(int64)|false|none|Funding rate clamp factor in parts-per-million, used for clamping 8-hour<br />funding rates according to equation: |R| <= funding_rate_clamp_factor *<br />(initial margin - maintenance margin).|
|»» premium_vote_clamp_factor_ppm|integer(int64)|false|none|Premium vote clamp factor in parts-per-million, used for clamping premium<br />votes according to equation: |V| <= premium_vote_clamp_factor *<br />(initial margin - maintenance margin).|
|»» min_num_votes_per_sample|integer(int64)|false|none|Minimum number of premium votes per premium sample. If number of premium<br />votes is smaller than this number, pad with zeros up to this number.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AllPerpetuals

<a id="opIdAllPerpetuals"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/perpetuals/perpetual', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/perpetuals/perpetual',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/perpetuals/perpetual`

*Queries a list of Perpetual items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllPerpetualsResponse is response type for the AllPerpetuals RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» perpetual|[object]|false|none|none|
|»» params|object|false|none|PerpetualParams is the parameters of the perpetual.|
|»»» id|integer(int64)|false|none|Unique, sequentially-generated.|
|»»» ticker|string|false|none|The name of the `Perpetual` (e.g. `BTC-USD`).|
|»»» market_id|integer(int64)|false|none|The market associated with this `Perpetual`. It<br />acts as the oracle price for the purposes of calculating<br />collateral, margin requirements, and funding rates.|
|»»» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (`size = 1`)<br />to a full coin. For example, if `AtomicResolution = -8`<br />then a `PerpetualPosition` with `size = 1e8` is equivalent to<br />a position size of one full coin.|
|»»» default_funding_ppm|integer(int32)|false|none|The default funding payment if there is no price premium. In<br />parts-per-million.|
|»»» liquidity_tier|integer(int64)|false|none|The liquidity_tier that this perpetual is associated with.|
|»»» market_type|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|
|»» funding_index|string(byte)|false|none|The current index determined by the cumulative all-time<br />history of the funding mechanism. Starts at zero.|
|»» open_interest|string(byte)|false|none|Total size of open long contracts, measured in base_quantums.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|market_type|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|market_type|PERPETUAL_MARKET_TYPE_CROSS|
|market_type|PERPETUAL_MARKET_TYPE_ISOLATED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Perpetual

<a id="opIdPerpetual"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/perpetuals/perpetual/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/perpetuals/perpetual/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/perpetuals/perpetual/{id}`

*Queries a Perpetual by id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPerpetualResponse is response type for the Perpetual RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» perpetual|object|false|none|Perpetual represents a perpetual on the dYdX exchange.|
|»» params|object|false|none|PerpetualParams is the parameters of the perpetual.|
|»»» id|integer(int64)|false|none|Unique, sequentially-generated.|
|»»» ticker|string|false|none|The name of the `Perpetual` (e.g. `BTC-USD`).|
|»»» market_id|integer(int64)|false|none|The market associated with this `Perpetual`. It<br />acts as the oracle price for the purposes of calculating<br />collateral, margin requirements, and funding rates.|
|»»» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (`size = 1`)<br />to a full coin. For example, if `AtomicResolution = -8`<br />then a `PerpetualPosition` with `size = 1e8` is equivalent to<br />a position size of one full coin.|
|»»» default_funding_ppm|integer(int32)|false|none|The default funding payment if there is no price premium. In<br />parts-per-million.|
|»»» liquidity_tier|integer(int64)|false|none|The liquidity_tier that this perpetual is associated with.|
|»»» market_type|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|
|»» funding_index|string(byte)|false|none|The current index determined by the cumulative all-time<br />history of the funding mechanism. Starts at zero.|
|»» open_interest|string(byte)|false|none|Total size of open long contracts, measured in base_quantums.|

#### Enumerated Values

|Property|Value|
|---|---|
|market_type|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|market_type|PERPETUAL_MARKET_TYPE_CROSS|
|market_type|PERPETUAL_MARKET_TYPE_ISOLATED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## PremiumSamples

<a id="opIdPremiumSamples"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/perpetuals/premium_samples', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/perpetuals/premium_samples',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/perpetuals/premium_samples`

*Queries a list of premium samples.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPremiumSamplesResponse is the response type for the PremiumSamples RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» premium_samples|object|false|none|PremiumStore is a struct to store a perpetual premiums for all<br />perpetual markets. It stores a list of `MarketPremiums`, each of which<br />corresponds to a perpetual market and stores a list of non-zero premium<br />values for that market.<br />This struct can either be used to store `PremiumVotes` or<br />`PremiumSamples`.|
|»» all_market_premiums|[object]|false|none|all_market_premiums a list of `MarketPremiums`, each corresponding to<br />a perpetual market.|
|»»» perpetual_id|integer(int64)|false|none|perpetual_id is the Id of the perpetual market.|
|»»» premiums|[integer]|false|none|premiums is a list of premium values for a perpetual market. Since most<br />premiums are zeros under "stable" market conditions, only non-zero values<br />are stored in this list.|
|»» num_premiums|integer(int64)|false|none|number of rounds where premium values were added. This value indicates<br />the total number of premiums (zeros and non-zeros) for each<br />`MarketPremiums` struct. Note that in the edge case a perpetual market was<br />added in the middle of a epoch, we don't keep a seperate count for that<br />market. This means we treat this market as having zero premiums before it<br />was added.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## PremiumVotes

<a id="opIdPremiumVotes"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/perpetuals/premium_votes', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/perpetuals/premium_votes',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/perpetuals/premium_votes`

*Queries a list of premium votes.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPremiumVotesResponse is the response type for the PremiumVotes RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» premium_votes|object|false|none|PremiumStore is a struct to store a perpetual premiums for all<br />perpetual markets. It stores a list of `MarketPremiums`, each of which<br />corresponds to a perpetual market and stores a list of non-zero premium<br />values for that market.<br />This struct can either be used to store `PremiumVotes` or<br />`PremiumSamples`.|
|»» all_market_premiums|[object]|false|none|all_market_premiums a list of `MarketPremiums`, each corresponding to<br />a perpetual market.|
|»»» perpetual_id|integer(int64)|false|none|perpetual_id is the Id of the perpetual market.|
|»»» premiums|[integer]|false|none|premiums is a list of premium values for a perpetual market. Since most<br />premiums are zeros under "stable" market conditions, only non-zero values<br />are stored in this list.|
|»» num_premiums|integer(int64)|false|none|number of rounds where premium values were added. This value indicates<br />the total number of premiums (zeros and non-zeros) for each<br />`MarketPremiums` struct. Note that in the edge case a perpetual market was<br />added in the middle of a epoch, we don't keep a seperate count for that<br />market. This means we treat this market as having zero premiums before it<br />was added.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AllMarketPrices

<a id="opIdAllMarketPrices"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/prices/market', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/prices/market',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/prices/market`

*Queries a list of MarketPrice items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllMarketPricesResponse is response type for the Query/Params
`AllMarketPrices` RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» market_prices|[object]|false|none|none|
|»» id|integer(int64)|false|none|Unique, sequentially-generated value that matches `MarketParam`.|
|»» exponent|integer(int32)|false|none|Static value. The exponent of the price. See the comment on the duplicate<br />MarketParam field for more information.|
|»» price|string(uint64)|false|none|The variable value that is updated by oracle price updates. `0` if it has<br />never been updated, `>0` otherwise.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## MarketPrice

<a id="opIdMarketPrice"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/prices/market/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/prices/market/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/prices/market/{id}`

*Queries a MarketPrice by id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryMarketPriceResponse is response type for the Query/Params `MarketPrice`
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» market_price|object|false|none|MarketPrice is used by the application to store/retrieve oracle price.|
|»» id|integer(int64)|false|none|Unique, sequentially-generated value that matches `MarketParam`.|
|»» exponent|integer(int32)|false|none|Static value. The exponent of the price. See the comment on the duplicate<br />MarketParam field for more information.|
|»» price|string(uint64)|false|none|The variable value that is updated by oracle price updates. `0` if it has<br />never been updated, `>0` otherwise.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AllMarketParams

<a id="opIdAllMarketParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/prices/params/market', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/prices/params/market',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/prices/params/market`

*Queries a list of MarketParam items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllMarketParamsResponse is response type for the Query/Params
`AllMarketParams` RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» market_params|[object]|false|none|none|
|»» id|integer(int64)|false|none|Unique, sequentially-generated value.|
|»» pair|string|false|none|The human-readable name of the market pair (e.g. `BTC-USD`).|
|»» exponent|integer(int32)|false|none|Static value. The exponent of the price.<br />For example if `Exponent == -5` then a `Value` of `1,000,000,000`<br />represents ``$10,000`. Therefore `10 ^ Exponent` represents the smallest<br />price step (in dollars) that can be recorded.|
|»» min_exchanges|integer(int64)|false|none|The minimum number of exchanges that should be reporting a live price for<br />a price update to be considered valid.|
|»» min_price_change_ppm|integer(int64)|false|none|The minimum allowable change in `price` value that would cause a price<br />update on the network. Measured as `1e-6` (parts per million).|
|»» exchange_config_json|string|false|none|A string of json that encodes the configuration for resolving the price<br />of this market on various exchanges.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## MarketParam

<a id="opIdMarketParam"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/prices/params/market/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/prices/params/market/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/prices/params/market/{id}`

*Queries a MarketParam by id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryMarketParamResponse is response type for the Query/Params `MarketParams`
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» market_param|object|false|none|MarketParam represents the x/prices configuration for markets, including<br />representing price values, resolving markets on individual exchanges, and<br />generating price updates. This configuration is specific to the quote<br />currency.|
|»» id|integer(int64)|false|none|Unique, sequentially-generated value.|
|»» pair|string|false|none|The human-readable name of the market pair (e.g. `BTC-USD`).|
|»» exponent|integer(int32)|false|none|Static value. The exponent of the price.<br />For example if `Exponent == -5` then a `Value` of `1,000,000,000`<br />represents ``$10,000`. Therefore `10 ^ Exponent` represents the smallest<br />price step (in dollars) that can be recorded.|
|»» min_exchanges|integer(int64)|false|none|The minimum number of exchanges that should be reporting a live price for<br />a price update to be considered valid.|
|»» min_price_change_ppm|integer(int64)|false|none|The minimum allowable change in `price` value that would cause a price<br />update on the network. Measured as `1e-6` (parts per million).|
|»» exchange_config_json|string|false|none|A string of json that encodes the configuration for resolving the price<br />of this market on various exchanges.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## RewardParams

<a id="opIdRewardParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/rewards/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/rewards/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/rewards/params`

*Queries the Params.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is a response type for the Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|Params defines the parameters for x/rewards module.|
|»» treasury_account|string|false|none|The module account to distribute rewards from.|
|»» denom|string|false|none|The denom of the rewards token.|
|»» denom_exponent|integer(int32)|false|none|The exponent of converting one unit of `denom` to a full coin.<br />For example, `denom=uatom, denom_exponent=-6` defines that<br />`1 uatom = 10^(-6) ATOM`. This conversion is needed since the<br />`market_id` retrieves the price of a full coin of the reward token.|
|»» market_id|integer(int64)|false|none|The id of the market that has the price of the rewards token.|
|»» fee_multiplier_ppm|integer(int64)|false|none|The amount (in ppm) that fees are multiplied by to get<br />the maximum rewards amount.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## GlobalStats

<a id="opIdGlobalStats"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/stats/global_stats', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/stats/global_stats',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/stats/global_stats`

*Queries GlobalStats.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGlobalStatsResponse is a response type for the GlobalStats RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» stats|object|false|none|none|
|»» notional_traded|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## StatParams

<a id="opIdStatParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/stats/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/stats/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/stats/params`

*Queries the Params.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is a response type for the Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|Params defines the parameters for x/stats module.|
|»» window_duration|string|false|none|The desired number of seconds in the look-back window.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## StatsMetadata

<a id="opIdStatsMetadata"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/stats/stats_metadata', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/stats/stats_metadata',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/stats/stats_metadata`

*Queries StatsMetadata.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryStatsMetadataResponse is a response type for the StatsMetadata RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» metadata|object|false|none|none|
|»» trailing_epoch|integer(int64)|false|none|The oldest epoch that is included in the stats. The next epoch to be<br />removed from the window.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## UserStats

<a id="opIdUserStats"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/stats/user_stats', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/stats/user_stats',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/stats/user_stats`

*Queries UserStats.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|user|query|string|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUserStatsResponse is a request type for the UserStats RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» stats|object|false|none|none|
|»» taker_notional|string(uint64)|false|none|none|
|»» maker_notional|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## CollateralPoolAddress

<a id="opIdCollateralPoolAddress"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/subaccounts/collateral_pool_address/{perpetual_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/subaccounts/collateral_pool_address/{perpetual_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/subaccounts/collateral_pool_address/{perpetual_id}`

*Queries the collateral pool account address for a perpetual id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|perpetual_id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryCollateralPoolAddressResponse is a response type for fetching the
account address of the collateral pool associated with the passed in
perpetual id.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» collateral_pool_address|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SubaccountAll

<a id="opIdSubaccountAll"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/subaccounts/subaccount', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/subaccounts/subaccount',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/subaccounts/subaccount`

*Queries a list of Subaccount items.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySubaccountAllResponse is response type for the Query RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» subaccount|[object]|false|none|none|
|»» id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» asset_positions|[object]|false|none|All `AssetPosition`s associated with this subaccount.<br />Always sorted ascending by `asset_id`.|
|»»» asset_id|integer(int64)|false|none|The `Id` of the `Asset`.|
|»»» quantums|string(byte)|false|none|The absolute size of the position in base quantums.|
|»»» index|string(uint64)|false|none|The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last<br />time this position was settled<br />TODO(DEC-582): pending margin trading being added.|
|»» perpetual_positions|[object]|false|none|All `PerpetualPosition`s associated with this subaccount.<br />Always sorted ascending by `perpetual_id.|
|»»» perpetual_id|integer(int64)|false|none|The `Id` of the `Perpetual`.|
|»»» quantums|string(byte)|false|none|The size of the position in base quantums.|
|»»» funding_index|string(byte)|false|none|The funding_index of the `Perpetual` the last time this position was<br />settled.|
|»» margin_enabled|boolean|false|none|Set by the owner. If true, then margin trades can be made in this<br />subaccount.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Subaccount

<a id="opIdSubaccount"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/subaccounts/subaccount/{owner}/{number}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/subaccounts/subaccount/{owner}/{number}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/subaccounts/subaccount/{owner}/{number}`

*Queries a Subaccount by id*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|owner|path|string|true|none|
|number|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySubaccountResponse is response type for the Query RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» subaccount|object|false|none|Subaccount defines a single sub-account for a given address.<br />Subaccounts are uniquely indexed by a subaccountNumber/owner pair.|
|»» id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» asset_positions|[object]|false|none|All `AssetPosition`s associated with this subaccount.<br />Always sorted ascending by `asset_id`.|
|»»» asset_id|integer(int64)|false|none|The `Id` of the `Asset`.|
|»»» quantums|string(byte)|false|none|The absolute size of the position in base quantums.|
|»»» index|string(uint64)|false|none|The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last<br />time this position was settled<br />TODO(DEC-582): pending margin trading being added.|
|»» perpetual_positions|[object]|false|none|All `PerpetualPosition`s associated with this subaccount.<br />Always sorted ascending by `perpetual_id.|
|»»» perpetual_id|integer(int64)|false|none|The `Id` of the `Perpetual`.|
|»»» quantums|string(byte)|false|none|The size of the position in base quantums.|
|»»» funding_index|string(byte)|false|none|The funding_index of the `Perpetual` the last time this position was<br />settled.|
|»» margin_enabled|boolean|false|none|Set by the owner. If true, then margin trades can be made in this<br />subaccount.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## GetWithdrawalAndTransfersBlockedInfo

<a id="opIdGetWithdrawalAndTransfersBlockedInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/subaccounts/withdrawals_and_transfers_blocked_info/{perpetual_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/subaccounts/withdrawals_and_transfers_blocked_info/{perpetual_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/subaccounts/withdrawals_and_transfers_blocked_info/{perpetual_id}`

*Queries information about whether withdrawal and transfers are blocked, and
if so which block they are re-enabled on.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|perpetual_id|path|integer(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGetWithdrawalAndTransfersBlockedInfoRequest is a response type for
fetching information about whether withdrawals and transfers are blocked.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» negative_tnc_subaccount_seen_at_block|integer(int64)|false|none|none|
|» chain_outage_seen_at_block|integer(int64)|false|none|none|
|» withdrawals_and_transfers_unblocked_at_block|integer(int64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## VestEntry

<a id="opIdVestEntry"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/dydxprotocol/v4/vest/vest_entry', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/dydxprotocol/v4/vest/vest_entry',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /dydxprotocol/v4/vest/vest_entry`

*Queries the VestEntry.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|vester_account|query|string|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryVestEntryResponse is a response type for the VestEntry RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» entry|object|false|none|VestEntry specifies a Vester Account and the rate at which tokens are<br />dripped into the corresponding Treasury Account.|
|»» vester_account|string|false|none|The module account to vest tokens from.<br />This is also the key to this `VestEntry` in state.|
|»» treasury_account|string|false|none|The module account to vest tokens to.|
|»» denom|string|false|none|The denom of the token to vest.|
|»» start_time|string(date-time)|false|none|The start time of vest. Before this time, no vest will occur.|
|»» end_time|string(date-time)|false|none|The end time of vest. At this target date, all funds should be in the<br />Treasury Account and none left in the Vester Account.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## EscrowAddress

<a id="opIdEscrowAddress"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address`

*EscrowAddress returns the escrow address for a particular port and channel id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|unique channel identifier|
|port_id|path|string|true|unique port identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» escrow_address|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomHash

<a id="opIdDenomHash"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/apps/transfer/v1/denom_hashes/{trace}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/apps/transfer/v1/denom_hashes/{trace}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/apps/transfer/v1/denom_hashes/{trace}`

*DenomHash queries a denomination hash information.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|trace|path|string|true|The denomination trace ([port_id]/[channel_id])+/[denom]|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDenomHashResponse is the response type for the Query/DenomHash RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» hash|string|false|none|hash (in hex format) of the denomination trace information.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomTraces

<a id="opIdDenomTraces"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/apps/transfer/v1/denom_traces', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/apps/transfer/v1/denom_traces',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/apps/transfer/v1/denom_traces`

*DenomTraces queries all denomination traces.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» denom_traces|[object]|false|none|denom_traces returns all denominations trace information.|
|»» path|string|false|none|path defines the chain of port/channel identifiers used for tracing the<br />source of the fungible token.|
|»» base_denom|string|false|none|base denomination of the relayed fungible token.|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomTrace

<a id="opIdDenomTrace"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/apps/transfer/v1/denom_traces/{hash}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/apps/transfer/v1/denom_traces/{hash}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/apps/transfer/v1/denom_traces/{hash}`

*DenomTrace queries a denomination trace information.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|hash|path|string|true|hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» denom_trace|object|false|none|DenomTrace contains the base denomination for ICS20 fungible tokens and the<br />source tracing information path.|
|»» path|string|false|none|path defines the chain of port/channel identifiers used for tracing the<br />source of the fungible token.|
|»» base_denom|string|false|none|base denomination of the relayed fungible token.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## TotalEscrowForDenom

<a id="opIdTotalEscrowForDenom"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/apps/transfer/v1/denoms/{denom}/total_escrow', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/apps/transfer/v1/denoms/{denom}/total_escrow',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/apps/transfer/v1/denoms/{denom}/total_escrow`

*TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|denom|path|string|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» amount|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## IbcTransferParams

<a id="opIdIbcTransferParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/apps/transfer/v1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/apps/transfer/v1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/apps/transfer/v1/params`

*Params queries all parameters of the ibc-transfer module.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» send_enabled|boolean|false|none|send_enabled enables or disables all cross-chain token transfers from this<br />chain.|
|»» receive_enabled|boolean|false|none|receive_enabled enables or disables all cross-chain token transfers to this<br />chain.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ClientStates

<a id="opIdClientStates"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/client_states', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/client_states',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/client_states`

*ClientStates queries all the IBC light clients of a chain.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClientStatesResponse is the response type for the Query/ClientStates RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» client_states|[object]|false|none|list of stored ClientStates of the chain.|
|»» client_id|string|false|none|none|
|»» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ClientState

<a id="opIdClientState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/client_states/{client_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/client_states/{client_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/client_states/{client_id}`

*ClientState queries an IBC light client.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|client_id|path|string|true|client state unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClientStateResponse is the response type for the Query/ClientState RPC
method. Besides the client state, it includes a proof and the height from
which the proof was retrieved.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ClientStatus

<a id="opIdClientStatus"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/client_status/{client_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/client_status/{client_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/client_status/{client_id}`

*Status queries the status of an IBC client.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|client_id|path|string|true|client unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
method. It returns the current status of the IBC client.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» status|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ConsensusStates

<a id="opIdConsensusStates"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/consensus_states/{client_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/consensus_states/{client_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/consensus_states/{client_id}`

*ConsensusStates queries all the consensus state associated with a given
client.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|client_id|path|string|true|client identifier|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConsensusStatesResponse is the response type for the
Query/ConsensusStates RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» consensus_states|[object]|false|none|none|
|»» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»»» revision_number|string(uint64)|false|none|none|
|»»» revision_height|string(uint64)|false|none|none|
|»» consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ConsensusStateHeights

<a id="opIdConsensusStateHeights"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/consensus_states/{client_id}/heights', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/consensus_states/{client_id}/heights',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/consensus_states/{client_id}/heights`

*ConsensusStateHeights queries the height of every consensus states associated with a given client.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|client_id|path|string|true|client identifier|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConsensusStateHeightsResponse is the response type for the
Query/ConsensusStateHeights RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» consensus_state_heights|[object]|false|none|none|
|»» Height is a monotonically increasing data type
that can be compared against another Height for the purposes of updating and
freezing clients|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»»» revision_number|string(uint64)|false|none|none|
|»»» revision_height|string(uint64)|false|none|none|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ConsensusState

<a id="opIdConsensusState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}`

*ConsensusState queries a consensus state associated with a client state at
a given height.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|client_id|path|string|true|client identifier|
|revision_number|path|string(uint64)|true|consensus state revision number|
|revision_height|path|string(uint64)|true|consensus state revision height|
|latest_height|query|boolean|false|latest_height overrides the height field and queries the latest stored|

#### Detailed descriptions

**latest_height**: latest_height overrides the height field and queries the latest stored
ConsensusState.

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConsensusStateResponse is the response type for the Query/ConsensusState
RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## IbcClientParams

<a id="opIdIbcClientParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/params`

*ClientParams queries all parameters of the ibc client submodule.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClientParamsResponse is the response type for the Query/ClientParams RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» allowed_clients|[string]|false|none|allowed_clients defines the list of allowed client state types which can be created<br />and interacted with. If a client type is removed from the allowed clients list, usage<br />of this client will be disabled until it is added again to the list.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## UpgradedClientState

<a id="opIdUpgradedClientState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/upgraded_client_states', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/upgraded_client_states',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/upgraded_client_states`

*UpgradedClientState queries an Upgraded IBC light client.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUpgradedClientStateResponse is the response type for the
Query/UpgradedClientState RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» upgraded_client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## IbcUpgradedConsensusState

<a id="opIdIbcUpgradedConsensusState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/client/v1/upgraded_consensus_states', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/upgraded_consensus_states',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/client/v1/upgraded_consensus_states`

*UpgradedConsensusState queries an Upgraded IBC consensus state.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUpgradedConsensusStateResponse is the response type for the
Query/UpgradedConsensusState RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» upgraded_consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## VerifyMembership

<a id="opIdVerifyMembership"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/ibc/core/client/v1/verify_membership', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "client_id": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  },
  "merkle_path": {
    "key_path": [
      "string"
    ]
  },
  "value": "string",
  "time_delay": "string",
  "block_delay": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/ibc/core/client/v1/verify_membership',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /ibc/core/client/v1/verify_membership`

*VerifyMembership queries an IBC light client for proof verification of a value at a given key path.*

> Body parameter

```json
{
  "client_id": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  },
  "merkle_path": {
    "key_path": [
      "string"
    ]
  },
  "value": "string",
  "time_delay": "string",
  "block_delay": "string"
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|object|true|none|
|» client_id|body|string|false|client unique identifier.|
|» proof|body|string(byte)|false|the proof to be verified by the client.|
|» proof_height|body|object|false|Normally the RevisionHeight is incremented at each height while keeping|
|»» revision_number|body|string(uint64)|false|none|
|»» revision_height|body|string(uint64)|false|none|
|» merkle_path|body|object|false|the commitment key path.|
|»» key_path|body|[string]|false|none|
|» value|body|string(byte)|false|the value which is proven.|
|» time_delay|body|string(uint64)|false|none|
|» block_delay|body|string(uint64)|false|none|

#### Detailed descriptions

**» proof_height**: Normally the RevisionHeight is incremented at each height while keeping
RevisionNumber the same. However some consensus algorithms may choose to
reset the height in certain conditions e.g. hard forks, state-machine
breaking changes In these cases, the RevisionNumber is incremented so that
height continues to be monitonically increasing even as the RevisionHeight
gets reset

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryVerifyMembershipResponse is the response type for the Query/VerifyMembership RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» success|boolean|false|none|boolean indicating success or failure of proof verification.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ClientConnections

<a id="opIdClientConnections"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/connection/v1/client_connections/{client_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/connection/v1/client_connections/{client_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/connection/v1/client_connections/{client_id}`

*ClientConnections queries the connection paths associated with a client
state.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|client_id|path|string|true|client identifier associated with a connection|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryClientConnectionsResponse is the response type for the
Query/ClientConnections RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» connection_paths|[string]|false|none|slice of all the connection paths associated with a client.|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Connections

<a id="opIdConnections"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/connection/v1/connections', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/connection/v1/connections',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/connection/v1/connections`

*Connections queries all the IBC connections of a chain.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionsResponse is the response type for the Query/Connections RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» connections|[object]|false|none|list of stored connections of the chain.|
|»» id|string|false|none|connection identifier.|
|»» client_id|string|false|none|client associated with this connection.|
|»» versions|[object]|false|none|none|
|»»» identifier|string|false|none|none|
|»»» features|[string]|false|none|none|
|»» state|string|false|none|current state of the connection end.|
|»» counterparty|object|false|none|counterparty chain associated with this connection.|
|»»» client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|»»» connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|»»» prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|»»»» key_prefix|string(byte)|false|none|none|
|»» delay_period|string(uint64)|false|none|delay period associated with this connection.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Connection

<a id="opIdConnection"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/connection/v1/connections/{connection_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/connection/v1/connections/{connection_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/connection/v1/connections/{connection_id}`

*Connection queries an IBC connection end.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|connection_id|path|string|true|connection unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionResponse is the response type for the Query/Connection RPC
method. Besides the connection end, it includes a proof and the height from
which the proof was retrieved.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» connection|object|false|none|ConnectionEnd defines a stateful object on a chain connected to another<br />separate one.<br />NOTE: there must only be 2 defined ConnectionEnds to establish<br />a connection between two chains.|
|»» client_id|string|false|none|client associated with this connection.|
|»» versions|[object]|false|none|IBC version which can be utilised to determine encodings or protocols for<br />channels or packets utilising this connection.|
|»»» identifier|string|false|none|none|
|»»» features|[string]|false|none|none|
|»» state|string|false|none|current state of the connection end.|
|»» counterparty|object|false|none|counterparty chain associated with this connection.|
|»»» client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|»»» connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|»»» prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|»»»» key_prefix|string(byte)|false|none|none|
|»» delay_period|string(uint64)|false|none|delay period that must pass before a consensus state can be used for<br />packet-verification NOTE: delay period logic is only implemented by some<br />clients.|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ConnectionClientState

<a id="opIdConnectionClientState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/connection/v1/connections/{connection_id}/client_state', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/connection/v1/connections/{connection_id}/client_state',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/connection/v1/connections/{connection_id}/client_state`

*ConnectionClientState queries the client state associated with the
connection.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|connection_id|path|string|true|connection identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionClientStateResponse is the response type for the
Query/ConnectionClientState RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» identified_client_state|object|false|none|IdentifiedClientState defines a client state with an additional client<br />identifier field.|
|»» client_id|string|false|none|none|
|»» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ConnectionConsensusState

<a id="opIdConnectionConsensusState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}`

*ConnectionConsensusState queries the consensus state associated with the
connection.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|connection_id|path|string|true|connection identifier|
|revision_number|path|string(uint64)|true|none|
|revision_height|path|string(uint64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionConsensusStateResponse is the response type for the
Query/ConnectionConsensusState RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» client_id|string|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## IbcConnectionParams

<a id="opIdIbcConnectionParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/connection/v1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/connection/v1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/connection/v1/params`

*ConnectionParams queries all parameters of the ibc connection submodule.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» max_expected_time_per_block|string(uint64)|false|none|maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the<br />largest amount of time that the chain might reasonably take to produce the next block under normal operating<br />conditions. A safe choice is 3-5x the expected time per block.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Channels

<a id="opIdChannels"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels`

*Channels queries all the IBC channels of a chain.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryChannelsResponse is the response type for the Query/Channels RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» channels|[object]|false|none|list of stored channels of the chain.|
|»» state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|»» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|»» counterparty|object|false|none|none|
|»»» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|»»» channel_id|string|false|none|none|
|»» connection_hops|[string]|false|none|none|
|»» version|string|false|none|none|
|»» port_id|string|false|none|none|
|»» channel_id|string|false|none|none|
|»» upgrade_sequence|string(uint64)|false|none|none|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Channel

<a id="opIdChannel"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}`

*Channel queries an IBC Channel.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryChannelResponse is the response type for the Query/Channel RPC method.
Besides the Channel end, it includes a proof and the height from which the
proof was retrieved.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» channel|object|false|none|Channel defines pipeline for exactly-once packet delivery between specific<br />modules on separate blockchains, which has at least one end capable of<br />sending packets and one end capable of receiving packets.|
|»» state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|»» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|»» counterparty|object|false|none|none|
|»»» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|»»» channel_id|string|false|none|none|
|»» connection_hops|[string]|false|none|none|
|»» version|string|false|none|none|
|»» upgrade_sequence|string(uint64)|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ChannelClientState

<a id="opIdChannelClientState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state`

*ChannelClientState queries for the client state for the channel associated
with the provided channel identifiers.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» identified_client_state|object|false|none|IdentifiedClientState defines a client state with an additional client<br />identifier field.|
|»» client_id|string|false|none|none|
|»» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ChannelConsensusState

<a id="opIdChannelConsensusState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}`

*ChannelConsensusState queries for the consensus state for the channel
associated with the provided channel identifiers.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|revision_number|path|string(uint64)|true|revision number of the consensus state|
|revision_height|path|string(uint64)|true|revision height of the consensus state|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» client_id|string|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## NextSequenceReceive

<a id="opIdNextSequenceReceive"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence`

*NextSequenceReceive returns the next receive sequence for a given channel.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySequenceResponse is the response type for the
Query/QueryNextSequenceReceiveResponse RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» next_sequence_receive|string(uint64)|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## NextSequenceSend

<a id="opIdNextSequenceSend"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send`

*NextSequenceSend returns the next send sequence for a given channel.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryNextSequenceSendResponse is the request type for the
Query/QueryNextSequenceSend RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» next_sequence_send|string(uint64)|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## PacketAcknowledgements

<a id="opIdPacketAcknowledgements"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements`

*PacketAcknowledgements returns all the packet acknowledgements associated
with a channel.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|
|packet_commitment_sequences|query|array[string]|false|list of packet sequences.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPacketAcknowledgemetsResponse is the request type for the
Query/QueryPacketAcknowledgements RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» acknowledgements|[object]|false|none|none|
|»» port_id|string|false|none|channel port identifier.|
|»» channel_id|string|false|none|channel unique identifier.|
|»» sequence|string(uint64)|false|none|packet sequence.|
|»» data|string(byte)|false|none|embedded data that represents packet state.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## PacketAcknowledgement

<a id="opIdPacketAcknowledgement"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}`

*PacketAcknowledgement queries a stored packet acknowledgement hash.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|sequence|path|string(uint64)|true|packet sequence|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPacketAcknowledgementResponse defines the client query response for a
packet which also includes a proof and the height from which the
proof was retrieved*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» acknowledgement|string(byte)|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## PacketCommitments

<a id="opIdPacketCommitments"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments`

*PacketCommitments returns all the packet commitments hashes associated
with a channel.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPacketCommitmentsResponse is the request type for the
Query/QueryPacketCommitments RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» commitments|[object]|false|none|none|
|»» port_id|string|false|none|channel port identifier.|
|»» channel_id|string|false|none|channel unique identifier.|
|»» sequence|string(uint64)|false|none|packet sequence.|
|»» data|string(byte)|false|none|embedded data that represents packet state.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## UnreceivedAcks

<a id="opIdUnreceivedAcks"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks`

*UnreceivedAcks returns all the unreceived IBC acknowledgements associated
with a channel and sequences.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|packet_ack_sequences|path|array[string]|true|list of acknowledgement sequences|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUnreceivedAcksResponse is the response type for the
Query/UnreceivedAcks RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» sequences|[string]|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## UnreceivedPackets

<a id="opIdUnreceivedPackets"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets`

*UnreceivedPackets returns all the unreceived IBC packets associated with a
channel and sequences.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|packet_commitment_sequences|path|array[string]|true|list of packet sequences|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUnreceivedPacketsResponse is the response type for the
Query/UnreceivedPacketCommitments RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» sequences|[string]|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## PacketCommitment

<a id="opIdPacketCommitment"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}`

*PacketCommitment queries a stored packet commitment hash.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|sequence|path|string(uint64)|true|packet sequence|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPacketCommitmentResponse defines the client query response for a packet
which also includes a proof and the height from which the proof was
retrieved*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» commitment|string(byte)|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## PacketReceipt

<a id="opIdPacketReceipt"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}`

*PacketReceipt queries if a given packet sequence has been received on the
queried chain*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|channel unique identifier|
|port_id|path|string|true|port unique identifier|
|sequence|path|string(uint64)|true|packet sequence|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPacketReceiptResponse defines the client query response for a packet
receipt which also includes a proof, and the height from which the proof was
retrieved*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» received|boolean|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Upgrade

<a id="opIdUpgrade"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade`

*Upgrade returns the upgrade for a given port and channel id.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|none|
|port_id|path|string|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUpgradeResponse is the response type for the QueryUpgradeResponse RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» upgrade|object|false|none|Upgrade is a verifiable type which contains the relevant information<br />for an attempted upgrade. It provides the proposed changes to the channel<br />end, the timeout for this upgrade attempt and the next packet sequence<br />which allows the counterparty to efficiently know the highest sequence it has received.<br />The next sequence send is used for pruning and upgrading from unordered to ordered channels.|
|»» fields|object|false|none|UpgradeFields are the fields in a channel end which may be changed<br />during a channel upgrade.|
|»»» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|»»» connection_hops|[string]|false|none|none|
|»»» version|string|false|none|none|
|»» timeout|object|false|none|Timeout defines an execution deadline structure for 04-channel handlers.<br />This includes packet lifecycle handlers as well as the upgrade handshake handlers.<br />A valid Timeout contains either one or both of a timestamp and block height (sequence).|
|»»» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»»»» revision_number|string(uint64)|false|none|none|
|»»»» revision_height|string(uint64)|false|none|none|
|»»» timestamp|string(uint64)|false|none|none|
|»» next_sequence_send|string(uint64)|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## UpgradeError

<a id="opIdUpgradeError"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade_error', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade_error',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/upgrade_error`

*UpgradeError returns the error receipt if the upgrade handshake failed.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|channel_id|path|string|true|none|
|port_id|path|string|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUpgradeErrorResponse is the response type for the Query/QueryUpgradeError RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error_receipt|object|false|none|ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the<br />upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the<br />next sequence.|
|»» sequence|string(uint64)|false|none|none|
|»» message|string|false|none|none|
|» proof|string(byte)|false|none|none|
|» proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ConnectionChannels

<a id="opIdConnectionChannels"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/connections/{connection}/channels', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/connections/{connection}/channels',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/connections/{connection}/channels`

*ConnectionChannels queries all the channels associated with a connection
end.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|connection|path|string|true|connection unique identifier|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryConnectionChannelsResponse is the Response type for the
Query/QueryConnectionChannels RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» channels|[object]|false|none|list of channels associated with a connection.|
|»» state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|»» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|»» counterparty|object|false|none|none|
|»»» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|»»» channel_id|string|false|none|none|
|»» connection_hops|[string]|false|none|none|
|»» version|string|false|none|none|
|»» port_id|string|false|none|none|
|»» channel_id|string|false|none|none|
|»» upgrade_sequence|string(uint64)|false|none|none|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ChannelParams

<a id="opIdChannelParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/ibc/core/channel/v1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/ibc/core/channel/v1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /ibc/core/channel/v1/params`

*ChannelParams queries all parameters of the ibc channel submodule.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryChannelParamsResponse is the response type for the Query/ChannelParams RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» upgrade_timeout|object|false|none|Timeout defines an execution deadline structure for 04-channel handlers.<br />This includes packet lifecycle handlers as well as the upgrade handshake handlers.<br />A valid Timeout contains either one or both of a timestamp and block height (sequence).|
|»»» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»»»» revision_number|string(uint64)|false|none|none|
|»»»» revision_height|string(uint64)|false|none|none|
|»»» timestamp|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AccountInfo

<a id="opIdAccountInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/account_info/{address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/account_info/{address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/account_info/{address}`

*AccountInfo queries account info which is common to all account types.*

Since: cosmos-sdk 0.47

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|path|string|true|address is the account address string.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAccountInfoResponse is the Query/AccountInfo response type.

Since: cosmos-sdk 0.47*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» info|object|false|none|info is the account info which is represented by BaseAccount.|
|»» address|string|false|none|none|
|»» pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» account_number|string(uint64)|false|none|none|
|»» sequence|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Accounts

<a id="opIdAccounts"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/accounts', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/accounts',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/accounts`

*Accounts returns all the existing accounts.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

Since: cosmos-sdk 0.43

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAccountsResponse is the response type for the Query/Accounts RPC method.

Since: cosmos-sdk 0.43*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» accounts|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Account

<a id="opIdAccount"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/accounts/{address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/accounts/{address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/accounts/{address}`

*Account returns account details based on address.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|path|string|true|address defines the address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAccountResponse is the response type for the Query/Account RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» account|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AccountAddressByID

<a id="opIdAccountAddressByID"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/address_by_id/{id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/address_by_id/{id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/address_by_id/{id}`

*AccountAddressByID returns account address based on account number.*

Since: cosmos-sdk 0.46.2

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|id|path|string(int64)|true|Deprecated, use account_id instead|
|account_id|query|string(uint64)|false|account_id is the account number of the address to be queried.|

#### Detailed descriptions

**id**: Deprecated, use account_id instead

id is the account number of the address to be queried. This field
should have been an uint64 (like all account numbers), and will be
updated to uint64 in a future version of the auth query.

**account_id**: account_id is the account number of the address to be queried.

Since: cosmos-sdk 0.47

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» account_address|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Bech32Prefix

<a id="opIdBech32Prefix"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/bech32', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/bech32',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/bech32`

*Bech32Prefix queries bech32Prefix*

Since: cosmos-sdk 0.46

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*Bech32PrefixResponse is the response type for Bech32Prefix rpc method.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» bech32_prefix|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AddressBytesToString

<a id="opIdAddressBytesToString"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/bech32/{address_bytes}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/bech32/{address_bytes}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/bech32/{address_bytes}`

*AddressBytesToString converts Account Address bytes to string*

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address_bytes|path|string(byte)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*AddressBytesToStringResponse is the response type for AddressString rpc method.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» address_string|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AddressStringToBytes

<a id="opIdAddressStringToBytes"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/bech32/{address_string}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/bech32/{address_string}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/bech32/{address_string}`

*AddressStringToBytes converts Address string to bytes*

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address_string|path|string|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*AddressStringToBytesResponse is the response type for AddressBytes rpc method.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» address_bytes|string(byte)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ModuleAccounts

<a id="opIdModuleAccounts"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/module_accounts', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/module_accounts',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/module_accounts`

*ModuleAccounts returns all the existing module accounts.*

Since: cosmos-sdk 0.46

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» accounts|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ModuleAccountByName

<a id="opIdModuleAccountByName"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/module_accounts/{name}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/module_accounts/{name}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/module_accounts/{name}`

*ModuleAccountByName returns the module account info by module name*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|name|path|string|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» account|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AuthParams

<a id="opIdAuthParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/auth/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/auth/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/auth/v1beta1/params`

*Params queries all parameters.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» max_memo_characters|string(uint64)|false|none|none|
|»» tx_sig_limit|string(uint64)|false|none|none|
|»» tx_size_cost_per_byte|string(uint64)|false|none|none|
|»» sig_verify_cost_ed25519|string(uint64)|false|none|none|
|»» sig_verify_cost_secp256k1|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Grants

<a id="opIdGrants"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/authz/v1beta1/grants', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/authz/v1beta1/grants',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/authz/v1beta1/grants`

*Returns list of `Authorization`, granted to the grantee by the granter.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|granter|query|string|false|none|
|grantee|query|string|false|none|
|msg_type_url|query|string|false|Optional, msg_type_url, when set, will query only grants matching given msg type.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGrantsResponse is the response type for the Query/Authorizations RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» grants|[object]|false|none|authorizations is a list of grants granted for grantee by granter.|
|»» authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» expiration|string(date-time)|false|none|none|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GranteeGrants

<a id="opIdGranteeGrants"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/authz/v1beta1/grants/grantee/{grantee}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/authz/v1beta1/grants/grantee/{grantee}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/authz/v1beta1/grants/grantee/{grantee}`

*GranteeGrants returns a list of `GrantAuthorization` by grantee.*

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|grantee|path|string|true|none|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» grants|[object]|false|none|grants is a list of grants granted to the grantee.|
|»» GrantAuthorization extends a grant with both the addresses of the grantee and granter.
It is used in genesis.proto and query.proto|object|false|none|none|
|»»» granter|string|false|none|none|
|»»» grantee|string|false|none|none|
|»»» authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»»» expiration|string(date-time)|false|none|none|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GranterGrants

<a id="opIdGranterGrants"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/authz/v1beta1/grants/granter/{granter}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/authz/v1beta1/grants/granter/{granter}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/authz/v1beta1/grants/granter/{granter}`

*GranterGrants returns list of `GrantAuthorization`, granted by granter.*

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|granter|path|string|true|none|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» grants|[object]|false|none|grants is a list of grants granted by the granter.|
|»» GrantAuthorization extends a grant with both the addresses of the grantee and granter.
It is used in genesis.proto and query.proto|object|false|none|none|
|»»» granter|string|false|none|none|
|»»» grantee|string|false|none|none|
|»»» authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»»» expiration|string(date-time)|false|none|none|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AllBalances

<a id="opIdAllBalances"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/balances/{address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/balances/{address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/balances/{address}`

*AllBalances queries the balance of all coins for a single account.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|path|string|true|address is the address to query balances for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|
|resolve_denom|query|boolean|false|resolve_denom is the flag to resolve the denom into a human-readable form from the metadata.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

**resolve_denom**: resolve_denom is the flag to resolve the denom into a human-readable form from the metadata.

Since: cosmos-sdk 0.50

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» balances|[object]|false|none|balances is the balances of all the coins.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Balance

<a id="opIdBalance"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/balances/{address}/by_denom', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/balances/{address}/by_denom',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/balances/{address}/by_denom`

*Balance queries the balance of a single coin for a single account.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|path|string|true|address is the address to query balances for.|
|denom|query|string|false|denom is the coin denom to query balances for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryBalanceResponse is the response type for the Query/Balance RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomOwners

<a id="opIdDenomOwners"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/denom_owners/{denom}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/denom_owners/{denom}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/denom_owners/{denom}`

*DenomOwners queries for all account addresses that own a particular token
denomination.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|denom|path|string|true|denom defines the coin denomination to query all account holders for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» denom_owners|[object]|false|none|none|
|»» address|string|false|none|address defines the address that owns a particular denomination.|
|»» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomsMetadata

<a id="opIdDenomsMetadata"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/denoms_metadata', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/denoms_metadata',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/denoms_metadata`

*DenomsMetadata queries the client metadata for all registered coin
denominations.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» metadatas|[object]|false|none|metadata provides the client information for all the registered tokens.|
|»» description|string|false|none|none|
|»» denom_units|[object]|false|none|none|
|»»» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|»»» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|»»» aliases|[string]|false|none|none|
|»» base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|»» display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|»» name|string|false|none|Since: cosmos-sdk 0.43|
|»» symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|»» uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|»» uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomMetadata

<a id="opIdDenomMetadata"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/denoms_metadata/{denom}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/denoms_metadata/{denom}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/denoms_metadata/{denom}`

*DenomsMetadata queries the client metadata of a given coin denomination.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|denom|path|string|true|denom is the coin denom to query the metadata for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» metadata|object|false|none|Metadata represents a struct that describes<br />a basic token.|
|»» description|string|false|none|none|
|»» denom_units|[object]|false|none|none|
|»»» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|»»» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|»»» aliases|[string]|false|none|none|
|»» base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|»» display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|»» name|string|false|none|Since: cosmos-sdk 0.43|
|»» symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|»» uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|»» uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DenomMetadataByQueryString

<a id="opIdDenomMetadataByQueryString"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/denoms_metadata_by_query_string', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/denoms_metadata_by_query_string',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/denoms_metadata_by_query_string`

*DenomsMetadata queries the client metadata of a given coin denomination.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|denom|query|string|false|denom is the coin denom to query the metadata for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC
method. Identical with QueryDenomMetadataResponse but receives denom as query string in request.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» metadata|object|false|none|Metadata represents a struct that describes<br />a basic token.|
|»» description|string|false|none|none|
|»» denom_units|[object]|false|none|none|
|»»» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|»»» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|»»» aliases|[string]|false|none|none|
|»» base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|»» display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|»» name|string|false|none|Since: cosmos-sdk 0.43|
|»» symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|»» uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|»» uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## BankParams

<a id="opIdBankParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/params`

*Params queries the parameters of x/bank module.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse defines the response type for querying x/bank parameters.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params provides the parameters of the bank module.|
|»» send_enabled|[object]|false|none|Deprecated: Use of SendEnabled in params is deprecated.<br />For genesis, use the newly added send_enabled field in the genesis object.<br />Storage, lookup, and manipulation of this information is now in the keeper.<br /><br />As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.|
|»»» denom|string|false|none|none|
|»»» enabled|boolean|false|none|none|
|»» default_send_enabled|boolean|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SendEnabled

<a id="opIdSendEnabled"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/send_enabled', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/send_enabled',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/send_enabled`

*SendEnabled queries for SendEnabled entries.*

This query only returns denominations that have specific SendEnabled settings.
Any denomination that does not have a specific setting will use the default
params.default_send_enabled, and will not be returned by this query.

Since: cosmos-sdk 0.47

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|denoms|query|array[string]|false|denoms is the specific denoms you want look up. Leave empty to get all entries.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySendEnabledResponse defines the RPC response of a SendEnable query.

Since: cosmos-sdk 0.47*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» send_enabled|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» enabled|boolean|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response. This field is only<br />populated if the denoms field in the request is empty.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SpendableBalances

<a id="opIdSpendableBalances"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/spendable_balances/{address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/spendable_balances/{address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/spendable_balances/{address}`

*SpendableBalances queries the spendable balance of all coins for a single
account.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|path|string|true|address is the address to query spendable balances for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySpendableBalancesResponse defines the gRPC response structure for querying
an account's spendable balances.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» balances|[object]|false|none|balances is the spendable balances of all the coins.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SpendableBalanceByDenom

<a id="opIdSpendableBalanceByDenom"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/spendable_balances/{address}/by_denom`

*SpendableBalanceByDenom queries the spendable balance of a single denom for
a single account.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

Since: cosmos-sdk 0.47

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|address|path|string|true|address is the address to query balances for.|
|denom|query|string|false|denom is the coin denom to query balances for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySpendableBalanceByDenomResponse defines the gRPC response structure for
querying an account's spendable balance for a specific denom.

Since: cosmos-sdk 0.47*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## TotalSupply

<a id="opIdTotalSupply"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/supply', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/supply',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/supply`

*TotalSupply queries the total supply of all coins.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» supply|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.<br /><br />Since: cosmos-sdk 0.43|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SupplyOf

<a id="opIdSupplyOf"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/bank/v1beta1/supply/by_denom', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/bank/v1beta1/supply/by_denom',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/bank/v1beta1/supply/by_denom`

*SupplyOf queries the supply of a single coin.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|denom|query|string|false|denom is the coin denom to query balances for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» amount|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## CommunityPool

<a id="opIdCommunityPool"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/community_pool', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/community_pool',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/community_pool`

*CommunityPool queries the community pool coins.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryCommunityPoolResponse is the response type for the Query/CommunityPool
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» pool|[object]|false|none|pool defines community pool's coins.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DelegationTotalRewards

<a id="opIdDelegationTotalRewards"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards`

*DelegationTotalRewards queries the total rewards accrued by each
validator.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_address|path|string|true|delegator_address defines the delegator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegationTotalRewardsResponse is the response type for the
Query/DelegationTotalRewards RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» rewards|[object]|false|none|rewards defines all the rewards accrued by a delegator.|
|»» validator_address|string|false|none|none|
|»» reward|[object]|false|none|none|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|» total|[object]|false|none|total defines the sum of all the rewards.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DelegationRewards

<a id="opIdDelegationRewards"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}`

*DelegationRewards queries the total rewards accrued by a delegation.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_address|path|string|true|delegator_address defines the delegator address to query for.|
|validator_address|path|string|true|validator_address defines the validator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegationRewardsResponse is the response type for the
Query/DelegationRewards RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» rewards|[object]|false|none|rewards defines the rewards accrued by a delegation.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DistDelegatorValidators

<a id="opIdDistDelegatorValidators"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/delegators/{delegator_address}/validators`

*DelegatorValidators queries the validators of a delegator.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_address|path|string|true|delegator_address defines the delegator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegatorValidatorsResponse is the response type for the
Query/DelegatorValidators RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» validators|[string]|false|none|validators defines the validators a delegator is delegating for.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DelegatorWithdrawAddress

<a id="opIdDelegatorWithdrawAddress"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address`

*DelegatorWithdrawAddress queries withdraw address of a delegator.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_address|path|string|true|delegator_address defines the delegator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegatorWithdrawAddressResponse is the response type for the
Query/DelegatorWithdrawAddress RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» withdraw_address|string|false|none|withdraw_address defines the delegator address to query for.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DistributionParams

<a id="opIdDistributionParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/params`

*Params queries params of the distribution module.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» community_tax|string|false|none|none|
|»» base_proposer_reward|string|false|none|Deprecated: The base_proposer_reward field is deprecated and is no longer used<br />in the x/distribution module's reward mechanism.|
|»» bonus_proposer_reward|string|false|none|Deprecated: The bonus_proposer_reward field is deprecated and is no longer used<br />in the x/distribution module's reward mechanism.|
|»» withdraw_addr_enabled|boolean|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ValidatorDistributionInfo

<a id="opIdValidatorDistributionInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/validators/{validator_address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/validators/{validator_address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/validators/{validator_address}`

*ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_address|path|string|true|validator_address defines the validator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» operator_address|string|false|none|operator_address defines the validator operator address.|
|» self_bond_rewards|[object]|false|none|self_bond_rewards defines the self delegations rewards.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» commission|[object]|false|none|commission defines the commission the validator received.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ValidatorCommission

<a id="opIdValidatorCommission"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/validators/{validator_address}/commission', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/validators/{validator_address}/commission',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/validators/{validator_address}/commission`

*ValidatorCommission queries accumulated commission for a validator.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_address|path|string|true|validator_address defines the validator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorCommissionResponse is the response type for the
Query/ValidatorCommission RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» commission|object|false|none|commission defines the commission the validator received.|
|»» commission|[object]|false|none|none|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ValidatorOutstandingRewards

<a id="opIdValidatorOutstandingRewards"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards`

*ValidatorOutstandingRewards queries rewards of a validator address.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_address|path|string|true|validator_address defines the validator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorOutstandingRewardsResponse is the response type for the
Query/ValidatorOutstandingRewards RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» rewards|object|false|none|ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards<br />for a validator inexpensive to track, allows simple sanity checks.|
|»» rewards|[object]|false|none|none|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## ValidatorSlashes

<a id="opIdValidatorSlashes"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/distribution/v1beta1/validators/{validator_address}/slashes', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/distribution/v1beta1/validators/{validator_address}/slashes',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/distribution/v1beta1/validators/{validator_address}/slashes`

*ValidatorSlashes queries slash events of a validator.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_address|path|string|true|validator_address defines the validator address to query for.|
|starting_height|query|string(uint64)|false|starting_height defines the optional starting height to query the slashes.|
|ending_height|query|string(uint64)|false|starting_height defines the optional ending height to query the slashes.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorSlashesResponse is the response type for the
Query/ValidatorSlashes RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» slashes|[object]|false|none|slashes defines the slashes the validator received.|
|»» validator_period|string(uint64)|false|none|none|
|»» fraction|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## AllEvidence

<a id="opIdAllEvidence"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/evidence/v1beta1/evidence', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/evidence/v1beta1/evidence',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/evidence/v1beta1/evidence`

*AllEvidence queries all evidence.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» evidence|[object]|false|none|evidence returns all evidences.|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Evidence

<a id="opIdEvidence"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/evidence/v1beta1/evidence/{hash}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/evidence/v1beta1/evidence/{hash}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/evidence/v1beta1/evidence/{hash}`

*Evidence queries evidence based on evidence hash.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|hash|path|string|true|hash defines the evidence hash of the requested evidence.|
|evidence_hash|query|string(byte)|false|evidence_hash defines the hash of the requested evidence.|

#### Detailed descriptions

**hash**: hash defines the evidence hash of the requested evidence.

Since: cosmos-sdk 0.47

**evidence_hash**: evidence_hash defines the hash of the requested evidence.
Deprecated: Use hash, a HEX encoded string, instead.

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryEvidenceResponse is the response type for the Query/Evidence RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» evidence|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Allowance

<a id="opIdAllowance"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}`

*Allowance returns granted allwance to the grantee by the granter.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|granter|path|string|true|granter is the address of the user granting an allowance of their funds.|
|grantee|path|string|true|grantee is the address of the user being granted an allowance of another user's funds.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllowanceResponse is the response type for the Query/Allowance RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» allowance|object|false|none|allowance is a allowance granted for grantee by granter.|
|»» granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|»» grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|»» allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Allowances

<a id="opIdAllowances"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/feegrant/v1beta1/allowances/{grantee}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/feegrant/v1beta1/allowances/{grantee}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/feegrant/v1beta1/allowances/{grantee}`

*Allowances returns all the grants for the given grantee address.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|grantee|path|string|true|none|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllowancesResponse is the response type for the Query/Allowances RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» allowances|[object]|false|none|allowances are allowance's granted for grantee by granter.|
|»» Grant is stored in the KVStore to record a grant with full context|object|false|none|none|
|»»» granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|»»» grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|»»» allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|»»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AllowancesByGranter

<a id="opIdAllowancesByGranter"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/feegrant/v1beta1/issued/{granter}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/feegrant/v1beta1/issued/{granter}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/feegrant/v1beta1/issued/{granter}`

*AllowancesByGranter returns all the grants given by an address*

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|granter|path|string|true|none|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» allowances|[object]|false|none|allowances that have been issued by the granter.|
|»» Grant is stored in the KVStore to record a grant with full context|object|false|none|none|
|»»» granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|»»» grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|»»» allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|»»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GovParams

<a id="opIdGovParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/params/{params_type}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/params/{params_type}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/params/{params_type}`

*Params queries all parameters of the gov module.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|params_type|path|string|true|params_type defines which parameters to query for, can be one of "voting",|

#### Detailed descriptions

**params_type**: params_type defines which parameters to query for, can be one of "voting",
"tallying" or "deposit".

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» voting_params|object|false|none|voting_params defines the parameters related to voting.|
|»» voting_period|string|false|none|Duration of the voting period.|
|» deposit_params|object|false|none|deposit_params defines the parameters related to deposit.|
|»» min_deposit|[object]|false|none|Minimum deposit for a proposal to enter voting period.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|»» max_deposit_period|string|false|none|Maximum period for Atom holders to deposit on a proposal. Initial value: 2<br />months.|
|» tally_params|object|false|none|tally_params defines the parameters related to tally.|
|»» quorum|string(byte)|false|none|Minimum percentage of total stake needed to vote for a result to be<br />considered valid.|
|»» threshold|string(byte)|false|none|Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.|
|»» veto_threshold|string(byte)|false|none|Minimum value of Veto votes to Total votes ratio for proposal to be<br />vetoed. Default value: 1/3.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Proposals

<a id="opIdProposals"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals`

*Proposals queries all proposals based on given status.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_status|query|string|false|proposal_status defines the status of the proposals.|
|voter|query|string|false|voter defines the voter address for the proposals.|
|depositor|query|string|false|depositor defines the deposit addresses from the proposals.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**proposal_status**: proposal_status defines the status of the proposals.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed.

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

#### Enumerated Values

|Parameter|Value|
|---|---|
|proposal_status|PROPOSAL_STATUS_UNSPECIFIED|
|proposal_status|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|proposal_status|PROPOSAL_STATUS_VOTING_PERIOD|
|proposal_status|PROPOSAL_STATUS_PASSED|
|proposal_status|PROPOSAL_STATUS_REJECTED|
|proposal_status|PROPOSAL_STATUS_FAILED|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryProposalsResponse is the response type for the Query/Proposals RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» proposals|[object]|false|none|proposals defines all the requested governance proposals.|
|»» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|»» content|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» status|string|false|none|status defines the proposal status.|
|»» final_tally_result|object|false|none|final_tally_result is the final tally result of the proposal. When<br />querying a proposal via gRPC, this field is not populated until the<br />proposal's voting period has ended.|
|»»» yes|string|false|none|yes is the number of yes votes on a proposal.|
|»»» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|»»» no|string|false|none|no is the number of no votes on a proposal.|
|»»» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|
|»» submit_time|string(date-time)|false|none|submit_time is the time of proposal submission.|
|»» deposit_end_time|string(date-time)|false|none|deposit_end_time is the end time for deposition.|
|»» total_deposit|[object]|false|none|total_deposit is the total deposit on the proposal.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|»» voting_start_time|string(date-time)|false|none|voting_start_time is the starting time to vote on a proposal.|
|»» voting_end_time|string(date-time)|false|none|voting_end_time is the end time of voting on a proposal.|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|PROPOSAL_STATUS_UNSPECIFIED|
|status|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|status|PROPOSAL_STATUS_VOTING_PERIOD|
|status|PROPOSAL_STATUS_PASSED|
|status|PROPOSAL_STATUS_REJECTED|
|status|PROPOSAL_STATUS_FAILED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Proposal

<a id="opIdProposal"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals/{proposal_id}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals/{proposal_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals/{proposal_id}`

*Proposal queries proposal details based on ProposalID.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_id|path|string(uint64)|true|proposal_id defines the unique id of the proposal.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryProposalResponse is the response type for the Query/Proposal RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» proposal|object|false|none|Proposal defines the core field members of a governance proposal.|
|»» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|»» content|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» status|string|false|none|status defines the proposal status.|
|»» final_tally_result|object|false|none|final_tally_result is the final tally result of the proposal. When<br />querying a proposal via gRPC, this field is not populated until the<br />proposal's voting period has ended.|
|»»» yes|string|false|none|yes is the number of yes votes on a proposal.|
|»»» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|»»» no|string|false|none|no is the number of no votes on a proposal.|
|»»» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|
|»» submit_time|string(date-time)|false|none|submit_time is the time of proposal submission.|
|»» deposit_end_time|string(date-time)|false|none|deposit_end_time is the end time for deposition.|
|»» total_deposit|[object]|false|none|total_deposit is the total deposit on the proposal.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|»» voting_start_time|string(date-time)|false|none|voting_start_time is the starting time to vote on a proposal.|
|»» voting_end_time|string(date-time)|false|none|voting_end_time is the end time of voting on a proposal.|

#### Enumerated Values

|Property|Value|
|---|---|
|status|PROPOSAL_STATUS_UNSPECIFIED|
|status|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|status|PROPOSAL_STATUS_VOTING_PERIOD|
|status|PROPOSAL_STATUS_PASSED|
|status|PROPOSAL_STATUS_REJECTED|
|status|PROPOSAL_STATUS_FAILED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Deposits

<a id="opIdDeposits"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals/{proposal_id}/deposits`

*Deposits queries all deposits of a single proposal.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_id|path|string(uint64)|true|proposal_id defines the unique id of the proposal.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDepositsResponse is the response type for the Query/Deposits RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» deposits|[object]|false|none|deposits defines the requested deposits.|
|»» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|»» depositor|string|false|none|depositor defines the deposit addresses from the proposals.|
|»» amount|[object]|false|none|amount to be deposited by depositor.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Deposit

<a id="opIdDeposit"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}`

*Deposit queries single deposit information based on proposalID, depositor address.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_id|path|string(uint64)|true|proposal_id defines the unique id of the proposal.|
|depositor|path|string|true|depositor defines the deposit addresses from the proposals.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDepositResponse is the response type for the Query/Deposit RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» deposit|object|false|none|Deposit defines an amount deposited by an account address to an active<br />proposal.|
|»» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|»» depositor|string|false|none|depositor defines the deposit addresses from the proposals.|
|»» amount|[object]|false|none|amount to be deposited by depositor.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## TallyResult

<a id="opIdTallyResult"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals/{proposal_id}/tally', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals/{proposal_id}/tally',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals/{proposal_id}/tally`

*TallyResult queries the tally of a proposal vote.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_id|path|string(uint64)|true|proposal_id defines the unique id of the proposal.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryTallyResultResponse is the response type for the Query/Tally RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» tally|object|false|none|tally defines the requested tally.|
|»» yes|string|false|none|yes is the number of yes votes on a proposal.|
|»» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|»» no|string|false|none|no is the number of no votes on a proposal.|
|»» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Votes

<a id="opIdVotes"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals/{proposal_id}/votes', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals/{proposal_id}/votes',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals/{proposal_id}/votes`

*Votes queries votes of a given proposal.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_id|path|string(uint64)|true|proposal_id defines the unique id of the proposal.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryVotesResponse is the response type for the Query/Votes RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» votes|[object]|false|none|votes defines the queried votes.|
|»» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|»» voter|string|false|none|voter is the voter address of the proposal.|
|»» option|string|false|none|Deprecated: Prefer to use `options` instead. This field is set in queries<br />if and only if `len(options) == 1` and that option has weight 1. In all<br />other cases, this field will default to VOTE_OPTION_UNSPECIFIED.|
|»» options|[object]|false|none|options is the weighted vote options.<br /><br />Since: cosmos-sdk 0.43|
|»»» option|string|false|none|option defines the valid vote options, it must not contain duplicate vote options.|
|»»» weight|string|false|none|weight is the vote weight associated with the vote option.|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Vote

<a id="opIdVote"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}`

*Vote queries voted information based on proposalID, voterAddr.
Due to how we handle state, this query would error for proposals that has already been finished.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|proposal_id|path|string(uint64)|true|proposal_id defines the unique id of the proposal.|
|voter|path|string|true|voter defines the voter address for the proposals.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryVoteResponse is the response type for the Query/Vote RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» vote|object|false|none|Vote defines a vote on a governance proposal.<br />A Vote consists of a proposal ID, the voter, and the vote option.|
|»» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|»» voter|string|false|none|voter is the voter address of the proposal.|
|»» option|string|false|none|Deprecated: Prefer to use `options` instead. This field is set in queries<br />if and only if `len(options) == 1` and that option has weight 1. In all<br />other cases, this field will default to VOTE_OPTION_UNSPECIFIED.|
|»» options|[object]|false|none|options is the weighted vote options.<br /><br />Since: cosmos-sdk 0.43|
|»»» option|string|false|none|option defines the valid vote options, it must not contain duplicate vote options.|
|»»» weight|string|false|none|weight is the vote weight associated with the vote option.|

#### Enumerated Values

|Property|Value|
|---|---|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AnnualProvisions

<a id="opIdAnnualProvisions"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/mint/v1beta1/annual_provisions', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/mint/v1beta1/annual_provisions',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/mint/v1beta1/annual_provisions`

*AnnualProvisions current minting annual provisions value.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAnnualProvisionsResponse is the response type for the
Query/AnnualProvisions RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» annual_provisions|string(byte)|false|none|annual_provisions is the current minting annual provisions value.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Inflation

<a id="opIdInflation"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/mint/v1beta1/inflation', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/mint/v1beta1/inflation',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/mint/v1beta1/inflation`

*Inflation returns the current minting inflation value.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryInflationResponse is the response type for the Query/Inflation RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» inflation|string(byte)|false|none|inflation is the current minting inflation value.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## MintParams

<a id="opIdMintParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/mint/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/mint/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/mint/v1beta1/params`

*Params returns the total set of minting parameters.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params defines the parameters of the module.|
|»» mint_denom|string|false|none|none|
|»» inflation_rate_change|string|false|none|none|
|»» inflation_max|string|false|none|none|
|»» inflation_min|string|false|none|none|
|»» goal_bonded|string|false|none|none|
|»» blocks_per_year|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Params

<a id="opIdParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/params/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/params/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/params/v1beta1/params`

*Params queries a specific parameter of a module, given its subspace and
key.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|subspace|query|string|false|subspace defines the module to query the parameter for.|
|key|query|string|false|key defines the key of the parameter in the subspace.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» param|object|false|none|param defines the queried parameter.|
|»» subspace|string|false|none|none|
|»» key|string|false|none|none|
|»» value|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## Subspaces

<a id="opIdSubspaces"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/params/v1beta1/subspaces', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/params/v1beta1/subspaces',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/params/v1beta1/subspaces`

*Subspaces queries for all registered subspaces and all keys for a subspace.*

Since: cosmos-sdk 0.46

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySubspacesResponse defines the response types for querying for all
registered subspaces and all keys for a subspace.

Since: cosmos-sdk 0.46*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» subspaces|[object]|false|none|none|
|»» subspace|string|false|none|none|
|»» keys|[string]|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SlashingParams

<a id="opIdSlashingParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/slashing/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/slashing/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/slashing/v1beta1/params`

*Params queries the parameters of slashing module*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is the response type for the Query/Params RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|Params represents the parameters used for by the slashing module.|
|»» signed_blocks_window|string(int64)|false|none|none|
|»» min_signed_per_window|string(byte)|false|none|none|
|»» downtime_jail_duration|string|false|none|none|
|»» slash_fraction_double_sign|string(byte)|false|none|none|
|»» slash_fraction_downtime|string(byte)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SigningInfos

<a id="opIdSigningInfos"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/slashing/v1beta1/signing_infos', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/slashing/v1beta1/signing_infos',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/slashing/v1beta1/signing_infos`

*SigningInfos queries signing info of all validators*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» info|[object]|false|none|none|
|»» address|string|false|none|none|
|»» start_height|string(int64)|false|none|none|
|»» index_offset|string(int64)|false|none|Index which is incremented every time a validator is bonded in a block and<br />_may_ have signed a pre-commit or not. This in conjunction with the<br />signed_blocks_window param determines the index in the missed block bitmap.|
|»» jailed_until|string(date-time)|false|none|Timestamp until which the validator is jailed due to liveness downtime.|
|»» tombstoned|boolean|false|none|Whether or not a validator has been tombstoned (killed out of validator<br />set). It is set once the validator commits an equivocation or for any other<br />configured misbehavior.|
|»» missed_blocks_counter|string(int64)|false|none|A counter of missed (unsigned) blocks. It is used to avoid unnecessary<br />reads in the missed block bitmap.|
|» pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## SigningInfo

<a id="opIdSigningInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/slashing/v1beta1/signing_infos/{cons_address}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/slashing/v1beta1/signing_infos/{cons_address}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/slashing/v1beta1/signing_infos/{cons_address}`

*SigningInfo queries the signing info of given cons address*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|cons_address|path|string|true|cons_address is the address to query signing info of|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» val_signing_info|object|false|none|ValidatorSigningInfo defines a validator's signing info for monitoring their<br />liveness activity.|
|»» address|string|false|none|none|
|»» start_height|string(int64)|false|none|none|
|»» index_offset|string(int64)|false|none|Index which is incremented every time a validator is bonded in a block and<br />_may_ have signed a pre-commit or not. This in conjunction with the<br />signed_blocks_window param determines the index in the missed block bitmap.|
|»» jailed_until|string(date-time)|false|none|Timestamp until which the validator is jailed due to liveness downtime.|
|»» tombstoned|boolean|false|none|Whether or not a validator has been tombstoned (killed out of validator<br />set). It is set once the validator commits an equivocation or for any other<br />configured misbehavior.|
|»» missed_blocks_counter|string(int64)|false|none|A counter of missed (unsigned) blocks. It is used to avoid unnecessary<br />reads in the missed block bitmap.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|none|
|»» value|string(byte)|false|none|none|

<aside class="success">
This operation does not require authentication
</aside>

## DelegatorDelegations

<a id="opIdDelegatorDelegations"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/delegations/{delegator_addr}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/delegations/{delegator_addr}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/delegations/{delegator_addr}`

*DelegatorDelegations queries all delegations of a given delegator address.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegatorDelegationsResponse is response type for the
Query/DelegatorDelegations RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» delegation_responses|[object]|false|none|delegation_responses defines all the delegations' info of a delegator.|
|»» delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|»»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»»» shares|string|false|none|shares define the delegation shares received.|
|»» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Redelegations

<a id="opIdRedelegations"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations`

*Redelegations queries redelegations of given address.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|
|src_validator_addr|query|string|false|src_validator_addr defines the validator address to redelegate from.|
|dst_validator_addr|query|string|false|dst_validator_addr defines the validator address to redelegate to.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryRedelegationsResponse is response type for the Query/Redelegations RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» redelegation_responses|[object]|false|none|none|
|»» redelegation|object|false|none|Redelegation contains the list of a particular delegator's redelegating bonds<br />from a particular source validator to a particular destination validator.|
|»»» delegator_address|string|false|none|delegator_address is the bech32-encoded address of the delegator.|
|»»» validator_src_address|string|false|none|validator_src_address is the validator redelegation source operator address.|
|»»» validator_dst_address|string|false|none|validator_dst_address is the validator redelegation destination operator address.|
|»»» entries|[object]|false|none|entries are the redelegation entries.|
|»»»» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|»»»» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|»»»» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|»»»» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|»»»» unbonding_id|string(uint64)|false|none|none|
|»»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» entries|[object]|false|none|none|
|»»» redelegation_entry|object|false|none|RedelegationEntry defines a redelegation object with relevant metadata.|
|»»»» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|»»»» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|»»»» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|»»»» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|»»»» unbonding_id|string(uint64)|false|none|none|
|»»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»»» balance|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## DelegatorUnbondingDelegations

<a id="opIdDelegatorUnbondingDelegations"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations`

*DelegatorUnbondingDelegations queries all unbonding delegations of a given
delegator address.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUnbondingDelegatorDelegationsResponse is response type for the
Query/UnbondingDelegatorDelegations RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» unbonding_responses|[object]|false|none|none|
|»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»» entries|[object]|false|none|entries are the unbonding delegation entries.|
|»»» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|»»» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|»»» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|»»» balance|string|false|none|balance defines the tokens to receive at completion.|
|»»» unbonding_id|string(uint64)|false|none|none|
|»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## DelegatorValidators

<a id="opIdDelegatorValidators"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/delegators/{delegator_addr}/validators`

*DelegatorValidators queries all validators info for given delegator
address.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegatorValidatorsResponse is response type for the
Query/DelegatorValidators RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» validators|[object]|false|none|validators defines the validators' info of a delegator.|
|»» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|»» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|»» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|»» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|»» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|»» description|object|false|none|description defines the description terms for the validator.|
|»»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»»» website|string|false|none|website defines an optional website link.|
|»»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»»» details|string|false|none|details define other optional details.|
|»» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|»» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|»» commission|object|false|none|commission defines the commission parameters.|
|»»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|»» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» unbonding_ids|[string]|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## DelegatorValidator

<a id="opIdDelegatorValidator"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}`

*DelegatorValidator queries validator info for given delegator validator
pair.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|
|validator_addr|path|string|true|validator_addr defines the validator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegatorValidatorResponse response type for the
Query/DelegatorValidator RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» validator|object|false|none|Validator defines a validator, together with the total amount of the<br />Validator's bond shares and their exchange rate to coins. Slashing results in<br />a decrease in the exchange rate, allowing correct calculation of future<br />undelegations without iterating over delegators. When coins are delegated to<br />this validator, the validator is credited with a delegation whose number of<br />bond shares is based on the amount of coins delegated divided by the current<br />exchange rate. Voting power can be calculated as total bonded shares<br />multiplied by exchange rate.|
|»» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|»» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|»» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|»» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|»» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|»» description|object|false|none|description defines the description terms for the validator.|
|»»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»»» website|string|false|none|website defines an optional website link.|
|»»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»»» details|string|false|none|details define other optional details.|
|»» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|»» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|»» commission|object|false|none|commission defines the commission parameters.|
|»»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|»» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## HistoricalInfo

<a id="opIdHistoricalInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/historical_info/{height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/historical_info/{height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/historical_info/{height}`

*HistoricalInfo queries the historical info for given height.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|height|path|string(int64)|true|height defines at which height to query the historical info.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» hist|object|false|none|hist defines the historical info at the given height.|
|»» header|object|false|none|Header defines the structure of a block header.|
|»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»» block|string(uint64)|false|none|none|
|»»»» app|string(uint64)|false|none|none|
|»»» chain_id|string|false|none|none|
|»»» height|string(int64)|false|none|none|
|»»» time|string(date-time)|false|none|none|
|»»» last_block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» last_commit_hash|string(byte)|false|none|none|
|»»» data_hash|string(byte)|false|none|none|
|»»» validators_hash|string(byte)|false|none|none|
|»»» next_validators_hash|string(byte)|false|none|none|
|»»» consensus_hash|string(byte)|false|none|none|
|»»» app_hash|string(byte)|false|none|none|
|»»» last_results_hash|string(byte)|false|none|none|
|»»» evidence_hash|string(byte)|false|none|none|
|»»» proposer_address|string(byte)|false|none|none|
|»» valset|[object]|false|none|none|
|»»» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|»»» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»»» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|»»» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|»»» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|»»» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|»»» description|object|false|none|description defines the description terms for the validator.|
|»»»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»»»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»»»» website|string|false|none|website defines an optional website link.|
|»»»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»»»» details|string|false|none|details define other optional details.|
|»»» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|»»» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|»»» commission|object|false|none|commission defines the commission parameters.|
|»»»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»»»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|»»» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»»» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## StakingParams

<a id="opIdStakingParams"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/params', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/params',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/params`

*Parameters queries the staking parameters.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryParamsResponse is response type for the Query/Params RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» params|object|false|none|params holds all the parameters of this module.|
|»» unbonding_time|string|false|none|unbonding_time is the time duration of unbonding.|
|»» max_validators|integer(int64)|false|none|max_validators is the maximum number of validators.|
|»» max_entries|integer(int64)|false|none|max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).|
|»» historical_entries|integer(int64)|false|none|historical_entries is the number of historical entries to persist.|
|»» bond_denom|string|false|none|bond_denom defines the bondable coin denomination.|
|»» min_commission_rate|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Pool

<a id="opIdPool"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/pool', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/pool',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/pool`

*Pool queries the pool info.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryPoolResponse is response type for the Query/Pool RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» pool|object|false|none|pool defines the pool info.|
|»» not_bonded_tokens|string|false|none|none|
|»» bonded_tokens|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Validators

<a id="opIdValidators"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/validators', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/validators',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/validators`

*Validators queries all validators that match the given status.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|status|query|string|false|status enables to query for validators matching a given status.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorsResponse is response type for the Query/Validators RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» validators|[object]|false|none|validators contains all the queried validators.|
|»» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|»» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|»» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|»» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|»» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|»» description|object|false|none|description defines the description terms for the validator.|
|»»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»»» website|string|false|none|website defines an optional website link.|
|»»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»»» details|string|false|none|details define other optional details.|
|»» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|»» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|»» commission|object|false|none|commission defines the commission parameters.|
|»»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|»» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» unbonding_ids|[string]|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Validator

<a id="opIdValidator"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/validators/{validator_addr}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/validators/{validator_addr}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/validators/{validator_addr}`

*Validator queries validator info for given validator address.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_addr|path|string|true|validator_addr defines the validator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorResponse is response type for the Query/Validator RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» validator|object|false|none|Validator defines a validator, together with the total amount of the<br />Validator's bond shares and their exchange rate to coins. Slashing results in<br />a decrease in the exchange rate, allowing correct calculation of future<br />undelegations without iterating over delegators. When coins are delegated to<br />this validator, the validator is credited with a delegation whose number of<br />bond shares is based on the amount of coins delegated divided by the current<br />exchange rate. Voting power can be calculated as total bonded shares<br />multiplied by exchange rate.|
|»» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|»» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|»» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|»» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|»» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|»» description|object|false|none|description defines the description terms for the validator.|
|»»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»»» website|string|false|none|website defines an optional website link.|
|»»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»»» details|string|false|none|details define other optional details.|
|»» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|»» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|»» commission|object|false|none|commission defines the commission parameters.|
|»»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|»» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ValidatorDelegations

<a id="opIdValidatorDelegations"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/validators/{validator_addr}/delegations', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/validators/{validator_addr}/delegations',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/validators/{validator_addr}/delegations`

*ValidatorDelegations queries delegate info for given validator.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_addr|path|string|true|validator_addr defines the validator address to query for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorDelegationsResponse is response type for the
Query/ValidatorDelegations RPC method*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» delegation_responses|[object]|false|none|none|
|»» delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|»»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»»» shares|string|false|none|shares define the delegation shares received.|
|»» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Delegation

<a id="opIdDelegation"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}`

*Delegation queries delegate info for given validator delegator pair.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_addr|path|string|true|validator_addr defines the validator address to query for.|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegationResponse is response type for the Query/Delegation RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» delegation_response|object|false|none|DelegationResponse is equivalent to Delegation except that it contains a<br />balance in addition to shares which is more suitable for client responses.|
|»» delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|»»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»»» shares|string|false|none|shares define the delegation shares received.|
|»» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## UnbondingDelegation

<a id="opIdUnbondingDelegation"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation`

*UnbondingDelegation queries unbonding info for given validator delegator
pair.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_addr|path|string|true|validator_addr defines the validator address to query for.|
|delegator_addr|path|string|true|delegator_addr defines the delegator address to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryDelegationResponse is response type for the Query/UnbondingDelegation
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» unbond|object|false|none|UnbondingDelegation stores all of a single delegator's unbonding bonds<br />for a single validator in an time-ordered list.|
|»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»» entries|[object]|false|none|entries are the unbonding delegation entries.|
|»»» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|»»» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|»»» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|»»» balance|string|false|none|balance defines the tokens to receive at completion.|
|»»» unbonding_id|string(uint64)|false|none|none|
|»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ValidatorUnbondingDelegations

<a id="opIdValidatorUnbondingDelegations"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations`

*ValidatorUnbondingDelegations queries unbonding delegations of a validator.*

When called from another module, this query might consume a high amount of
gas if the pagination field is incorrectly set.

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|validator_addr|path|string|true|validator_addr defines the validator address to query for.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryValidatorUnbondingDelegationsResponse is response type for the
Query/ValidatorUnbondingDelegations RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» unbonding_responses|[object]|false|none|none|
|»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»» entries|[object]|false|none|entries are the unbonding delegation entries.|
|»»» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|»»» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|»»» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|»»» balance|string|false|none|balance defines the tokens to receive at completion.|
|»»» unbonding_id|string(uint64)|false|none|none|
|»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» pagination|object|false|none|pagination defines the pagination in the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## AppliedPlan

<a id="opIdAppliedPlan"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/upgrade/v1beta1/applied_plan/{name}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/upgrade/v1beta1/applied_plan/{name}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/upgrade/v1beta1/applied_plan/{name}`

*AppliedPlan queries a previously applied upgrade plan by its name.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|name|path|string|true|name is the name of the applied plan to query for.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» height|string(int64)|false|none|height is the block height at which the plan was applied.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Authority

<a id="opIdAuthority"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/upgrade/v1beta1/authority', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/upgrade/v1beta1/authority',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/upgrade/v1beta1/authority`

*Returns the account with authority to conduct upgrades*

Since: cosmos-sdk 0.46

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryAuthorityResponse is the response type for Query/Authority*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» address|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## CurrentPlan

<a id="opIdCurrentPlan"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/upgrade/v1beta1/current_plan', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/upgrade/v1beta1/current_plan',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/upgrade/v1beta1/current_plan`

*CurrentPlan queries the current upgrade plan.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC
method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» plan|object|false|none|plan is the current upgrade plan.|
|»» name|string|false|none|Sets the name for the upgrade. This name will be used by the upgraded<br />version of the software to apply any special "on-upgrade" commands during<br />the first BeginBlock method after the upgrade is applied. It is also used<br />to detect whether a software version can handle a given upgrade. If no<br />upgrade handler with this name has been set in the software, it will be<br />assumed that the software is out-of-date when the upgrade Time or Height is<br />reached and the software will exit.|
|»» time|string(date-time)|false|none|Deprecated: Time based upgrades have been deprecated. Time based upgrade logic<br />has been removed from the SDK.<br />If this field is not empty, an error will be thrown.|
|»» height|string(int64)|false|none|The height at which the upgrade must be performed.|
|»» info|string|false|none|none|
|»» upgraded_client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ModuleVersions

<a id="opIdModuleVersions"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/upgrade/v1beta1/module_versions', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/upgrade/v1beta1/module_versions',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/upgrade/v1beta1/module_versions`

*ModuleVersions queries the list of module versions from state.*

Since: cosmos-sdk 0.43

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|module_name|query|string|false|module_name is a field to query a specific module|

#### Detailed descriptions

**module_name**: module_name is a field to query a specific module
consensus version from state. Leaving this empty will
fetch the full list of module versions from state.

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryModuleVersionsResponse is the response type for the Query/ModuleVersions
RPC method.

Since: cosmos-sdk 0.43*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» module_versions|[object]|false|none|module_versions is a list of module names with their consensus versions.|
|»» name|string|false|none|none|
|»» version|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## UpgradedConsensusState

<a id="opIdUpgradedConsensusState"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}`

*UpgradedConsensusState queries the consensus state that will serve
as a trusted kernel for the next version of this chain. It will only be
stored at the last height of this chain.
UpgradedConsensusState RPC not supported with legacy querier
This rpc is deprecated now that IBC has its own replacement
(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|last_height|path|string(int64)|true|last height of the current chain must be sent in request|

#### Detailed descriptions

**last_height**: last height of the current chain must be sent in request
as this is the height under which next consensus state is stored

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState
RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» upgraded_consensus_state|string(byte)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

# Service

## TxDecode

<a id="opIdTxDecode"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/cosmos/tx/v1beta1/decode', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "tx_bytes": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/decode',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /cosmos/tx/v1beta1/decode`

*TxDecode decodes the transaction.*

Since: cosmos-sdk 0.47

> Body parameter

```json
{
  "tx_bytes": "string"
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|object|true|none|
|» tx_bytes|body|string(byte)|false|tx_bytes is the raw transaction.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|[cosmos.tx.v1beta1.TxDecodeResponse](#schemacosmos.tx.v1beta1.txdecoderesponse)|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## TxDecodeAmino

<a id="opIdTxDecodeAmino"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/cosmos/tx/v1beta1/decode/amino', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "amino_binary": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/decode/amino',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /cosmos/tx/v1beta1/decode/amino`

*TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.*

Since: cosmos-sdk 0.47

> Body parameter

```json
{
  "amino_binary": "string"
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|object|true|none|
|» amino_binary|body|string(byte)|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino
RPC method.

Since: cosmos-sdk 0.47*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» amino_json|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## TxEncode

<a id="opIdTxEncode"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/cosmos/tx/v1beta1/encode', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  }
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/encode',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /cosmos/tx/v1beta1/encode`

*TxEncode encodes the transaction.*

Since: cosmos-sdk 0.47

> Body parameter

```json
{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  }
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[cosmos.tx.v1beta1.TxEncodeRequest](#schemacosmos.tx.v1beta1.txencoderequest)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*TxEncodeResponse is the response type for the
Service.TxEncode method.

Since: cosmos-sdk 0.47*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» tx_bytes|string(byte)|false|none|tx_bytes is the encoded transaction bytes.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## TxEncodeAmino

<a id="opIdTxEncodeAmino"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/cosmos/tx/v1beta1/encode/amino', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "amino_json": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/encode/amino',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /cosmos/tx/v1beta1/encode/amino`

*TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.*

Since: cosmos-sdk 0.47

> Body parameter

```json
{
  "amino_json": "string"
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|object|true|none|
|» amino_json|body|string|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino
RPC method.

Since: cosmos-sdk 0.47*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» amino_binary|string(byte)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## Simulate

<a id="opIdSimulate"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/cosmos/tx/v1beta1/simulate', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  },
  "tx_bytes": "string"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/simulate',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /cosmos/tx/v1beta1/simulate`

*Simulate simulates executing a transaction for estimating gas usage.*

> Body parameter

```json
{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  },
  "tx_bytes": "string"
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|[cosmos.tx.v1beta1.SimulateRequest](#schemacosmos.tx.v1beta1.simulaterequest)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*SimulateResponse is the response type for the
Service.SimulateRPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» gas_info|object|false|none|gas_info is the information about gas used in the simulation.|
|»» gas_wanted|string(uint64)|false|none|GasWanted is the maximum units of work we allow this tx to perform.|
|»» gas_used|string(uint64)|false|none|GasUsed is the amount of gas actually consumed.|
|» result|object|false|none|result is the result of the simulation.|
|»» data|string(byte)|false|none|Data is any data returned from message or handler execution. It MUST be<br />length prefixed in order to separate data from multiple message executions.<br />Deprecated. This field is still populated, but prefer msg_response instead<br />because it also contains the Msg response typeURL.|
|»» log|string|false|none|Log contains the log information from message or handler execution.|
|»» events|[object]|false|none|Events contains a slice of Event objects that were emitted during message<br />or handler execution.|
|»»» type|string|false|none|none|
|»»» attributes|[object]|false|none|none|
|»»»» key|string|false|none|none|
|»»»» value|string|false|none|none|
|»»»» index|boolean|false|none|none|
|»» msg_responses|[object]|false|none|msg_responses contains the Msg handler responses type packed in Anys.<br /><br />Since: cosmos-sdk 0.46|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetTxsEvent

<a id="opIdGetTxsEvent"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/tx/v1beta1/txs', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/txs',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/tx/v1beta1/txs`

*GetTxsEvent fetches txs by event.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|events|query|array[string]|false|events is the list of transaction event type.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|
|order_by|query|string|false| - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults|
|page|query|string(uint64)|false|page is the page number to query, starts at 1. If not provided, will|
|limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|query|query|string|false|query defines the transaction event query that is proxied to Tendermint's|

#### Detailed descriptions

**events**: events is the list of transaction event type.
Deprecated post v0.47.x: use query instead, which should contain a valid
events query.

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

**order_by**:  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults
to ASC in this case.
 - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
 - ORDER_BY_DESC: ORDER_BY_DESC defines descending order

**page**: page is the page number to query, starts at 1. If not provided, will
default to first page.

**limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**query**: query defines the transaction event query that is proxied to Tendermint's
TxSearch RPC method. The query must be valid.

Since cosmos-sdk 0.50

#### Enumerated Values

|Parameter|Value|
|---|---|
|order_by|ORDER_BY_UNSPECIFIED|
|order_by|ORDER_BY_ASC|
|order_by|ORDER_BY_DESC|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|[cosmos.tx.v1beta1.GetTxsEventResponse](#schemacosmos.tx.v1beta1.gettxseventresponse)|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## BroadcastTx

<a id="opIdBroadcastTx"></a>

> Code samples

```python
import requests
headers = {
  'Content-Type': 'application/json',
  'Accept': '*/*'
}

r = requests.post('/cosmos/tx/v1beta1/txs', headers = headers)

print(r.json())

```

```javascript
const inputBody = '{
  "tx_bytes": "string",
  "mode": "BROADCAST_MODE_UNSPECIFIED"
}';
const headers = {
  'Content-Type':'application/json',
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/txs',
{
  method: 'POST',
  body: inputBody,
  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`POST /cosmos/tx/v1beta1/txs`

*BroadcastTx broadcast transaction.*

> Body parameter

```json
{
  "tx_bytes": "string",
  "mode": "BROADCAST_MODE_UNSPECIFIED"
}
```

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|body|body|object|true|none|
|» tx_bytes|body|string(byte)|false|tx_bytes is the raw transaction.|
|» mode|body|string|false|BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC|

#### Detailed descriptions

**» mode**: BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
method.

 - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
 - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
 - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
for a CheckTx execution response only.
 - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
returns immediately.

#### Enumerated Values

|Parameter|Value|
|---|---|
|» mode|BROADCAST_MODE_UNSPECIFIED|
|» mode|BROADCAST_MODE_BLOCK|
|» mode|BROADCAST_MODE_SYNC|
|» mode|BROADCAST_MODE_ASYNC|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*BroadcastTxResponse is the response type for the
Service.BroadcastTx method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» tx_response|object|false|none|TxResponse defines a structure containing relevant tx data and metadata. The<br />tags are stringified and the log is JSON decoded.|
|»» height|string(int64)|false|none|none|
|»» txhash|string|false|none|The transaction hash.|
|»» codespace|string|false|none|none|
|»» code|integer(int64)|false|none|Response code.|
|»» data|string|false|none|Result bytes, if any.|
|»» raw_log|string|false|none|The output of the application's logger (raw string). May be<br />non-deterministic.|
|»» logs|[object]|false|none|The output of the application's logger (typed). May be non-deterministic.|
|»»» msg_index|integer(int64)|false|none|none|
|»»» log|string|false|none|none|
|»»» events|[object]|false|none|Events contains a slice of Event objects that were emitted during some<br />execution.|
|»»»» type|string|false|none|none|
|»»»» attributes|[object]|false|none|none|
|»»»»» key|string|false|none|none|
|»»»»» value|string|false|none|none|
|»» info|string|false|none|Additional information. May be non-deterministic.|
|»» gas_wanted|string(int64)|false|none|Amount of gas requested for transaction.|
|»» gas_used|string(int64)|false|none|Amount of gas consumed by transaction.|
|»» tx|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» timestamp|string|false|none|Time of the previous block. For heights > 1, it's the weighted median of<br />the timestamps of the valid votes in the block.LastCommit. For height == 1,<br />it's genesis time.|
|»» events|[object]|false|none|Events defines all the events emitted by processing a transaction. Note,<br />these events include those emitted by processing all the messages and those<br />emitted from the ante. Whereas Logs contains the events, with<br />additional metadata, emitted only by processing the messages.<br /><br />Since: cosmos-sdk 0.42.11, 0.44.5, 0.45|
|»»» type|string|false|none|none|
|»»» attributes|[object]|false|none|none|
|»»»» key|string|false|none|none|
|»»»» value|string|false|none|none|
|»»»» index|boolean|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetBlockWithTxs

<a id="opIdGetBlockWithTxs"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/tx/v1beta1/txs/block/{height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/txs/block/{height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/tx/v1beta1/txs/block/{height}`

*GetBlockWithTxs fetches a block with decoded txs.*

Since: cosmos-sdk 0.45.2

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|height|path|string(int64)|true|height is the height of the block to query.|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|[cosmos.tx.v1beta1.GetBlockWithTxsResponse](#schemacosmos.tx.v1beta1.getblockwithtxsresponse)|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetTx

<a id="opIdGetTx"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/tx/v1beta1/txs/{hash}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/tx/v1beta1/txs/{hash}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/tx/v1beta1/txs/{hash}`

*GetTx fetches a tx by hash.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|hash|path|string|true|hash is the tx hash to query, encoded as a hex string.|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|[cosmos.tx.v1beta1.GetTxResponse](#schemacosmos.tx.v1beta1.gettxresponse)|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## ABCIQuery

<a id="opIdABCIQuery"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/abci_query', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/abci_query',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/abci_query`

*ABCIQuery defines a query handler that supports ABCI queries directly to the
application, bypassing Tendermint completely. The ABCI query must contain
a valid and supported path, including app, custom, p2p, and store.*

Since: cosmos-sdk 0.46

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|data|query|string(byte)|false|none|
|path|query|string|false|none|
|height|query|string(int64)|false|none|
|prove|query|boolean|false|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.

Note: This type is a duplicate of the ResponseQuery proto type defined in
Tendermint.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» code|integer(int64)|false|none|none|
|» log|string|false|none|none|
|» info|string|false|none|none|
|» index|string(int64)|false|none|none|
|» key|string(byte)|false|none|none|
|» value|string(byte)|false|none|none|
|» proof_ops|object|false|none|ProofOps is Merkle proof defined by the list of ProofOps.<br /><br />Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.|
|»» ops|[object]|false|none|none|
|»»» type|string|false|none|none|
|»»» key|string(byte)|false|none|none|
|»»» data|string(byte)|false|none|none|
|» height|string(int64)|false|none|none|
|» codespace|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetLatestBlock

<a id="opIdGetLatestBlock"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/blocks/latest', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/blocks/latest',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/blocks/latest`

*GetLatestBlock returns the latest block.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» block|object|false|none|none|
|»» header|object|false|none|Header defines the structure of a block header.|
|»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»» block|string(uint64)|false|none|none|
|»»»» app|string(uint64)|false|none|none|
|»»» chain_id|string|false|none|none|
|»»» height|string(int64)|false|none|none|
|»»» time|string(date-time)|false|none|none|
|»»» last_block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» last_commit_hash|string(byte)|false|none|none|
|»»» data_hash|string(byte)|false|none|none|
|»»» validators_hash|string(byte)|false|none|none|
|»»» next_validators_hash|string(byte)|false|none|none|
|»»» consensus_hash|string(byte)|false|none|none|
|»»» app_hash|string(byte)|false|none|none|
|»»» last_results_hash|string(byte)|false|none|none|
|»»» evidence_hash|string(byte)|false|none|none|
|»»» proposer_address|string(byte)|false|none|none|
|»» data|object|false|none|none|
|»»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|»» evidence|object|false|none|none|
|»»» evidence|[object]|false|none|none|
|»»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» validator_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»»» conflicting_block|object|false|none|none|
|»»»»»» signed_header|object|false|none|none|
|»»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»»» chain_id|string|false|none|none|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»»» block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»»» signature|string(byte)|false|none|none|
|»»»»»» validator_set|object|false|none|none|
|»»»»»»» validators|[object]|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» proposer|object|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» common_height|string(int64)|false|none|none|
|»»»»» byzantine_validators|[object]|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» signatures|[object]|false|none|none|
|»»»» block_id_flag|string|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» signature|string(byte)|false|none|none|
|» sdk_block|object|false|none|Block is tendermint type Block, with the Header proposer address<br />field converted to bech32 string.|
|»» header|object|false|none|Header defines the structure of a Tendermint block header.|
|»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»» block|string(uint64)|false|none|none|
|»»»» app|string(uint64)|false|none|none|
|»»» chain_id|string|false|none|none|
|»»» height|string(int64)|false|none|none|
|»»» time|string(date-time)|false|none|none|
|»»» last_block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» last_commit_hash|string(byte)|false|none|none|
|»»» data_hash|string(byte)|false|none|none|
|»»» validators_hash|string(byte)|false|none|none|
|»»» next_validators_hash|string(byte)|false|none|none|
|»»» consensus_hash|string(byte)|false|none|none|
|»»» app_hash|string(byte)|false|none|none|
|»»» last_results_hash|string(byte)|false|none|none|
|»»» evidence_hash|string(byte)|false|none|none|
|»»» proposer_address|string|false|none|proposer_address is the original block proposer address, formatted as a Bech32 string.<br />In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string<br />for better UX.|
|»» data|object|false|none|none|
|»»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|»» evidence|object|false|none|none|
|»»» evidence|[object]|false|none|none|
|»»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» validator_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»»» conflicting_block|object|false|none|none|
|»»»»»» signed_header|object|false|none|none|
|»»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»»» chain_id|string|false|none|none|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»»» block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»»» signature|string(byte)|false|none|none|
|»»»»»» validator_set|object|false|none|none|
|»»»»»»» validators|[object]|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» proposer|object|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» common_height|string(int64)|false|none|none|
|»»»»» byzantine_validators|[object]|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» signatures|[object]|false|none|none|
|»»»» block_id_flag|string|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetBlockByHeight

<a id="opIdGetBlockByHeight"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/blocks/{height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/blocks/{height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/blocks/{height}`

*GetBlockByHeight queries block for given height.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|height|path|string(int64)|true|none|

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» block|object|false|none|none|
|»» header|object|false|none|Header defines the structure of a block header.|
|»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»» block|string(uint64)|false|none|none|
|»»»» app|string(uint64)|false|none|none|
|»»» chain_id|string|false|none|none|
|»»» height|string(int64)|false|none|none|
|»»» time|string(date-time)|false|none|none|
|»»» last_block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» last_commit_hash|string(byte)|false|none|none|
|»»» data_hash|string(byte)|false|none|none|
|»»» validators_hash|string(byte)|false|none|none|
|»»» next_validators_hash|string(byte)|false|none|none|
|»»» consensus_hash|string(byte)|false|none|none|
|»»» app_hash|string(byte)|false|none|none|
|»»» last_results_hash|string(byte)|false|none|none|
|»»» evidence_hash|string(byte)|false|none|none|
|»»» proposer_address|string(byte)|false|none|none|
|»» data|object|false|none|none|
|»»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|»» evidence|object|false|none|none|
|»»» evidence|[object]|false|none|none|
|»»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» validator_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»»» conflicting_block|object|false|none|none|
|»»»»»» signed_header|object|false|none|none|
|»»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»»» chain_id|string|false|none|none|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»»» block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»»» signature|string(byte)|false|none|none|
|»»»»»» validator_set|object|false|none|none|
|»»»»»»» validators|[object]|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» proposer|object|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» common_height|string(int64)|false|none|none|
|»»»»» byzantine_validators|[object]|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» signatures|[object]|false|none|none|
|»»»» block_id_flag|string|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» signature|string(byte)|false|none|none|
|» sdk_block|object|false|none|Block is tendermint type Block, with the Header proposer address<br />field converted to bech32 string.|
|»» header|object|false|none|Header defines the structure of a Tendermint block header.|
|»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»» block|string(uint64)|false|none|none|
|»»»» app|string(uint64)|false|none|none|
|»»» chain_id|string|false|none|none|
|»»» height|string(int64)|false|none|none|
|»»» time|string(date-time)|false|none|none|
|»»» last_block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» last_commit_hash|string(byte)|false|none|none|
|»»» data_hash|string(byte)|false|none|none|
|»»» validators_hash|string(byte)|false|none|none|
|»»» next_validators_hash|string(byte)|false|none|none|
|»»» consensus_hash|string(byte)|false|none|none|
|»»» app_hash|string(byte)|false|none|none|
|»»» last_results_hash|string(byte)|false|none|none|
|»»» evidence_hash|string(byte)|false|none|none|
|»»» proposer_address|string|false|none|proposer_address is the original block proposer address, formatted as a Bech32 string.<br />In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string<br />for better UX.|
|»» data|object|false|none|none|
|»»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|»» evidence|object|false|none|none|
|»»» evidence|[object]|false|none|none|
|»»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» validator_index|integer(int32)|false|none|none|
|»»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» validator_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»»» conflicting_block|object|false|none|none|
|»»»»»» signed_header|object|false|none|none|
|»»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»»» chain_id|string|false|none|none|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»»» height|string(int64)|false|none|none|
|»»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»»» block_id|object|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»»» signature|string(byte)|false|none|none|
|»»»»»» validator_set|object|false|none|none|
|»»»»»»» validators|[object]|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» proposer|object|false|none|none|
|»»»»»»»» address|string(byte)|false|none|none|
|»»»»»»»» pub_key|object|false|none|none|
|»»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» common_height|string(int64)|false|none|none|
|»»»»» byzantine_validators|[object]|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» signatures|[object]|false|none|none|
|»»»» block_id_flag|string|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetNodeInfo

<a id="opIdGetNodeInfo"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/node_info', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/node_info',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/node_info`

*GetNodeInfo queries the current node info.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» default_node_info|object|false|none|none|
|»» protocol_version|object|false|none|none|
|»»» p2p|string(uint64)|false|none|none|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» default_node_id|string|false|none|none|
|»» listen_addr|string|false|none|none|
|»» network|string|false|none|none|
|»» version|string|false|none|none|
|»» channels|string(byte)|false|none|none|
|»» moniker|string|false|none|none|
|»» other|object|false|none|none|
|»»» tx_index|string|false|none|none|
|»»» rpc_address|string|false|none|none|
|» application_version|object|false|none|VersionInfo is the type for the GetNodeInfoResponse message.|
|»» name|string|false|none|none|
|»» app_name|string|false|none|none|
|»» version|string|false|none|none|
|»» git_commit|string|false|none|none|
|»» build_tags|string|false|none|none|
|»» go_version|string|false|none|none|
|»» build_deps|[object]|false|none|none|
|»»» Module is the type for VersionInfo|object|false|none|none|
|»»»» path|string|false|none|none|
|»»»» version|string|false|none|none|
|»»»» sum|string|false|none|none|
|»» cosmos_sdk_version|string|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetSyncing

<a id="opIdGetSyncing"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/syncing', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/syncing',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/syncing`

*GetSyncing queries node syncing.*

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*GetSyncingResponse is the response type for the Query/GetSyncing RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» syncing|boolean|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetLatestValidatorSet

<a id="opIdGetLatestValidatorSet"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/validatorsets/latest', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/validatorsets/latest',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/validatorsets/latest`

*GetLatestValidatorSet queries latest validator-set.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» block_height|string(int64)|false|none|none|
|» validators|[object]|false|none|none|
|»» address|string|false|none|none|
|»» pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» voting_power|string(int64)|false|none|none|
|»» proposer_priority|string(int64)|false|none|none|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

## GetValidatorSetByHeight

<a id="opIdGetValidatorSetByHeight"></a>

> Code samples

```python
import requests
headers = {
  'Accept': '*/*'
}

r = requests.get('/cosmos/base/tendermint/v1beta1/validatorsets/{height}', headers = headers)

print(r.json())

```

```javascript

const headers = {
  'Accept':'*/*'
};

fetch('/cosmos/base/tendermint/v1beta1/validatorsets/{height}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

`GET /cosmos/base/tendermint/v1beta1/validatorsets/{height}`

*GetValidatorSetByHeight queries validator-set at a given height.*

### Parameters

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|height|path|string(int64)|true|none|
|pagination.key|query|string(byte)|false|key is a value returned in PageResponse.next_key to begin|
|pagination.offset|query|string(uint64)|false|offset is a numeric offset that can be used when key is unavailable.|
|pagination.limit|query|string(uint64)|false|limit is the total number of results to be returned in the result page.|
|pagination.count_total|query|boolean|false|count_total is set to true  to indicate that the result set should include|
|pagination.reverse|query|boolean|false|reverse is set to true if results are to be returned in the descending order.|

#### Detailed descriptions

**pagination.key**: key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set.

**pagination.offset**: offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set.

**pagination.limit**: limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app.

**pagination.count_total**: count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set.

**pagination.reverse**: reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43

> Example responses

> 200 Response

### Responses

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|A successful response.|Inline|
|default|Default|An unexpected error response.|Inline|

### Response Schema

Status Code **200**

*GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.*

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» block_height|string(int64)|false|none|none|
|» validators|[object]|false|none|none|
|»» address|string|false|none|none|
|»» pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» voting_power|string(int64)|false|none|none|
|»» proposer_priority|string(int64)|false|none|none|
|» pagination|object|false|none|pagination defines an pagination for the response.|
|»» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|»» total|string(uint64)|false|none|none|

Status Code **default**

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|» error|string|false|none|none|
|» code|integer(int32)|false|none|none|
|» message|string|false|none|none|
|» details|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

<aside class="success">
This operation does not require authentication
</aside>

# Schemas

## cosmos.base.query.v1beta1.PageRequest

<a id="schemacosmos.base.query.v1beta1.pagerequest"></a>
<a id="schema_cosmos.base.query.v1beta1.PageRequest"></a>
<a id="tocScosmos.base.query.v1beta1.pagerequest"></a>
<a id="tocscosmos.base.query.v1beta1.pagerequest"></a>

```json
{
  "key": "string",
  "offset": "string",
  "limit": "string",
  "count_total": true,
  "reverse": true
}

```

PageRequest is to be embedded in gRPC request messages for efficient
pagination. Ex:

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|key|string(byte)|false|none|key is a value returned in PageResponse.next_key to begin<br />querying the next page most efficiently. Only one of offset or key<br />should be set.|
|offset|string(uint64)|false|none|offset is a numeric offset that can be used when key is unavailable.<br />It is less efficient than using key. Only one of offset or key should<br />be set.|
|limit|string(uint64)|false|none|limit is the total number of results to be returned in the result page.<br />If left empty it will default to a value to be set by each app.|
|count_total|boolean|false|none|count_total is set to true  to indicate that the result set should include<br />a count of the total number of items available for pagination in UIs.<br />count_total is only respected when offset is used. It is ignored when key<br />is set.|
|reverse|boolean|false|none|reverse is set to true if results are to be returned in the descending order.<br /><br />Since: cosmos-sdk 0.43|

## cosmos.base.query.v1beta1.PageResponse

<a id="schemacosmos.base.query.v1beta1.pageresponse"></a>
<a id="schema_cosmos.base.query.v1beta1.PageResponse"></a>
<a id="tocScosmos.base.query.v1beta1.pageresponse"></a>
<a id="tocscosmos.base.query.v1beta1.pageresponse"></a>

```json
{
  "next_key": "string",
  "total": "string"
}

```

PageResponse is to be embedded in gRPC response messages where the
corresponding request message has used PageRequest.

 message SomeResponse {
         repeated Bar results = 1;
         PageResponse page = 2;
 }

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|total|string(uint64)|false|none|none|

## dydxprotocol.assets.Asset

<a id="schemadydxprotocol.assets.asset"></a>
<a id="schema_dydxprotocol.assets.Asset"></a>
<a id="tocSdydxprotocol.assets.asset"></a>
<a id="tocsdydxprotocol.assets.asset"></a>

```json
{
  "id": 0,
  "symbol": "string",
  "denom": "string",
  "denom_exponent": 0,
  "has_market": true,
  "market_id": 0,
  "atomic_resolution": 0
}

```

Asset defines a single exchangable asset.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|Unique, sequentially-generated.|
|symbol|string|false|none|The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).<br />Must be uppercase, unique and correspond to the canonical symbol of the<br />full coin.|
|denom|string|false|none|The name of base denomination unit of the `Asset` (e.g. `uatom`,<br />'ibc/xxxxx'). Must be unique and match the `denom` used in the `sdk.Coin`<br />type in the `x/bank` module.|
|denom_exponent|integer(int32)|false|none|none|
|has_market|boolean|false|none|`true` if this `Asset` has a valid `MarketId` value.|
|market_id|integer(int64)|false|none|The `Id` of the `Market` associated with this `Asset`. It acts as the<br />oracle price for the purposes of calculating collateral<br />and margin requirements.|
|atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (1 'quantum')<br />to a full coin. For example, if `atomic_resolution = -8`<br />then an `asset_position` with `base_quantums = 1e8` is equivalent to<br />a position size of one full coin.|

## dydxprotocol.assets.QueryAllAssetsResponse

<a id="schemadydxprotocol.assets.queryallassetsresponse"></a>
<a id="schema_dydxprotocol.assets.QueryAllAssetsResponse"></a>
<a id="tocSdydxprotocol.assets.queryallassetsresponse"></a>
<a id="tocsdydxprotocol.assets.queryallassetsresponse"></a>

```json
{
  "asset": [
    {
      "id": 0,
      "symbol": "string",
      "denom": "string",
      "denom_exponent": 0,
      "has_market": true,
      "market_id": 0,
      "atomic_resolution": 0
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllAssetsResponse is response type for the AllAssets RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|asset|[object]|false|none|none|
|» id|integer(int64)|false|none|Unique, sequentially-generated.|
|» symbol|string|false|none|The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).<br />Must be uppercase, unique and correspond to the canonical symbol of the<br />full coin.|
|» denom|string|false|none|The name of base denomination unit of the `Asset` (e.g. `uatom`,<br />'ibc/xxxxx'). Must be unique and match the `denom` used in the `sdk.Coin`<br />type in the `x/bank` module.|
|» denom_exponent|integer(int32)|false|none|none|
|» has_market|boolean|false|none|`true` if this `Asset` has a valid `MarketId` value.|
|» market_id|integer(int64)|false|none|The `Id` of the `Market` associated with this `Asset`. It acts as the<br />oracle price for the purposes of calculating collateral<br />and margin requirements.|
|» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (1 'quantum')<br />to a full coin. For example, if `atomic_resolution = -8`<br />then an `asset_position` with `base_quantums = 1e8` is equivalent to<br />a position size of one full coin.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## dydxprotocol.assets.QueryAssetResponse

<a id="schemadydxprotocol.assets.queryassetresponse"></a>
<a id="schema_dydxprotocol.assets.QueryAssetResponse"></a>
<a id="tocSdydxprotocol.assets.queryassetresponse"></a>
<a id="tocsdydxprotocol.assets.queryassetresponse"></a>

```json
{
  "asset": {
    "id": 0,
    "symbol": "string",
    "denom": "string",
    "denom_exponent": 0,
    "has_market": true,
    "market_id": 0,
    "atomic_resolution": 0
  }
}

```

QueryAssetResponse is response type for the Asset RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|asset|object|false|none|Asset defines a single exchangable asset.|
|» id|integer(int64)|false|none|Unique, sequentially-generated.|
|» symbol|string|false|none|The human readable symbol of the `Asset` (e.g. `USDC`, `ATOM`).<br />Must be uppercase, unique and correspond to the canonical symbol of the<br />full coin.|
|» denom|string|false|none|The name of base denomination unit of the `Asset` (e.g. `uatom`,<br />'ibc/xxxxx'). Must be unique and match the `denom` used in the `sdk.Coin`<br />type in the `x/bank` module.|
|» denom_exponent|integer(int32)|false|none|none|
|» has_market|boolean|false|none|`true` if this `Asset` has a valid `MarketId` value.|
|» market_id|integer(int64)|false|none|The `Id` of the `Market` associated with this `Asset`. It acts as the<br />oracle price for the purposes of calculating collateral<br />and margin requirements.|
|» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (1 'quantum')<br />to a full coin. For example, if `atomic_resolution = -8`<br />then an `asset_position` with `base_quantums = 1e8` is equivalent to<br />a position size of one full coin.|

## google.protobuf.Any

<a id="schemagoogle.protobuf.any"></a>
<a id="schema_google.protobuf.Any"></a>
<a id="tocSgoogle.protobuf.any"></a>
<a id="tocsgoogle.protobuf.any"></a>

```json
{
  "type_url": "string",
  "value": "string"
}

```

`Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".

JSON

The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    }

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## grpc.gateway.runtime.Error

<a id="schemagrpc.gateway.runtime.error"></a>
<a id="schema_grpc.gateway.runtime.Error"></a>
<a id="tocSgrpc.gateway.runtime.error"></a>
<a id="tocsgrpc.gateway.runtime.error"></a>

```json
{
  "error": "string",
  "code": 0,
  "message": "string",
  "details": [
    {
      "type_url": "string",
      "value": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error|string|false|none|none|
|code|integer(int32)|false|none|none|
|message|string|false|none|none|
|details|[object]|false|none|none|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## dydxprotocol.blocktime.AllDowntimeInfo

<a id="schemadydxprotocol.blocktime.alldowntimeinfo"></a>
<a id="schema_dydxprotocol.blocktime.AllDowntimeInfo"></a>
<a id="tocSdydxprotocol.blocktime.alldowntimeinfo"></a>
<a id="tocsdydxprotocol.blocktime.alldowntimeinfo"></a>

```json
{
  "infos": [
    {
      "duration": "string",
      "block_info": {
        "height": 0,
        "timestamp": "2019-08-24T14:15:22Z"
      }
    }
  ]
}

```

AllDowntimeInfo stores information for all downtime durations.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|infos|[object]|false|none|The downtime information for each tracked duration. Sorted by duration,<br />ascending. (i.e. the same order as they appear in DowntimeParams).|
|» duration|string|false|none|none|
|» block_info|object|false|none|none|
|»» height|integer(int64)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|

## dydxprotocol.blocktime.AllDowntimeInfo.DowntimeInfo

<a id="schemadydxprotocol.blocktime.alldowntimeinfo.downtimeinfo"></a>
<a id="schema_dydxprotocol.blocktime.AllDowntimeInfo.DowntimeInfo"></a>
<a id="tocSdydxprotocol.blocktime.alldowntimeinfo.downtimeinfo"></a>
<a id="tocsdydxprotocol.blocktime.alldowntimeinfo.downtimeinfo"></a>

```json
{
  "duration": "string",
  "block_info": {
    "height": 0,
    "timestamp": "2019-08-24T14:15:22Z"
  }
}

```

Stores information about downtime. block_info corresponds to the most
recent block at which a downtime occurred.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|duration|string|false|none|none|
|block_info|object|false|none|none|
|» height|integer(int64)|false|none|none|
|» timestamp|string(date-time)|false|none|none|

## dydxprotocol.blocktime.BlockInfo

<a id="schemadydxprotocol.blocktime.blockinfo"></a>
<a id="schema_dydxprotocol.blocktime.BlockInfo"></a>
<a id="tocSdydxprotocol.blocktime.blockinfo"></a>
<a id="tocsdydxprotocol.blocktime.blockinfo"></a>

```json
{
  "height": 0,
  "timestamp": "2019-08-24T14:15:22Z"
}

```

BlockInfo stores information about a block

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|height|integer(int64)|false|none|none|
|timestamp|string(date-time)|false|none|none|

## dydxprotocol.blocktime.DowntimeParams

<a id="schemadydxprotocol.blocktime.downtimeparams"></a>
<a id="schema_dydxprotocol.blocktime.DowntimeParams"></a>
<a id="tocSdydxprotocol.blocktime.downtimeparams"></a>
<a id="tocsdydxprotocol.blocktime.downtimeparams"></a>

```json
{
  "durations": [
    "string"
  ]
}

```

DowntimeParams defines the parameters for downtime.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|durations|[string]|false|none|Durations tracked for downtime. The durations must be sorted from<br />shortest to longest and must all be positive.|

## dydxprotocol.blocktime.QueryAllDowntimeInfoResponse

<a id="schemadydxprotocol.blocktime.queryalldowntimeinforesponse"></a>
<a id="schema_dydxprotocol.blocktime.QueryAllDowntimeInfoResponse"></a>
<a id="tocSdydxprotocol.blocktime.queryalldowntimeinforesponse"></a>
<a id="tocsdydxprotocol.blocktime.queryalldowntimeinforesponse"></a>

```json
{
  "info": {
    "infos": [
      {
        "duration": "string",
        "block_info": {
          "height": 0,
          "timestamp": "2019-08-24T14:15:22Z"
        }
      }
    ]
  }
}

```

QueryAllDowntimeInfoResponse is a request type for the AllDowntimeInfo
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|object|false|none|AllDowntimeInfo stores information for all downtime durations.|
|» infos|[object]|false|none|The downtime information for each tracked duration. Sorted by duration,<br />ascending. (i.e. the same order as they appear in DowntimeParams).|
|»» duration|string|false|none|none|
|»» block_info|object|false|none|none|
|»»» height|integer(int64)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|

## dydxprotocol.blocktime.QueryDowntimeParamsResponse

<a id="schemadydxprotocol.blocktime.querydowntimeparamsresponse"></a>
<a id="schema_dydxprotocol.blocktime.QueryDowntimeParamsResponse"></a>
<a id="tocSdydxprotocol.blocktime.querydowntimeparamsresponse"></a>
<a id="tocsdydxprotocol.blocktime.querydowntimeparamsresponse"></a>

```json
{
  "params": {
    "durations": [
      "string"
    ]
  }
}

```

QueryDowntimeParamsResponse is a response type for the DowntimeParams
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|DowntimeParams defines the parameters for downtime.|
|» durations|[string]|false|none|Durations tracked for downtime. The durations must be sorted from<br />shortest to longest and must all be positive.|

## dydxprotocol.blocktime.QueryPreviousBlockInfoResponse

<a id="schemadydxprotocol.blocktime.querypreviousblockinforesponse"></a>
<a id="schema_dydxprotocol.blocktime.QueryPreviousBlockInfoResponse"></a>
<a id="tocSdydxprotocol.blocktime.querypreviousblockinforesponse"></a>
<a id="tocsdydxprotocol.blocktime.querypreviousblockinforesponse"></a>

```json
{
  "info": {
    "height": 0,
    "timestamp": "2019-08-24T14:15:22Z"
  }
}

```

QueryPreviousBlockInfoResponse is a request type for the PreviousBlockInfo
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|object|false|none|none|
|» height|integer(int64)|false|none|none|
|» timestamp|string(date-time)|false|none|none|

## cosmos.base.v1beta1.Coin

<a id="schemacosmos.base.v1beta1.coin"></a>
<a id="schema_cosmos.base.v1beta1.Coin"></a>
<a id="tocScosmos.base.v1beta1.coin"></a>
<a id="tocscosmos.base.v1beta1.coin"></a>

```json
{
  "denom": "string",
  "amount": "string"
}

```

Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom|string|false|none|none|
|amount|string|false|none|none|

## dydxprotocol.bridge.BridgeEvent

<a id="schemadydxprotocol.bridge.bridgeevent"></a>
<a id="schema_dydxprotocol.bridge.BridgeEvent"></a>
<a id="tocSdydxprotocol.bridge.bridgeevent"></a>
<a id="tocsdydxprotocol.bridge.bridgeevent"></a>

```json
{
  "id": 0,
  "coin": {
    "denom": "string",
    "amount": "string"
  },
  "address": "string",
  "eth_block_height": "string"
}

```

BridgeEvent is a recognized event from the Ethereum blockchain.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|The unique id of the Ethereum event log.|
|coin|object|false|none|The tokens bridged.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|address|string|false|none|The account address or module address to bridge to.|
|eth_block_height|string(uint64)|false|none|The Ethereum block height of the event.|

## dydxprotocol.bridge.BridgeEventInfo

<a id="schemadydxprotocol.bridge.bridgeeventinfo"></a>
<a id="schema_dydxprotocol.bridge.BridgeEventInfo"></a>
<a id="tocSdydxprotocol.bridge.bridgeeventinfo"></a>
<a id="tocsdydxprotocol.bridge.bridgeeventinfo"></a>

```json
{
  "next_id": 0,
  "eth_block_height": "string"
}

```

BridgeEventInfo stores information about the most recently processed bridge
event.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|next_id|integer(int64)|false|none|The next event id (the last processed id plus one) of the logs from the<br />Ethereum contract.|
|eth_block_height|string(uint64)|false|none|The Ethereum block height of the most recently processed bridge event.|

## dydxprotocol.bridge.DelayedCompleteBridgeMessage

<a id="schemadydxprotocol.bridge.delayedcompletebridgemessage"></a>
<a id="schema_dydxprotocol.bridge.DelayedCompleteBridgeMessage"></a>
<a id="tocSdydxprotocol.bridge.delayedcompletebridgemessage"></a>
<a id="tocsdydxprotocol.bridge.delayedcompletebridgemessage"></a>

```json
{
  "message": {
    "authority": "string",
    "event": {
      "id": 0,
      "coin": {
        "denom": "string",
        "amount": "string"
      },
      "address": "string",
      "eth_block_height": "string"
    }
  },
  "block_height": 0
}

```

DelayedCompleteBridgeMessage is a message type for the response of
DelayedCompleteBridgeMessages RPC method. It contains the message
and the block height at which it will execute.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|message|object|false|none|MsgCompleteBridge is the Msg/CompleteBridgeResponse request type.|
|» authority|string|false|none|none|
|» event|object|false|none|The event to complete.|
|»» id|integer(int64)|false|none|The unique id of the Ethereum event log.|
|»» coin|object|false|none|The tokens bridged.|
|»»» denom|string|false|none|none|
|»»» amount|string|false|none|none|
|»» address|string|false|none|The account address or module address to bridge to.|
|»» eth_block_height|string(uint64)|false|none|The Ethereum block height of the event.|
|block_height|integer(int64)|false|none|none|

## dydxprotocol.bridge.EventParams

<a id="schemadydxprotocol.bridge.eventparams"></a>
<a id="schema_dydxprotocol.bridge.EventParams"></a>
<a id="tocSdydxprotocol.bridge.eventparams"></a>
<a id="tocsdydxprotocol.bridge.eventparams"></a>

```json
{
  "denom": "string",
  "eth_chain_id": "string",
  "eth_address": "string"
}

```

EventParams stores parameters about which events to recognize and which
tokens to mint.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom|string|false|none|The denom of the token to mint.|
|eth_chain_id|string(uint64)|false|none|The numerical chain ID of the Ethereum chain to query.|
|eth_address|string|false|none|The address of the Ethereum contract to monitor for logs.|

## dydxprotocol.bridge.MsgCompleteBridge

<a id="schemadydxprotocol.bridge.msgcompletebridge"></a>
<a id="schema_dydxprotocol.bridge.MsgCompleteBridge"></a>
<a id="tocSdydxprotocol.bridge.msgcompletebridge"></a>
<a id="tocsdydxprotocol.bridge.msgcompletebridge"></a>

```json
{
  "authority": "string",
  "event": {
    "id": 0,
    "coin": {
      "denom": "string",
      "amount": "string"
    },
    "address": "string",
    "eth_block_height": "string"
  }
}

```

MsgCompleteBridge is the Msg/CompleteBridgeResponse request type.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|authority|string|false|none|none|
|event|object|false|none|The event to complete.|
|» id|integer(int64)|false|none|The unique id of the Ethereum event log.|
|» coin|object|false|none|The tokens bridged.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» address|string|false|none|The account address or module address to bridge to.|
|» eth_block_height|string(uint64)|false|none|The Ethereum block height of the event.|

## dydxprotocol.bridge.ProposeParams

<a id="schemadydxprotocol.bridge.proposeparams"></a>
<a id="schema_dydxprotocol.bridge.ProposeParams"></a>
<a id="tocSdydxprotocol.bridge.proposeparams"></a>
<a id="tocsdydxprotocol.bridge.proposeparams"></a>

```json
{
  "max_bridges_per_block": 0,
  "propose_delay_duration": "string",
  "skip_rate_ppm": 0,
  "skip_if_block_delayed_by_duration": "string"
}

```

ProposeParams stores parameters for proposing to the module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|max_bridges_per_block|integer(int64)|false|none|The maximum number of bridge events to propose per block.<br />Limits the number of events to propose in a single block<br />in-order to smooth out the flow of events.|
|propose_delay_duration|string|false|none|The minimum duration to wait between a finalized bridge and<br />proposing it. This allows other validators to have enough time to<br />also recognize its occurence. Therefore the bridge daemon should<br />pool for new finalized events at least as often as this parameter.|
|skip_rate_ppm|integer(int64)|false|none|Do not propose any events if a [0, 1_000_000) random number generator<br />generates a number smaller than this number.<br />Setting this parameter to 1_000_000 means always skipping proposing events.|
|skip_if_block_delayed_by_duration|string|false|none|Do not propose any events if the timestamp of the proposal block is<br />behind the proposers' wall-clock by at least this duration.|

## dydxprotocol.bridge.QueryAcknowledgedEventInfoResponse

<a id="schemadydxprotocol.bridge.queryacknowledgedeventinforesponse"></a>
<a id="schema_dydxprotocol.bridge.QueryAcknowledgedEventInfoResponse"></a>
<a id="tocSdydxprotocol.bridge.queryacknowledgedeventinforesponse"></a>
<a id="tocsdydxprotocol.bridge.queryacknowledgedeventinforesponse"></a>

```json
{
  "info": {
    "next_id": 0,
    "eth_block_height": "string"
  }
}

```

QueryAcknowledgedEventInfoResponse is a response type for the
AcknowledgedEventInfo RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|object|false|none|BridgeEventInfo stores information about the most recently processed bridge<br />event.|
|» next_id|integer(int64)|false|none|The next event id (the last processed id plus one) of the logs from the<br />Ethereum contract.|
|» eth_block_height|string(uint64)|false|none|The Ethereum block height of the most recently processed bridge event.|

## dydxprotocol.bridge.QueryDelayedCompleteBridgeMessagesResponse

<a id="schemadydxprotocol.bridge.querydelayedcompletebridgemessagesresponse"></a>
<a id="schema_dydxprotocol.bridge.QueryDelayedCompleteBridgeMessagesResponse"></a>
<a id="tocSdydxprotocol.bridge.querydelayedcompletebridgemessagesresponse"></a>
<a id="tocsdydxprotocol.bridge.querydelayedcompletebridgemessagesresponse"></a>

```json
{
  "messages": [
    {
      "message": {
        "authority": "string",
        "event": {
          "id": 0,
          "coin": {},
          "address": "string",
          "eth_block_height": "string"
        }
      },
      "block_height": 0
    }
  ]
}

```

QueryDelayedCompleteBridgeMessagesResponse is a response type for the
DelayedCompleteBridgeMessages RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|messages|[object]|false|none|none|
|» message|object|false|none|MsgCompleteBridge is the Msg/CompleteBridgeResponse request type.|
|»» authority|string|false|none|none|
|»» event|object|false|none|The event to complete.|
|»»» id|integer(int64)|false|none|The unique id of the Ethereum event log.|
|»»» coin|object|false|none|The tokens bridged.|
|»»»» denom|string|false|none|none|
|»»»» amount|string|false|none|none|
|»»» address|string|false|none|The account address or module address to bridge to.|
|»»» eth_block_height|string(uint64)|false|none|The Ethereum block height of the event.|
|» block_height|integer(int64)|false|none|none|

## dydxprotocol.bridge.QueryEventParamsResponse

<a id="schemadydxprotocol.bridge.queryeventparamsresponse"></a>
<a id="schema_dydxprotocol.bridge.QueryEventParamsResponse"></a>
<a id="tocSdydxprotocol.bridge.queryeventparamsresponse"></a>
<a id="tocsdydxprotocol.bridge.queryeventparamsresponse"></a>

```json
{
  "params": {
    "denom": "string",
    "eth_chain_id": "string",
    "eth_address": "string"
  }
}

```

QueryEventParamsResponse is a response type for the EventParams RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|EventParams stores parameters about which events to recognize and which<br />tokens to mint.|
|» denom|string|false|none|The denom of the token to mint.|
|» eth_chain_id|string(uint64)|false|none|The numerical chain ID of the Ethereum chain to query.|
|» eth_address|string|false|none|The address of the Ethereum contract to monitor for logs.|

## dydxprotocol.bridge.QueryProposeParamsResponse

<a id="schemadydxprotocol.bridge.queryproposeparamsresponse"></a>
<a id="schema_dydxprotocol.bridge.QueryProposeParamsResponse"></a>
<a id="tocSdydxprotocol.bridge.queryproposeparamsresponse"></a>
<a id="tocsdydxprotocol.bridge.queryproposeparamsresponse"></a>

```json
{
  "params": {
    "max_bridges_per_block": 0,
    "propose_delay_duration": "string",
    "skip_rate_ppm": 0,
    "skip_if_block_delayed_by_duration": "string"
  }
}

```

QueryProposeParamsResponse is a response type for the ProposeParams RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|ProposeParams stores parameters for proposing to the module.|
|» max_bridges_per_block|integer(int64)|false|none|The maximum number of bridge events to propose per block.<br />Limits the number of events to propose in a single block<br />in-order to smooth out the flow of events.|
|» propose_delay_duration|string|false|none|The minimum duration to wait between a finalized bridge and<br />proposing it. This allows other validators to have enough time to<br />also recognize its occurence. Therefore the bridge daemon should<br />pool for new finalized events at least as often as this parameter.|
|» skip_rate_ppm|integer(int64)|false|none|Do not propose any events if a [0, 1_000_000) random number generator<br />generates a number smaller than this number.<br />Setting this parameter to 1_000_000 means always skipping proposing events.|
|» skip_if_block_delayed_by_duration|string|false|none|Do not propose any events if the timestamp of the proposal block is<br />behind the proposers' wall-clock by at least this duration.|

## dydxprotocol.bridge.QueryRecognizedEventInfoResponse

<a id="schemadydxprotocol.bridge.queryrecognizedeventinforesponse"></a>
<a id="schema_dydxprotocol.bridge.QueryRecognizedEventInfoResponse"></a>
<a id="tocSdydxprotocol.bridge.queryrecognizedeventinforesponse"></a>
<a id="tocsdydxprotocol.bridge.queryrecognizedeventinforesponse"></a>

```json
{
  "info": {
    "next_id": 0,
    "eth_block_height": "string"
  }
}

```

QueryRecognizedEventInfoResponse is a response type for the
RecognizedEventInfo RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|object|false|none|BridgeEventInfo stores information about the most recently processed bridge<br />event.|
|» next_id|integer(int64)|false|none|The next event id (the last processed id plus one) of the logs from the<br />Ethereum contract.|
|» eth_block_height|string(uint64)|false|none|The Ethereum block height of the most recently processed bridge event.|

## dydxprotocol.bridge.QuerySafetyParamsResponse

<a id="schemadydxprotocol.bridge.querysafetyparamsresponse"></a>
<a id="schema_dydxprotocol.bridge.QuerySafetyParamsResponse"></a>
<a id="tocSdydxprotocol.bridge.querysafetyparamsresponse"></a>
<a id="tocsdydxprotocol.bridge.querysafetyparamsresponse"></a>

```json
{
  "params": {
    "is_disabled": true,
    "delay_blocks": 0
  }
}

```

QuerySafetyParamsResponse is a response type for the SafetyParams RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|SafetyParams stores safety parameters for the module.|
|» is_disabled|boolean|false|none|True if bridging is disabled.|
|» delay_blocks|integer(int64)|false|none|The number of blocks that bridges accepted in-consensus will be pending<br />until the minted tokens are granted.|

## dydxprotocol.bridge.SafetyParams

<a id="schemadydxprotocol.bridge.safetyparams"></a>
<a id="schema_dydxprotocol.bridge.SafetyParams"></a>
<a id="tocSdydxprotocol.bridge.safetyparams"></a>
<a id="tocsdydxprotocol.bridge.safetyparams"></a>

```json
{
  "is_disabled": true,
  "delay_blocks": 0
}

```

SafetyParams stores safety parameters for the module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|is_disabled|boolean|false|none|True if bridging is disabled.|
|delay_blocks|integer(int64)|false|none|The number of blocks that bridges accepted in-consensus will be pending<br />until the minted tokens are granted.|

## dydxprotocol.clob.BlockRateLimitConfiguration

<a id="schemadydxprotocol.clob.blockratelimitconfiguration"></a>
<a id="schema_dydxprotocol.clob.BlockRateLimitConfiguration"></a>
<a id="tocSdydxprotocol.clob.blockratelimitconfiguration"></a>
<a id="tocsdydxprotocol.clob.blockratelimitconfiguration"></a>

```json
{
  "max_short_term_orders_per_n_blocks": [
    {
      "num_blocks": 0,
      "limit": 0
    }
  ],
  "max_stateful_orders_per_n_blocks": [
    {
      "num_blocks": 0,
      "limit": 0
    }
  ],
  "max_short_term_order_cancellations_per_n_blocks": [
    {
      "num_blocks": 0,
      "limit": 0
    }
  ],
  "max_short_term_orders_and_cancels_per_n_blocks": [
    {
      "num_blocks": 0,
      "limit": 0
    }
  ]
}

```

Defines the block rate limits for CLOB specific operations.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|max_short_term_orders_per_n_blocks|[object]|false|none|How many short term order attempts (successful and failed) are allowed for<br />an account per N blocks. Note that the rate limits are applied<br />in an AND fashion such that an order placement must pass all rate limit<br />configurations.<br /><br />Specifying 0 values disables this rate limit.<br />Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`<br />for v5.x onwards.|
|» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|max_stateful_orders_per_n_blocks|[object]|false|none|How many stateful order attempts (successful and failed) are allowed for<br />an account per N blocks. Note that the rate limits are applied<br />in an AND fashion such that an order placement must pass all rate limit<br />configurations.<br /><br />Specifying 0 values disables this rate limit.|
|» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|max_short_term_order_cancellations_per_n_blocks|[object]|false|none|How many short term order cancellation attempts (successful and failed) are<br />allowed for an account per N blocks. Note that the rate limits are<br />applied in an AND fashion such that an order cancellation must pass all<br />rate limit configurations.<br /><br />Specifying 0 values disables this rate limit.<br />Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`<br />for v5.x onwards.|
|» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|max_short_term_orders_and_cancels_per_n_blocks|[object]|false|none|How many short term order place and cancel attempts (successful and failed)<br />are allowed for an account per N blocks. Note that the rate limits are<br />applied in an AND fashion such that an order placement must pass all rate<br />limit configurations.<br /><br />Specifying 0 values disables this rate limit.|
|» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|

## dydxprotocol.clob.ClobMidPrice

<a id="schemadydxprotocol.clob.clobmidprice"></a>
<a id="schema_dydxprotocol.clob.ClobMidPrice"></a>
<a id="tocSdydxprotocol.clob.clobmidprice"></a>
<a id="tocsdydxprotocol.clob.clobmidprice"></a>

```json
{
  "clob_pair": {
    "id": 0,
    "perpetual_clob_metadata": {
      "perpetual_id": 0
    },
    "spot_clob_metadata": {
      "base_asset_id": 0,
      "quote_asset_id": 0
    },
    "step_base_quantums": "string",
    "subticks_per_tick": 0,
    "quantum_conversion_exponent": 0,
    "status": "STATUS_UNSPECIFIED"
  },
  "subticks": "string"
}

```

ClobMidPrice contains the mid price of a CLOB pair, represented by it's ID.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|clob_pair|object|false|none|ClobPair represents a single CLOB pair for a given product<br />in state.|
|» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|
|subticks|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.ClobPair

<a id="schemadydxprotocol.clob.clobpair"></a>
<a id="schema_dydxprotocol.clob.ClobPair"></a>
<a id="tocSdydxprotocol.clob.clobpair"></a>
<a id="tocsdydxprotocol.clob.clobpair"></a>

```json
{
  "id": 0,
  "perpetual_clob_metadata": {
    "perpetual_id": 0
  },
  "spot_clob_metadata": {
    "base_asset_id": 0,
    "quote_asset_id": 0
  },
  "step_base_quantums": "string",
  "subticks_per_tick": 0,
  "quantum_conversion_exponent": 0,
  "status": "STATUS_UNSPECIFIED"
}

```

ClobPair represents a single CLOB pair for a given product
in state.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.ClobPair.Status

<a id="schemadydxprotocol.clob.clobpair.status"></a>
<a id="schema_dydxprotocol.clob.ClobPair.Status"></a>
<a id="tocSdydxprotocol.clob.clobpair.status"></a>
<a id="tocsdydxprotocol.clob.clobpair.status"></a>

```json
"STATUS_UNSPECIFIED"

```

Status of the CLOB.

 - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.
 - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.
 - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.
TODO(DEC-600): update this documentation.
 - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.
TODO(DEC-600): update this documentation.
 - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.
TODO(DEC-600): update this documentation.
 - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.
Clob pairs in this state only accept orders which are
both short-term and post-only.
 - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated
and trading has ceased. All open positions will be closed by the
protocol. Open stateful orders will be cancelled. Open short-term
orders will be left to expire.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|STATUS_UNSPECIFIED|
|*anonymous*|STATUS_ACTIVE|
|*anonymous*|STATUS_PAUSED|
|*anonymous*|STATUS_CANCEL_ONLY|
|*anonymous*|STATUS_POST_ONLY|
|*anonymous*|STATUS_INITIALIZING|
|*anonymous*|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.EquityTierLimit

<a id="schemadydxprotocol.clob.equitytierlimit"></a>
<a id="schema_dydxprotocol.clob.EquityTierLimit"></a>
<a id="tocSdydxprotocol.clob.equitytierlimit"></a>
<a id="tocsdydxprotocol.clob.equitytierlimit"></a>

```json
{
  "usd_tnc_required": "string",
  "limit": 0
}

```

Defines an equity tier limit.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|

## dydxprotocol.clob.EquityTierLimitConfiguration

<a id="schemadydxprotocol.clob.equitytierlimitconfiguration"></a>
<a id="schema_dydxprotocol.clob.EquityTierLimitConfiguration"></a>
<a id="tocSdydxprotocol.clob.equitytierlimitconfiguration"></a>
<a id="tocsdydxprotocol.clob.equitytierlimitconfiguration"></a>

```json
{
  "short_term_order_equity_tiers": [
    {
      "usd_tnc_required": "string",
      "limit": 0
    }
  ],
  "stateful_order_equity_tiers": [
    {
      "usd_tnc_required": "string",
      "limit": 0
    }
  ]
}

```

Defines the set of equity tiers to limit how many open orders
a subaccount is allowed to have.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|short_term_order_equity_tiers|[object]|false|none|How many short term stateful orders are allowed per equity tier.<br />Specifying 0 values disables this limit.|
|» usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|» limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|
|stateful_order_equity_tiers|[object]|false|none|How many open stateful orders are allowed per equity tier.<br />Specifying 0 values disables this limit.|
|» usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|» limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|

## dydxprotocol.clob.FillablePriceConfig

<a id="schemadydxprotocol.clob.fillablepriceconfig"></a>
<a id="schema_dydxprotocol.clob.FillablePriceConfig"></a>
<a id="tocSdydxprotocol.clob.fillablepriceconfig"></a>
<a id="tocsdydxprotocol.clob.fillablepriceconfig"></a>

```json
{
  "bankruptcy_adjustment_ppm": 0,
  "spread_to_maintenance_margin_ratio_ppm": 0
}

```

FillablePriceConfig stores all configurable fields related to calculating
the fillable price for liquidating a position.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bankruptcy_adjustment_ppm|integer(int64)|false|none|The rate at which the Adjusted Bankruptcy Rating increases.|
|spread_to_maintenance_margin_ratio_ppm|integer(int64)|false|none|The maximum value that the liquidation spread can take, as<br />a ratio against the position's maintenance margin.|

## dydxprotocol.clob.LiquidationsConfig

<a id="schemadydxprotocol.clob.liquidationsconfig"></a>
<a id="schema_dydxprotocol.clob.LiquidationsConfig"></a>
<a id="tocSdydxprotocol.clob.liquidationsconfig"></a>
<a id="tocsdydxprotocol.clob.liquidationsconfig"></a>

```json
{
  "max_liquidation_fee_ppm": 0,
  "position_block_limits": {
    "min_position_notional_liquidated": "string",
    "max_position_portion_liquidated_ppm": 0
  },
  "subaccount_block_limits": {
    "max_notional_liquidated": "string",
    "max_quantums_insurance_lost": "string"
  },
  "fillable_price_config": {
    "bankruptcy_adjustment_ppm": 0,
    "spread_to_maintenance_margin_ratio_ppm": 0
  }
}

```

LiquidationsConfig stores all configurable fields related to liquidations.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|max_liquidation_fee_ppm|integer(int64)|false|none|The maximum liquidation fee (in parts-per-million). This fee goes<br />100% to the insurance fund.|
|position_block_limits|object|false|none|Limits around how much of a single position can be liquidated<br />within a single block.|
|» min_position_notional_liquidated|string(uint64)|false|none|The minimum amount of quantums to liquidate for each message (in<br />quote quantums).<br />Overridden by the maximum size of the position.|
|» max_position_portion_liquidated_ppm|integer(int64)|false|none|The maximum portion of the position liquidated (in parts-per-<br />million). Overridden by min_position_notional_liquidated.|
|subaccount_block_limits|object|false|none|Limits around how many quote quantums from a single subaccount can<br />be liquidated within a single block.|
|» max_notional_liquidated|string(uint64)|false|none|The maximum notional amount that a single subaccount can have<br />liquidated (in quote quantums) per block.|
|» max_quantums_insurance_lost|string(uint64)|false|none|The maximum insurance-fund payout amount for a given subaccount<br />per block. I.e. how much it can cover for that subaccount.|
|fillable_price_config|object|false|none|Config about how the fillable-price spread from the oracle price<br />increases based on the adjusted bankruptcy rating of the subaccount.|
|» bankruptcy_adjustment_ppm|integer(int64)|false|none|The rate at which the Adjusted Bankruptcy Rating increases.|
|» spread_to_maintenance_margin_ratio_ppm|integer(int64)|false|none|The maximum value that the liquidation spread can take, as<br />a ratio against the position's maintenance margin.|

## dydxprotocol.clob.MEVLiquidationMatch

<a id="schemadydxprotocol.clob.mevliquidationmatch"></a>
<a id="schema_dydxprotocol.clob.MEVLiquidationMatch"></a>
<a id="tocSdydxprotocol.clob.mevliquidationmatch"></a>
<a id="tocsdydxprotocol.clob.mevliquidationmatch"></a>

```json
{
  "liquidated_subaccount_id": {
    "owner": "string",
    "number": 0
  },
  "insurance_fund_delta_quote_quantums": "string",
  "maker_order_subaccount_id": {
    "owner": "string",
    "number": 0
  },
  "maker_order_subticks": "string",
  "maker_order_is_buy": true,
  "maker_fee_ppm": 0,
  "clob_pair_id": 0,
  "fill_amount": "string"
}

```

MEVLiquidationMatch represents all necessary data to calculate MEV for a
liquidation.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|» owner|string|false|none|The address of the wallet that owns this subaccount.|
|» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|» owner|string|false|none|The address of the wallet that owns this subaccount.|
|» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|maker_order_subticks|string(uint64)|false|none|none|
|maker_order_is_buy|boolean|false|none|none|
|maker_fee_ppm|integer(int32)|false|none|none|
|clob_pair_id|integer(int64)|false|none|none|
|fill_amount|string(uint64)|false|none|none|

## dydxprotocol.clob.MEVMatch

<a id="schemadydxprotocol.clob.mevmatch"></a>
<a id="schema_dydxprotocol.clob.MEVMatch"></a>
<a id="tocSdydxprotocol.clob.mevmatch"></a>
<a id="tocsdydxprotocol.clob.mevmatch"></a>

```json
{
  "taker_order_subaccount_id": {
    "owner": "string",
    "number": 0
  },
  "taker_fee_ppm": 0,
  "maker_order_subaccount_id": {
    "owner": "string",
    "number": 0
  },
  "maker_order_subticks": "string",
  "maker_order_is_buy": true,
  "maker_fee_ppm": 0,
  "clob_pair_id": 0,
  "fill_amount": "string"
}

```

MEVMatch represents all necessary data to calculate MEV for a regular match.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|» owner|string|false|none|The address of the wallet that owns this subaccount.|
|» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|taker_fee_ppm|integer(int32)|false|none|none|
|maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|» owner|string|false|none|The address of the wallet that owns this subaccount.|
|» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|maker_order_subticks|string(uint64)|false|none|none|
|maker_order_is_buy|boolean|false|none|none|
|maker_fee_ppm|integer(int32)|false|none|none|
|clob_pair_id|integer(int64)|false|none|none|
|fill_amount|string(uint64)|false|none|none|

## dydxprotocol.clob.MaxPerNBlocksRateLimit

<a id="schemadydxprotocol.clob.maxpernblocksratelimit"></a>
<a id="schema_dydxprotocol.clob.MaxPerNBlocksRateLimit"></a>
<a id="tocSdydxprotocol.clob.maxpernblocksratelimit"></a>
<a id="tocsdydxprotocol.clob.maxpernblocksratelimit"></a>

```json
{
  "num_blocks": 0,
  "limit": 0
}

```

Defines a rate limit over a specific number of blocks.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|

## dydxprotocol.clob.MevNodeToNodeCalculationRequest

<a id="schemadydxprotocol.clob.mevnodetonodecalculationrequest"></a>
<a id="schema_dydxprotocol.clob.MevNodeToNodeCalculationRequest"></a>
<a id="tocSdydxprotocol.clob.mevnodetonodecalculationrequest"></a>
<a id="tocsdydxprotocol.clob.mevnodetonodecalculationrequest"></a>

```json
{
  "block_proposer_matches": {
    "matches": [
      {
        "taker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "taker_fee_ppm": 0,
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ],
    "liquidation_matches": [
      {
        "liquidated_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "insurance_fund_delta_quote_quantums": "string",
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ]
  },
  "validator_mev_metrics": {
    "validator_mev_matches": {
      "matches": [
        {
          "taker_order_subaccount_id": {},
          "taker_fee_ppm": 0,
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ],
      "liquidation_matches": [
        {
          "liquidated_subaccount_id": {},
          "insurance_fund_delta_quote_quantums": "string",
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ]
    },
    "clob_mid_prices": [
      {
        "clob_pair": {
          "id": 0,
          "perpetual_clob_metadata": {},
          "spot_clob_metadata": {},
          "step_base_quantums": "string",
          "subticks_per_tick": 0,
          "quantum_conversion_exponent": 0,
          "status": "["
        },
        "subticks": "string"
      }
    ],
    "bp_mev_matches": {
      "matches": [
        {
          "taker_order_subaccount_id": {},
          "taker_fee_ppm": 0,
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ],
      "liquidation_matches": [
        {
          "liquidated_subaccount_id": {},
          "insurance_fund_delta_quote_quantums": "string",
          "maker_order_subaccount_id": {},
          "maker_order_subticks": "string",
          "maker_order_is_buy": true,
          "maker_fee_ppm": 0,
          "clob_pair_id": 0,
          "fill_amount": "string"
        }
      ]
    },
    "proposal_receive_time": "string"
  }
}

```

MevNodeToNodeCalculationRequest is a request message used to run the
MEV node <> node calculation.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_proposer_matches|object|false|none|Represents the matches on the "block proposer". Note that this field<br />does not need to be the actual block proposer's matches for a block, since<br />the MEV calculation logic is run with this nodes matches as the "block<br />proposer" matches.|
|» matches|[object]|false|none|none|
|»» taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» taker_fee_ppm|integer(int32)|false|none|none|
|»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» maker_order_subticks|string(uint64)|false|none|none|
|»» maker_order_is_buy|boolean|false|none|none|
|»» maker_fee_ppm|integer(int32)|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» fill_amount|string(uint64)|false|none|none|
|» liquidation_matches|[object]|false|none|none|
|»» liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» maker_order_subticks|string(uint64)|false|none|none|
|»» maker_order_is_buy|boolean|false|none|none|
|»» maker_fee_ppm|integer(int32)|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» fill_amount|string(uint64)|false|none|none|
|validator_mev_metrics|object|false|none|Represents the matches and mid-prices on the validator.|
|» validator_mev_matches|object|false|none|ValidatorMevMatches contains all matches from the validator's local<br />operations queue.|
|»» matches|[object]|false|none|none|
|»»» taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» taker_fee_ppm|integer(int32)|false|none|none|
|»»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» maker_order_subticks|string(uint64)|false|none|none|
|»»» maker_order_is_buy|boolean|false|none|none|
|»»» maker_fee_ppm|integer(int32)|false|none|none|
|»»» clob_pair_id|integer(int64)|false|none|none|
|»»» fill_amount|string(uint64)|false|none|none|
|»» liquidation_matches|[object]|false|none|none|
|»»» liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|»»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» maker_order_subticks|string(uint64)|false|none|none|
|»»» maker_order_is_buy|boolean|false|none|none|
|»»» maker_fee_ppm|integer(int32)|false|none|none|
|»»» clob_pair_id|integer(int64)|false|none|none|
|»»» fill_amount|string(uint64)|false|none|none|
|» clob_mid_prices|[object]|false|none|none|
|»» clob_pair|object|false|none|ClobPair represents a single CLOB pair for a given product<br />in state.|
|»»» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|»»» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»»»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|»»» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»»»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»»»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|»»» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|»»» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|»»» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|»»» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|
|»» subticks|string(uint64)|false|none|none|
|» bp_mev_matches|object|false|none|ValidatorMevMatches contains all matches from the validator's local<br />operations queue.|
|»» matches|[object]|false|none|none|
|»»» taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» taker_fee_ppm|integer(int32)|false|none|none|
|»»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» maker_order_subticks|string(uint64)|false|none|none|
|»»» maker_order_is_buy|boolean|false|none|none|
|»»» maker_fee_ppm|integer(int32)|false|none|none|
|»»» clob_pair_id|integer(int64)|false|none|none|
|»»» fill_amount|string(uint64)|false|none|none|
|»» liquidation_matches|[object]|false|none|none|
|»»» liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|»»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»»» maker_order_subticks|string(uint64)|false|none|none|
|»»» maker_order_is_buy|boolean|false|none|none|
|»»» maker_fee_ppm|integer(int32)|false|none|none|
|»»» clob_pair_id|integer(int64)|false|none|none|
|»»» fill_amount|string(uint64)|false|none|none|
|» proposal_receive_time|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.MevNodeToNodeCalculationResponse

<a id="schemadydxprotocol.clob.mevnodetonodecalculationresponse"></a>
<a id="schema_dydxprotocol.clob.MevNodeToNodeCalculationResponse"></a>
<a id="tocSdydxprotocol.clob.mevnodetonodecalculationresponse"></a>
<a id="tocsdydxprotocol.clob.mevnodetonodecalculationresponse"></a>

```json
{
  "results": [
    {
      "clob_pair_id": 0,
      "mev": 0.1,
      "volume": "string"
    }
  ]
}

```

MevNodeToNodeCalculationResponse is a response message that contains the
MEV node <> node calculation result.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|results|[object]|false|none|none|
|» clob_pair_id|integer(int64)|false|none|none|
|» mev|number(float)|false|none|none|
|» volume|string(uint64)|false|none|none|

## dydxprotocol.clob.MevNodeToNodeCalculationResponse.MevAndVolumePerClob

<a id="schemadydxprotocol.clob.mevnodetonodecalculationresponse.mevandvolumeperclob"></a>
<a id="schema_dydxprotocol.clob.MevNodeToNodeCalculationResponse.MevAndVolumePerClob"></a>
<a id="tocSdydxprotocol.clob.mevnodetonodecalculationresponse.mevandvolumeperclob"></a>
<a id="tocsdydxprotocol.clob.mevnodetonodecalculationresponse.mevandvolumeperclob"></a>

```json
{
  "clob_pair_id": 0,
  "mev": 0.1,
  "volume": "string"
}

```

MevAndVolumePerClob contains information about the MEV and volume per CLOB.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|clob_pair_id|integer(int64)|false|none|none|
|mev|number(float)|false|none|none|
|volume|string(uint64)|false|none|none|

## dydxprotocol.clob.MevNodeToNodeMetrics

<a id="schemadydxprotocol.clob.mevnodetonodemetrics"></a>
<a id="schema_dydxprotocol.clob.MevNodeToNodeMetrics"></a>
<a id="tocSdydxprotocol.clob.mevnodetonodemetrics"></a>
<a id="tocsdydxprotocol.clob.mevnodetonodemetrics"></a>

```json
{
  "validator_mev_matches": {
    "matches": [
      {
        "taker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "taker_fee_ppm": 0,
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ],
    "liquidation_matches": [
      {
        "liquidated_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "insurance_fund_delta_quote_quantums": "string",
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ]
  },
  "clob_mid_prices": [
    {
      "clob_pair": {
        "id": 0,
        "perpetual_clob_metadata": {
          "perpetual_id": 0
        },
        "spot_clob_metadata": {
          "base_asset_id": 0,
          "quote_asset_id": 0
        },
        "step_base_quantums": "string",
        "subticks_per_tick": 0,
        "quantum_conversion_exponent": 0,
        "status": "STATUS_UNSPECIFIED"
      },
      "subticks": "string"
    }
  ],
  "bp_mev_matches": {
    "matches": [
      {
        "taker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "taker_fee_ppm": 0,
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ],
    "liquidation_matches": [
      {
        "liquidated_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "insurance_fund_delta_quote_quantums": "string",
        "maker_order_subaccount_id": {
          "owner": "string",
          "number": 0
        },
        "maker_order_subticks": "string",
        "maker_order_is_buy": true,
        "maker_fee_ppm": 0,
        "clob_pair_id": 0,
        "fill_amount": "string"
      }
    ]
  },
  "proposal_receive_time": "string"
}

```

MevNodeToNodeMetrics is a data structure for encapsulating all MEV node <>
node metrics.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validator_mev_matches|object|false|none|ValidatorMevMatches contains all matches from the validator's local<br />operations queue.|
|» matches|[object]|false|none|none|
|»» taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» taker_fee_ppm|integer(int32)|false|none|none|
|»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» maker_order_subticks|string(uint64)|false|none|none|
|»» maker_order_is_buy|boolean|false|none|none|
|»» maker_fee_ppm|integer(int32)|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» fill_amount|string(uint64)|false|none|none|
|» liquidation_matches|[object]|false|none|none|
|»» liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» maker_order_subticks|string(uint64)|false|none|none|
|»» maker_order_is_buy|boolean|false|none|none|
|»» maker_fee_ppm|integer(int32)|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» fill_amount|string(uint64)|false|none|none|
|clob_mid_prices|[object]|false|none|none|
|» clob_pair|object|false|none|ClobPair represents a single CLOB pair for a given product<br />in state.|
|»» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|»» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|»» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|»» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|»» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|»» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|»» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|
|» subticks|string(uint64)|false|none|none|
|bp_mev_matches|object|false|none|ValidatorMevMatches contains all matches from the validator's local<br />operations queue.|
|» matches|[object]|false|none|none|
|»» taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» taker_fee_ppm|integer(int32)|false|none|none|
|»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» maker_order_subticks|string(uint64)|false|none|none|
|»» maker_order_is_buy|boolean|false|none|none|
|»» maker_fee_ppm|integer(int32)|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» fill_amount|string(uint64)|false|none|none|
|» liquidation_matches|[object]|false|none|none|
|»» liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|»» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|»» maker_order_subticks|string(uint64)|false|none|none|
|»» maker_order_is_buy|boolean|false|none|none|
|»» maker_fee_ppm|integer(int32)|false|none|none|
|»» clob_pair_id|integer(int64)|false|none|none|
|»» fill_amount|string(uint64)|false|none|none|
|proposal_receive_time|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.PerpetualClobMetadata

<a id="schemadydxprotocol.clob.perpetualclobmetadata"></a>
<a id="schema_dydxprotocol.clob.PerpetualClobMetadata"></a>
<a id="tocSdydxprotocol.clob.perpetualclobmetadata"></a>
<a id="tocsdydxprotocol.clob.perpetualclobmetadata"></a>

```json
{
  "perpetual_id": 0
}

```

PerpetualClobMetadata contains metadata for a `ClobPair`
representing a Perpetual product.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|

## dydxprotocol.clob.PositionBlockLimits

<a id="schemadydxprotocol.clob.positionblocklimits"></a>
<a id="schema_dydxprotocol.clob.PositionBlockLimits"></a>
<a id="tocSdydxprotocol.clob.positionblocklimits"></a>
<a id="tocsdydxprotocol.clob.positionblocklimits"></a>

```json
{
  "min_position_notional_liquidated": "string",
  "max_position_portion_liquidated_ppm": 0
}

```

PositionBlockLimits stores all configurable fields related to limits
around how much of a single position can be liquidated within a single block.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|min_position_notional_liquidated|string(uint64)|false|none|The minimum amount of quantums to liquidate for each message (in<br />quote quantums).<br />Overridden by the maximum size of the position.|
|max_position_portion_liquidated_ppm|integer(int64)|false|none|The maximum portion of the position liquidated (in parts-per-<br />million). Overridden by min_position_notional_liquidated.|

## dydxprotocol.clob.QueryBlockRateLimitConfigurationResponse

<a id="schemadydxprotocol.clob.queryblockratelimitconfigurationresponse"></a>
<a id="schema_dydxprotocol.clob.QueryBlockRateLimitConfigurationResponse"></a>
<a id="tocSdydxprotocol.clob.queryblockratelimitconfigurationresponse"></a>
<a id="tocsdydxprotocol.clob.queryblockratelimitconfigurationresponse"></a>

```json
{
  "block_rate_limit_config": {
    "max_short_term_orders_per_n_blocks": [
      {
        "num_blocks": 0,
        "limit": 0
      }
    ],
    "max_stateful_orders_per_n_blocks": [
      {
        "num_blocks": 0,
        "limit": 0
      }
    ],
    "max_short_term_order_cancellations_per_n_blocks": [
      {
        "num_blocks": 0,
        "limit": 0
      }
    ],
    "max_short_term_orders_and_cancels_per_n_blocks": [
      {
        "num_blocks": 0,
        "limit": 0
      }
    ]
  }
}

```

QueryBlockRateLimitConfigurationResponse is a response message that contains
the BlockRateLimitConfiguration.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_rate_limit_config|object|false|none|Defines the block rate limits for CLOB specific operations.|
|» max_short_term_orders_per_n_blocks|[object]|false|none|How many short term order attempts (successful and failed) are allowed for<br />an account per N blocks. Note that the rate limits are applied<br />in an AND fashion such that an order placement must pass all rate limit<br />configurations.<br /><br />Specifying 0 values disables this rate limit.<br />Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`<br />for v5.x onwards.|
|»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|» max_stateful_orders_per_n_blocks|[object]|false|none|How many stateful order attempts (successful and failed) are allowed for<br />an account per N blocks. Note that the rate limits are applied<br />in an AND fashion such that an order placement must pass all rate limit<br />configurations.<br /><br />Specifying 0 values disables this rate limit.|
|»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|» max_short_term_order_cancellations_per_n_blocks|[object]|false|none|How many short term order cancellation attempts (successful and failed) are<br />allowed for an account per N blocks. Note that the rate limits are<br />applied in an AND fashion such that an order cancellation must pass all<br />rate limit configurations.<br /><br />Specifying 0 values disables this rate limit.<br />Deprecated in favor of `max_short_term_orders_and_cancels_per_n_blocks`<br />for v5.x onwards.|
|»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|
|» max_short_term_orders_and_cancels_per_n_blocks|[object]|false|none|How many short term order place and cancel attempts (successful and failed)<br />are allowed for an account per N blocks. Note that the rate limits are<br />applied in an AND fashion such that an order placement must pass all rate<br />limit configurations.<br /><br />Specifying 0 values disables this rate limit.|
|»» num_blocks|integer(int64)|false|none|How many blocks the rate limit is over.<br />Specifying 0 is invalid.|
|»» limit|integer(int64)|false|none|What the limit is for `num_blocks`.<br />Specifying 0 is invalid.|

## dydxprotocol.clob.QueryClobPairAllResponse

<a id="schemadydxprotocol.clob.queryclobpairallresponse"></a>
<a id="schema_dydxprotocol.clob.QueryClobPairAllResponse"></a>
<a id="tocSdydxprotocol.clob.queryclobpairallresponse"></a>
<a id="tocsdydxprotocol.clob.queryclobpairallresponse"></a>

```json
{
  "clob_pair": [
    {
      "id": 0,
      "perpetual_clob_metadata": {
        "perpetual_id": 0
      },
      "spot_clob_metadata": {
        "base_asset_id": 0,
        "quote_asset_id": 0
      },
      "step_base_quantums": "string",
      "subticks_per_tick": 0,
      "quantum_conversion_exponent": 0,
      "status": "STATUS_UNSPECIFIED"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryClobPairAllResponse is response type for the ClobPairAll method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|clob_pair|[object]|false|none|none|
|» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.QueryClobPairResponse

<a id="schemadydxprotocol.clob.queryclobpairresponse"></a>
<a id="schema_dydxprotocol.clob.QueryClobPairResponse"></a>
<a id="tocSdydxprotocol.clob.queryclobpairresponse"></a>
<a id="tocsdydxprotocol.clob.queryclobpairresponse"></a>

```json
{
  "clob_pair": {
    "id": 0,
    "perpetual_clob_metadata": {
      "perpetual_id": 0
    },
    "spot_clob_metadata": {
      "base_asset_id": 0,
      "quote_asset_id": 0
    },
    "step_base_quantums": "string",
    "subticks_per_tick": 0,
    "quantum_conversion_exponent": 0,
    "status": "STATUS_UNSPECIFIED"
  }
}

```

QueryClobPairResponse is response type for the ClobPair method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|clob_pair|object|false|none|ClobPair represents a single CLOB pair for a given product<br />in state.|
|» id|integer(int64)|false|none|ID of the orderbook that stores all resting liquidity for this CLOB.|
|» perpetual_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Perpetual product.|
|»» perpetual_id|integer(int64)|false|none|Id of the Perpetual the CLOB allows trading of.|
|» spot_clob_metadata|object|false|none|PerpetualClobMetadata contains metadata for a `ClobPair`<br />representing a Spot product.|
|»» base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|»» quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|
|» step_base_quantums|string(uint64)|false|none|Minimum increment in the size of orders on the CLOB, in base quantums.|
|» subticks_per_tick|integer(int64)|false|none|Defines the tick size of the orderbook by defining how many subticks<br />are in one tick. That is, the subticks of any valid order must be a<br />multiple of this value. Generally this value should start `>= 100`to<br />allow room for decreasing it.|
|» quantum_conversion_exponent|integer(int32)|false|none|`10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum<br />per Subtick.|
|» status|string|false|none|Status of the CLOB.<br /><br /> - STATUS_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - STATUS_ACTIVE: STATUS_ACTIVE represents an active clob pair.<br /> - STATUS_PAUSED: STATUS_PAUSED behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_CANCEL_ONLY: STATUS_CANCEL_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_POST_ONLY: STATUS_POST_ONLY behavior is unfinalized.<br />TODO(DEC-600): update this documentation.<br /> - STATUS_INITIALIZING: STATUS_INITIALIZING represents a newly-added clob pair.<br />Clob pairs in this state only accept orders which are<br />both short-term and post-only.<br /> - STATUS_FINAL_SETTLEMENT: STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated<br />and trading has ceased. All open positions will be closed by the<br />protocol. Open stateful orders will be cancelled. Open short-term<br />orders will be left to expire.|

#### Enumerated Values

|Property|Value|
|---|---|
|status|STATUS_UNSPECIFIED|
|status|STATUS_ACTIVE|
|status|STATUS_PAUSED|
|status|STATUS_CANCEL_ONLY|
|status|STATUS_POST_ONLY|
|status|STATUS_INITIALIZING|
|status|STATUS_FINAL_SETTLEMENT|

## dydxprotocol.clob.QueryEquityTierLimitConfigurationResponse

<a id="schemadydxprotocol.clob.queryequitytierlimitconfigurationresponse"></a>
<a id="schema_dydxprotocol.clob.QueryEquityTierLimitConfigurationResponse"></a>
<a id="tocSdydxprotocol.clob.queryequitytierlimitconfigurationresponse"></a>
<a id="tocsdydxprotocol.clob.queryequitytierlimitconfigurationresponse"></a>

```json
{
  "equity_tier_limit_config": {
    "short_term_order_equity_tiers": [
      {
        "usd_tnc_required": "string",
        "limit": 0
      }
    ],
    "stateful_order_equity_tiers": [
      {
        "usd_tnc_required": "string",
        "limit": 0
      }
    ]
  }
}

```

QueryEquityTierLimitConfigurationResponse is a response message that contains
the EquityTierLimitConfiguration.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|equity_tier_limit_config|object|false|none|Defines the set of equity tiers to limit how many open orders<br />a subaccount is allowed to have.|
|» short_term_order_equity_tiers|[object]|false|none|How many short term stateful orders are allowed per equity tier.<br />Specifying 0 values disables this limit.|
|»» usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|»» limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|
|» stateful_order_equity_tiers|[object]|false|none|How many open stateful orders are allowed per equity tier.<br />Specifying 0 values disables this limit.|
|»» usd_tnc_required|string(byte)|false|none|The total net collateral in USDC quote quantums of equity required.|
|»» limit|integer(int64)|false|none|What the limit is for `usd_tnc_required`.|

## dydxprotocol.clob.QueryLiquidationsConfigurationResponse

<a id="schemadydxprotocol.clob.queryliquidationsconfigurationresponse"></a>
<a id="schema_dydxprotocol.clob.QueryLiquidationsConfigurationResponse"></a>
<a id="tocSdydxprotocol.clob.queryliquidationsconfigurationresponse"></a>
<a id="tocsdydxprotocol.clob.queryliquidationsconfigurationresponse"></a>

```json
{
  "liquidations_config": {
    "max_liquidation_fee_ppm": 0,
    "position_block_limits": {
      "min_position_notional_liquidated": "string",
      "max_position_portion_liquidated_ppm": 0
    },
    "subaccount_block_limits": {
      "max_notional_liquidated": "string",
      "max_quantums_insurance_lost": "string"
    },
    "fillable_price_config": {
      "bankruptcy_adjustment_ppm": 0,
      "spread_to_maintenance_margin_ratio_ppm": 0
    }
  }
}

```

QueryLiquidationsConfigurationResponse is a response message that contains
the LiquidationsConfiguration.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|liquidations_config|object|false|none|LiquidationsConfig stores all configurable fields related to liquidations.|
|» max_liquidation_fee_ppm|integer(int64)|false|none|The maximum liquidation fee (in parts-per-million). This fee goes<br />100% to the insurance fund.|
|» position_block_limits|object|false|none|Limits around how much of a single position can be liquidated<br />within a single block.|
|»» min_position_notional_liquidated|string(uint64)|false|none|The minimum amount of quantums to liquidate for each message (in<br />quote quantums).<br />Overridden by the maximum size of the position.|
|»» max_position_portion_liquidated_ppm|integer(int64)|false|none|The maximum portion of the position liquidated (in parts-per-<br />million). Overridden by min_position_notional_liquidated.|
|» subaccount_block_limits|object|false|none|Limits around how many quote quantums from a single subaccount can<br />be liquidated within a single block.|
|»» max_notional_liquidated|string(uint64)|false|none|The maximum notional amount that a single subaccount can have<br />liquidated (in quote quantums) per block.|
|»» max_quantums_insurance_lost|string(uint64)|false|none|The maximum insurance-fund payout amount for a given subaccount<br />per block. I.e. how much it can cover for that subaccount.|
|» fillable_price_config|object|false|none|Config about how the fillable-price spread from the oracle price<br />increases based on the adjusted bankruptcy rating of the subaccount.|
|»» bankruptcy_adjustment_ppm|integer(int64)|false|none|The rate at which the Adjusted Bankruptcy Rating increases.|
|»» spread_to_maintenance_margin_ratio_ppm|integer(int64)|false|none|The maximum value that the liquidation spread can take, as<br />a ratio against the position's maintenance margin.|

## dydxprotocol.clob.SpotClobMetadata

<a id="schemadydxprotocol.clob.spotclobmetadata"></a>
<a id="schema_dydxprotocol.clob.SpotClobMetadata"></a>
<a id="tocSdydxprotocol.clob.spotclobmetadata"></a>
<a id="tocsdydxprotocol.clob.spotclobmetadata"></a>

```json
{
  "base_asset_id": 0,
  "quote_asset_id": 0
}

```

PerpetualClobMetadata contains metadata for a `ClobPair`
representing a Spot product.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|base_asset_id|integer(int64)|false|none|Id of the base Asset in the trading pair.|
|quote_asset_id|integer(int64)|false|none|Id of the quote Asset in the trading pair.|

## dydxprotocol.clob.StreamOrderbookUpdatesResponse

<a id="schemadydxprotocol.clob.streamorderbookupdatesresponse"></a>
<a id="schema_dydxprotocol.clob.StreamOrderbookUpdatesResponse"></a>
<a id="tocSdydxprotocol.clob.streamorderbookupdatesresponse"></a>
<a id="tocsdydxprotocol.clob.streamorderbookupdatesresponse"></a>

```json
{
  "updates": [
    {
      "order_place": {
        "order": {
          "order_id": {},
          "side": "[",
          "quantums": "string",
          "subticks": "string",
          "good_til_block": 0,
          "good_til_block_time": 0,
          "time_in_force": "[",
          "reduce_only": true,
          "client_metadata": 0,
          "condition_type": "[",
          "conditional_order_trigger_subticks": "string"
        },
        "placement_status": "ORDER_PLACEMENT_STATUS_UNSPECIFIED"
      },
      "order_remove": {
        "removed_order_id": {
          "subaccount_id": {},
          "client_id": 0,
          "order_flags": 0,
          "clob_pair_id": 0
        },
        "reason": "ORDER_REMOVAL_REASON_UNSPECIFIED",
        "removal_status": "ORDER_REMOVAL_STATUS_UNSPECIFIED"
      },
      "order_update": {
        "order_id": {
          "subaccount_id": {},
          "client_id": 0,
          "order_flags": 0,
          "clob_pair_id": 0
        },
        "total_filled_quantums": "string"
      }
    }
  ],
  "snapshot": true,
  "block_height": 0,
  "exec_mode": 0
}

```

StreamOrderbookUpdatesResponse is a response message for the
StreamOrderbookUpdates method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|updates|[object]|false|none|Orderbook updates for the clob pair.|
|» order_place|object|false|none|OrderPlace messages contain the order placed/replaced.|
|»» order|object|false|none|IndexerOrderV1 represents a single order belonging to a `Subaccount`<br />for a particular `ClobPair`.|
|»»» order_id|object|false|none|The unique ID of this order. Meant to be unique across all orders.|
|»»»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»»»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»»»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»»»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|»»» side|string|false|none|Represents the side of the orderbook the order will be placed on.<br />Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be<br />placed on the orderbook.<br /><br /> - SIDE_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - SIDE_BUY: SIDE_BUY is used to represent a BUY order.<br /> - SIDE_SELL: SIDE_SELL is used to represent a SELL order.|
|»»» quantums|string(uint64)|false|none|The size of this order in base quantums. Must be a multiple of<br />`ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).|
|»»» subticks|string(uint64)|false|none|The price level that this order will be placed at on the orderbook,<br />in subticks. Must be a multiple of ClobPair.SubticksPerTick<br />(where `ClobPair.Id = orderId.ClobPairId`).|
|»»» good_til_block|integer(int64)|false|none|The last block this order can be executed at (after which it will be<br />unfillable). Used only for Short-Term orders. If this value is non-zero<br />then the order is assumed to be a Short-Term order.|
|»»» good_til_block_time|integer(int64)|false|none|good_til_block_time represents the unix timestamp (in seconds) at which a<br />stateful order will be considered expired. The<br />good_til_block_time is always evaluated against the previous block's<br />`BlockTime` instead of the block in which the order is committed. If this<br />value is non-zero then the order is assumed to be a stateful or<br />conditional order.|
|»»» time_in_force|string|false|none|The time in force of this order.|
|»»» reduce_only|boolean|false|none|Enforces that the order can only reduce the size of an existing position.<br />If a ReduceOnly order would change the side of the existing position,<br />its size is reduced to that of the remaining size of the position.<br />If existing orders on the book with ReduceOnly<br />would already close the position, the least aggressive (out-of-the-money)<br />ReduceOnly orders are resized and canceled first.|
|»»» client_metadata|integer(int64)|false|none|Set of bit flags set arbitrarily by clients and ignored by the protocol.<br />Used by indexer to infer information about a placed order.|
|»»» condition_type|string|false|none|- CONDITION_TYPE_UNSPECIFIED: CONDITION_TYPE_UNSPECIFIED represents the default behavior where an<br />order will be placed immediately on the orderbook.<br /> - CONDITION_TYPE_STOP_LOSS: CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will<br />trigger when the oracle price moves at or above the trigger price for<br />buys, and at or below the trigger price for sells.<br /> - CONDITION_TYPE_TAKE_PROFIT: CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit<br />order will trigger when the oracle price moves at or below the trigger<br />price for buys and at or above the trigger price for sells.|
|»»» conditional_order_trigger_subticks|string(uint64)|false|none|conditional_order_trigger_subticks represents the price at which this order<br />will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,<br />this value is enforced to be 0. If this value is nonzero, condition_type<br />cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.<br />Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =<br />orderId.ClobPairId`).|
|»» placement_status|string|false|none|OrderPlacementStatus is an enum for the resulting status after an order is<br />placed.<br /><br /> - ORDER_PLACEMENT_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED: A best effort opened order is one that has only been confirmed to be<br />placed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- The dYdX node places an order in it's in-memory orderbook during the<br />  CheckTx flow.<br />A best effort placed order may not have been placed on other dYdX<br />nodes including other dYdX validator nodes and may still be excluded in<br />future order matches.<br /> - ORDER_PLACEMENT_STATUS_OPENED: An opened order is one that is confirmed to be placed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will be included in any future<br />order matches.<br />This status is used internally by the indexer and will not be sent<br />out by protocol.|
|» order_remove|object|false|none|OrderRemove messages contain the id of the order removed, the reason for the<br />removal and the resulting status from the removal.|
|»» removed_order_id|object|false|none|IndexerOrderId refers to a single order belonging to a Subaccount.|
|»»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|»» reason|string|false|none|OrderRemovalReason is an enum of all the reasons an order was removed.<br /><br /> - ORDER_REMOVAL_REASON_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_REASON_EXPIRED: The order was removed due to being expired.<br /> - ORDER_REMOVAL_REASON_USER_CANCELED: The order was removed due to being canceled by a user.<br /> - ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED: The order was removed due to being undercollateralized.<br /> - ORDER_REMOVAL_REASON_INTERNAL_ERROR: The order caused an internal error during order placement and was<br />removed.<br /> - ORDER_REMOVAL_REASON_SELF_TRADE_ERROR: The order would have matched against another order placed by the same<br />subaccount and was removed.<br /> - ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER: The order would have matched against maker orders on the orderbook<br />despite being a post-only order and was removed.<br /> - ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK: The order was an ICO order and would have been placed on the orderbook as<br />resting liquidity and was removed.<br /> - ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED: The order was a fill-or-kill order that could not be fully filled and was<br />removed.<br /> - ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE: The order was a reduce-only order that was removed due to either:<br />- being a taker order and fully-filling the order would flip the side of<br />   the subaccount's position, in this case the remaining size of the<br />   order is removed<br />- being a maker order resting on the book and being removed when either<br />   the subaccount's position is closed or flipped sides<br /> - ORDER_REMOVAL_REASON_INDEXER_EXPIRED: The order should be expired, according to the Indexer's cached data, but<br />the Indexer has yet to receive a message to remove the order. In order to<br />keep the data cached by the Indexer up-to-date and accurate, clear out<br />the data if it's expired by sending an order removal with this reason.<br />Protocol should never send this reason to Indexer.<br /> - ORDER_REMOVAL_REASON_REPLACED: The order has been replaced.<br /> - ORDER_REMOVAL_REASON_FULLY_FILLED: The order has been fully-filled. Only sent by the Indexer for stateful<br />orders.<br /> - ORDER_REMOVAL_REASON_EQUITY_TIER: The order has been removed since the subaccount does not satisfy the<br />equity tier requirements.<br /> - ORDER_REMOVAL_REASON_FINAL_SETTLEMENT: The order has been removed since its ClobPair has entered final settlement.|
|»» removal_status|string|false|none|OrderRemovalStatus is an enum for the resulting status after an order is<br />removed.<br /><br /> - ORDER_REMOVAL_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED: A best effort canceled order is one that has only been confirmed to be<br />removed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- the order was removed due to the dYdX node receiving a CancelOrder<br />  transaction for the order.<br />- the order was removed due to being undercollateralized during<br />  optimistic matching.<br />A best effort canceled order may not have been removed on other dYdX<br />nodes including other dYdX validator nodes and may still be included in<br />future order matches.<br /> - ORDER_REMOVAL_STATUS_CANCELED: A canceled order is one that is confirmed to be removed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will not be included in any future<br />order matches.<br />The cases where this happens includes:<br />- the order is expired.<br /> - ORDER_REMOVAL_STATUS_FILLED: An order was fully-filled. Only sent by the Indexer for stateful orders.|
|» order_update|object|false|none|OrderUpdate messages contain the id of the order being updated, and the<br />updated total filled quantums of the order.|
|»» order_id|object|false|none|IndexerOrderId refers to a single order belonging to a Subaccount.|
|»»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|»» total_filled_quantums|string(uint64)|false|none|none|
|snapshot|boolean|false|none|Snapshot indicates if the response is from a snapshot of the orderbook.<br />This is true for the initial response and false for all subsequent updates.<br />Note that if the snapshot is true, then all previous entries should be<br />discarded and the orderbook should be resynced.|
|block_height|integer(int64)|false|none|---Additional fields used to debug issues---<br />Block height of the updates.|
|exec_mode|integer(int64)|false|none|Exec mode of the updates.|

#### Enumerated Values

|Property|Value|
|---|---|
|side|SIDE_UNSPECIFIED|
|side|SIDE_BUY|
|side|SIDE_SELL|
|time_in_force|TIME_IN_FORCE_UNSPECIFIED|
|time_in_force|TIME_IN_FORCE_IOC|
|time_in_force|TIME_IN_FORCE_POST_ONLY|
|time_in_force|TIME_IN_FORCE_FILL_OR_KILL|
|condition_type|CONDITION_TYPE_UNSPECIFIED|
|condition_type|CONDITION_TYPE_STOP_LOSS|
|condition_type|CONDITION_TYPE_TAKE_PROFIT|
|placement_status|ORDER_PLACEMENT_STATUS_UNSPECIFIED|
|placement_status|ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED|
|placement_status|ORDER_PLACEMENT_STATUS_OPENED|
|reason|ORDER_REMOVAL_REASON_UNSPECIFIED|
|reason|ORDER_REMOVAL_REASON_EXPIRED|
|reason|ORDER_REMOVAL_REASON_USER_CANCELED|
|reason|ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED|
|reason|ORDER_REMOVAL_REASON_INTERNAL_ERROR|
|reason|ORDER_REMOVAL_REASON_SELF_TRADE_ERROR|
|reason|ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER|
|reason|ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK|
|reason|ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED|
|reason|ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE|
|reason|ORDER_REMOVAL_REASON_INDEXER_EXPIRED|
|reason|ORDER_REMOVAL_REASON_REPLACED|
|reason|ORDER_REMOVAL_REASON_FULLY_FILLED|
|reason|ORDER_REMOVAL_REASON_EQUITY_TIER|
|reason|ORDER_REMOVAL_REASON_FINAL_SETTLEMENT|
|removal_status|ORDER_REMOVAL_STATUS_UNSPECIFIED|
|removal_status|ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED|
|removal_status|ORDER_REMOVAL_STATUS_CANCELED|
|removal_status|ORDER_REMOVAL_STATUS_FILLED|

## dydxprotocol.clob.SubaccountBlockLimits

<a id="schemadydxprotocol.clob.subaccountblocklimits"></a>
<a id="schema_dydxprotocol.clob.SubaccountBlockLimits"></a>
<a id="tocSdydxprotocol.clob.subaccountblocklimits"></a>
<a id="tocsdydxprotocol.clob.subaccountblocklimits"></a>

```json
{
  "max_notional_liquidated": "string",
  "max_quantums_insurance_lost": "string"
}

```

SubaccountBlockLimits stores all configurable fields related to limits
around how many quote quantums from a single subaccount can
be liquidated within a single block.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|max_notional_liquidated|string(uint64)|false|none|The maximum notional amount that a single subaccount can have<br />liquidated (in quote quantums) per block.|
|max_quantums_insurance_lost|string(uint64)|false|none|The maximum insurance-fund payout amount for a given subaccount<br />per block. I.e. how much it can cover for that subaccount.|

## dydxprotocol.clob.ValidatorMevMatches

<a id="schemadydxprotocol.clob.validatormevmatches"></a>
<a id="schema_dydxprotocol.clob.ValidatorMevMatches"></a>
<a id="tocSdydxprotocol.clob.validatormevmatches"></a>
<a id="tocsdydxprotocol.clob.validatormevmatches"></a>

```json
{
  "matches": [
    {
      "taker_order_subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "taker_fee_ppm": 0,
      "maker_order_subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "maker_order_subticks": "string",
      "maker_order_is_buy": true,
      "maker_fee_ppm": 0,
      "clob_pair_id": 0,
      "fill_amount": "string"
    }
  ],
  "liquidation_matches": [
    {
      "liquidated_subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "insurance_fund_delta_quote_quantums": "string",
      "maker_order_subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "maker_order_subticks": "string",
      "maker_order_is_buy": true,
      "maker_fee_ppm": 0,
      "clob_pair_id": 0,
      "fill_amount": "string"
    }
  ]
}

```

ValidatorMevMatches contains all matches from the validator's local
operations queue.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|matches|[object]|false|none|none|
|» taker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|» taker_fee_ppm|integer(int32)|false|none|none|
|» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|» maker_order_subticks|string(uint64)|false|none|none|
|» maker_order_is_buy|boolean|false|none|none|
|» maker_fee_ppm|integer(int32)|false|none|none|
|» clob_pair_id|integer(int64)|false|none|none|
|» fill_amount|string(uint64)|false|none|none|
|liquidation_matches|[object]|false|none|none|
|» liquidated_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|» insurance_fund_delta_quote_quantums|string(int64)|false|none|none|
|» maker_order_subaccount_id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|» maker_order_subticks|string(uint64)|false|none|none|
|» maker_order_is_buy|boolean|false|none|none|
|» maker_fee_ppm|integer(int32)|false|none|none|
|» clob_pair_id|integer(int64)|false|none|none|
|» fill_amount|string(uint64)|false|none|none|

## dydxprotocol.indexer.off_chain_updates.OffChainUpdateV1

<a id="schemadydxprotocol.indexer.off_chain_updates.offchainupdatev1"></a>
<a id="schema_dydxprotocol.indexer.off_chain_updates.OffChainUpdateV1"></a>
<a id="tocSdydxprotocol.indexer.off_chain_updates.offchainupdatev1"></a>
<a id="tocsdydxprotocol.indexer.off_chain_updates.offchainupdatev1"></a>

```json
{
  "order_place": {
    "order": {
      "order_id": {
        "subaccount_id": {
          "owner": null,
          "number": null
        },
        "client_id": 0,
        "order_flags": 0,
        "clob_pair_id": 0
      },
      "side": "SIDE_UNSPECIFIED",
      "quantums": "string",
      "subticks": "string",
      "good_til_block": 0,
      "good_til_block_time": 0,
      "time_in_force": "TIME_IN_FORCE_UNSPECIFIED",
      "reduce_only": true,
      "client_metadata": 0,
      "condition_type": "CONDITION_TYPE_UNSPECIFIED",
      "conditional_order_trigger_subticks": "string"
    },
    "placement_status": "ORDER_PLACEMENT_STATUS_UNSPECIFIED"
  },
  "order_remove": {
    "removed_order_id": {
      "subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "client_id": 0,
      "order_flags": 0,
      "clob_pair_id": 0
    },
    "reason": "ORDER_REMOVAL_REASON_UNSPECIFIED",
    "removal_status": "ORDER_REMOVAL_STATUS_UNSPECIFIED"
  },
  "order_update": {
    "order_id": {
      "subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "client_id": 0,
      "order_flags": 0,
      "clob_pair_id": 0
    },
    "total_filled_quantums": "string"
  }
}

```

An OffChainUpdate message is the message type which will be sent on Kafka to
the Indexer.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|order_place|object|false|none|OrderPlace messages contain the order placed/replaced.|
|» order|object|false|none|IndexerOrderV1 represents a single order belonging to a `Subaccount`<br />for a particular `ClobPair`.|
|»» order_id|object|false|none|The unique ID of this order. Meant to be unique across all orders.|
|»»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|»» side|string|false|none|Represents the side of the orderbook the order will be placed on.<br />Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be<br />placed on the orderbook.<br /><br /> - SIDE_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - SIDE_BUY: SIDE_BUY is used to represent a BUY order.<br /> - SIDE_SELL: SIDE_SELL is used to represent a SELL order.|
|»» quantums|string(uint64)|false|none|The size of this order in base quantums. Must be a multiple of<br />`ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).|
|»» subticks|string(uint64)|false|none|The price level that this order will be placed at on the orderbook,<br />in subticks. Must be a multiple of ClobPair.SubticksPerTick<br />(where `ClobPair.Id = orderId.ClobPairId`).|
|»» good_til_block|integer(int64)|false|none|The last block this order can be executed at (after which it will be<br />unfillable). Used only for Short-Term orders. If this value is non-zero<br />then the order is assumed to be a Short-Term order.|
|»» good_til_block_time|integer(int64)|false|none|good_til_block_time represents the unix timestamp (in seconds) at which a<br />stateful order will be considered expired. The<br />good_til_block_time is always evaluated against the previous block's<br />`BlockTime` instead of the block in which the order is committed. If this<br />value is non-zero then the order is assumed to be a stateful or<br />conditional order.|
|»» time_in_force|string|false|none|The time in force of this order.|
|»» reduce_only|boolean|false|none|Enforces that the order can only reduce the size of an existing position.<br />If a ReduceOnly order would change the side of the existing position,<br />its size is reduced to that of the remaining size of the position.<br />If existing orders on the book with ReduceOnly<br />would already close the position, the least aggressive (out-of-the-money)<br />ReduceOnly orders are resized and canceled first.|
|»» client_metadata|integer(int64)|false|none|Set of bit flags set arbitrarily by clients and ignored by the protocol.<br />Used by indexer to infer information about a placed order.|
|»» condition_type|string|false|none|- CONDITION_TYPE_UNSPECIFIED: CONDITION_TYPE_UNSPECIFIED represents the default behavior where an<br />order will be placed immediately on the orderbook.<br /> - CONDITION_TYPE_STOP_LOSS: CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will<br />trigger when the oracle price moves at or above the trigger price for<br />buys, and at or below the trigger price for sells.<br /> - CONDITION_TYPE_TAKE_PROFIT: CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit<br />order will trigger when the oracle price moves at or below the trigger<br />price for buys and at or above the trigger price for sells.|
|»» conditional_order_trigger_subticks|string(uint64)|false|none|conditional_order_trigger_subticks represents the price at which this order<br />will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,<br />this value is enforced to be 0. If this value is nonzero, condition_type<br />cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.<br />Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =<br />orderId.ClobPairId`).|
|» placement_status|string|false|none|OrderPlacementStatus is an enum for the resulting status after an order is<br />placed.<br /><br /> - ORDER_PLACEMENT_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED: A best effort opened order is one that has only been confirmed to be<br />placed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- The dYdX node places an order in it's in-memory orderbook during the<br />  CheckTx flow.<br />A best effort placed order may not have been placed on other dYdX<br />nodes including other dYdX validator nodes and may still be excluded in<br />future order matches.<br /> - ORDER_PLACEMENT_STATUS_OPENED: An opened order is one that is confirmed to be placed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will be included in any future<br />order matches.<br />This status is used internally by the indexer and will not be sent<br />out by protocol.|
|order_remove|object|false|none|OrderRemove messages contain the id of the order removed, the reason for the<br />removal and the resulting status from the removal.|
|» removed_order_id|object|false|none|IndexerOrderId refers to a single order belonging to a Subaccount.|
|»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|» reason|string|false|none|OrderRemovalReason is an enum of all the reasons an order was removed.<br /><br /> - ORDER_REMOVAL_REASON_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_REASON_EXPIRED: The order was removed due to being expired.<br /> - ORDER_REMOVAL_REASON_USER_CANCELED: The order was removed due to being canceled by a user.<br /> - ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED: The order was removed due to being undercollateralized.<br /> - ORDER_REMOVAL_REASON_INTERNAL_ERROR: The order caused an internal error during order placement and was<br />removed.<br /> - ORDER_REMOVAL_REASON_SELF_TRADE_ERROR: The order would have matched against another order placed by the same<br />subaccount and was removed.<br /> - ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER: The order would have matched against maker orders on the orderbook<br />despite being a post-only order and was removed.<br /> - ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK: The order was an ICO order and would have been placed on the orderbook as<br />resting liquidity and was removed.<br /> - ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED: The order was a fill-or-kill order that could not be fully filled and was<br />removed.<br /> - ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE: The order was a reduce-only order that was removed due to either:<br />- being a taker order and fully-filling the order would flip the side of<br />   the subaccount's position, in this case the remaining size of the<br />   order is removed<br />- being a maker order resting on the book and being removed when either<br />   the subaccount's position is closed or flipped sides<br /> - ORDER_REMOVAL_REASON_INDEXER_EXPIRED: The order should be expired, according to the Indexer's cached data, but<br />the Indexer has yet to receive a message to remove the order. In order to<br />keep the data cached by the Indexer up-to-date and accurate, clear out<br />the data if it's expired by sending an order removal with this reason.<br />Protocol should never send this reason to Indexer.<br /> - ORDER_REMOVAL_REASON_REPLACED: The order has been replaced.<br /> - ORDER_REMOVAL_REASON_FULLY_FILLED: The order has been fully-filled. Only sent by the Indexer for stateful<br />orders.<br /> - ORDER_REMOVAL_REASON_EQUITY_TIER: The order has been removed since the subaccount does not satisfy the<br />equity tier requirements.<br /> - ORDER_REMOVAL_REASON_FINAL_SETTLEMENT: The order has been removed since its ClobPair has entered final settlement.|
|» removal_status|string|false|none|OrderRemovalStatus is an enum for the resulting status after an order is<br />removed.<br /><br /> - ORDER_REMOVAL_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED: A best effort canceled order is one that has only been confirmed to be<br />removed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- the order was removed due to the dYdX node receiving a CancelOrder<br />  transaction for the order.<br />- the order was removed due to being undercollateralized during<br />  optimistic matching.<br />A best effort canceled order may not have been removed on other dYdX<br />nodes including other dYdX validator nodes and may still be included in<br />future order matches.<br /> - ORDER_REMOVAL_STATUS_CANCELED: A canceled order is one that is confirmed to be removed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will not be included in any future<br />order matches.<br />The cases where this happens includes:<br />- the order is expired.<br /> - ORDER_REMOVAL_STATUS_FILLED: An order was fully-filled. Only sent by the Indexer for stateful orders.|
|order_update|object|false|none|OrderUpdate messages contain the id of the order being updated, and the<br />updated total filled quantums of the order.|
|» order_id|object|false|none|IndexerOrderId refers to a single order belonging to a Subaccount.|
|»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|» total_filled_quantums|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|side|SIDE_UNSPECIFIED|
|side|SIDE_BUY|
|side|SIDE_SELL|
|time_in_force|TIME_IN_FORCE_UNSPECIFIED|
|time_in_force|TIME_IN_FORCE_IOC|
|time_in_force|TIME_IN_FORCE_POST_ONLY|
|time_in_force|TIME_IN_FORCE_FILL_OR_KILL|
|condition_type|CONDITION_TYPE_UNSPECIFIED|
|condition_type|CONDITION_TYPE_STOP_LOSS|
|condition_type|CONDITION_TYPE_TAKE_PROFIT|
|placement_status|ORDER_PLACEMENT_STATUS_UNSPECIFIED|
|placement_status|ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED|
|placement_status|ORDER_PLACEMENT_STATUS_OPENED|
|reason|ORDER_REMOVAL_REASON_UNSPECIFIED|
|reason|ORDER_REMOVAL_REASON_EXPIRED|
|reason|ORDER_REMOVAL_REASON_USER_CANCELED|
|reason|ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED|
|reason|ORDER_REMOVAL_REASON_INTERNAL_ERROR|
|reason|ORDER_REMOVAL_REASON_SELF_TRADE_ERROR|
|reason|ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER|
|reason|ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK|
|reason|ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED|
|reason|ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE|
|reason|ORDER_REMOVAL_REASON_INDEXER_EXPIRED|
|reason|ORDER_REMOVAL_REASON_REPLACED|
|reason|ORDER_REMOVAL_REASON_FULLY_FILLED|
|reason|ORDER_REMOVAL_REASON_EQUITY_TIER|
|reason|ORDER_REMOVAL_REASON_FINAL_SETTLEMENT|
|removal_status|ORDER_REMOVAL_STATUS_UNSPECIFIED|
|removal_status|ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED|
|removal_status|ORDER_REMOVAL_STATUS_CANCELED|
|removal_status|ORDER_REMOVAL_STATUS_FILLED|

## dydxprotocol.indexer.off_chain_updates.OrderPlaceV1

<a id="schemadydxprotocol.indexer.off_chain_updates.orderplacev1"></a>
<a id="schema_dydxprotocol.indexer.off_chain_updates.OrderPlaceV1"></a>
<a id="tocSdydxprotocol.indexer.off_chain_updates.orderplacev1"></a>
<a id="tocsdydxprotocol.indexer.off_chain_updates.orderplacev1"></a>

```json
{
  "order": {
    "order_id": {
      "subaccount_id": {
        "owner": "string",
        "number": 0
      },
      "client_id": 0,
      "order_flags": 0,
      "clob_pair_id": 0
    },
    "side": "SIDE_UNSPECIFIED",
    "quantums": "string",
    "subticks": "string",
    "good_til_block": 0,
    "good_til_block_time": 0,
    "time_in_force": "TIME_IN_FORCE_UNSPECIFIED",
    "reduce_only": true,
    "client_metadata": 0,
    "condition_type": "CONDITION_TYPE_UNSPECIFIED",
    "conditional_order_trigger_subticks": "string"
  },
  "placement_status": "ORDER_PLACEMENT_STATUS_UNSPECIFIED"
}

```

OrderPlace messages contain the order placed/replaced.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|order|object|false|none|IndexerOrderV1 represents a single order belonging to a `Subaccount`<br />for a particular `ClobPair`.|
|» order_id|object|false|none|The unique ID of this order. Meant to be unique across all orders.|
|»» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|»» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|»» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|»» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|» side|string|false|none|Represents the side of the orderbook the order will be placed on.<br />Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be<br />placed on the orderbook.<br /><br /> - SIDE_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - SIDE_BUY: SIDE_BUY is used to represent a BUY order.<br /> - SIDE_SELL: SIDE_SELL is used to represent a SELL order.|
|» quantums|string(uint64)|false|none|The size of this order in base quantums. Must be a multiple of<br />`ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).|
|» subticks|string(uint64)|false|none|The price level that this order will be placed at on the orderbook,<br />in subticks. Must be a multiple of ClobPair.SubticksPerTick<br />(where `ClobPair.Id = orderId.ClobPairId`).|
|» good_til_block|integer(int64)|false|none|The last block this order can be executed at (after which it will be<br />unfillable). Used only for Short-Term orders. If this value is non-zero<br />then the order is assumed to be a Short-Term order.|
|» good_til_block_time|integer(int64)|false|none|good_til_block_time represents the unix timestamp (in seconds) at which a<br />stateful order will be considered expired. The<br />good_til_block_time is always evaluated against the previous block's<br />`BlockTime` instead of the block in which the order is committed. If this<br />value is non-zero then the order is assumed to be a stateful or<br />conditional order.|
|» time_in_force|string|false|none|The time in force of this order.|
|» reduce_only|boolean|false|none|Enforces that the order can only reduce the size of an existing position.<br />If a ReduceOnly order would change the side of the existing position,<br />its size is reduced to that of the remaining size of the position.<br />If existing orders on the book with ReduceOnly<br />would already close the position, the least aggressive (out-of-the-money)<br />ReduceOnly orders are resized and canceled first.|
|» client_metadata|integer(int64)|false|none|Set of bit flags set arbitrarily by clients and ignored by the protocol.<br />Used by indexer to infer information about a placed order.|
|» condition_type|string|false|none|- CONDITION_TYPE_UNSPECIFIED: CONDITION_TYPE_UNSPECIFIED represents the default behavior where an<br />order will be placed immediately on the orderbook.<br /> - CONDITION_TYPE_STOP_LOSS: CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will<br />trigger when the oracle price moves at or above the trigger price for<br />buys, and at or below the trigger price for sells.<br /> - CONDITION_TYPE_TAKE_PROFIT: CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit<br />order will trigger when the oracle price moves at or below the trigger<br />price for buys and at or above the trigger price for sells.|
|» conditional_order_trigger_subticks|string(uint64)|false|none|conditional_order_trigger_subticks represents the price at which this order<br />will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,<br />this value is enforced to be 0. If this value is nonzero, condition_type<br />cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.<br />Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =<br />orderId.ClobPairId`).|
|placement_status|string|false|none|OrderPlacementStatus is an enum for the resulting status after an order is<br />placed.<br /><br /> - ORDER_PLACEMENT_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED: A best effort opened order is one that has only been confirmed to be<br />placed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- The dYdX node places an order in it's in-memory orderbook during the<br />  CheckTx flow.<br />A best effort placed order may not have been placed on other dYdX<br />nodes including other dYdX validator nodes and may still be excluded in<br />future order matches.<br /> - ORDER_PLACEMENT_STATUS_OPENED: An opened order is one that is confirmed to be placed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will be included in any future<br />order matches.<br />This status is used internally by the indexer and will not be sent<br />out by protocol.|

#### Enumerated Values

|Property|Value|
|---|---|
|side|SIDE_UNSPECIFIED|
|side|SIDE_BUY|
|side|SIDE_SELL|
|time_in_force|TIME_IN_FORCE_UNSPECIFIED|
|time_in_force|TIME_IN_FORCE_IOC|
|time_in_force|TIME_IN_FORCE_POST_ONLY|
|time_in_force|TIME_IN_FORCE_FILL_OR_KILL|
|condition_type|CONDITION_TYPE_UNSPECIFIED|
|condition_type|CONDITION_TYPE_STOP_LOSS|
|condition_type|CONDITION_TYPE_TAKE_PROFIT|
|placement_status|ORDER_PLACEMENT_STATUS_UNSPECIFIED|
|placement_status|ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED|
|placement_status|ORDER_PLACEMENT_STATUS_OPENED|

## dydxprotocol.indexer.off_chain_updates.OrderPlaceV1.OrderPlacementStatus

<a id="schemadydxprotocol.indexer.off_chain_updates.orderplacev1.orderplacementstatus"></a>
<a id="schema_dydxprotocol.indexer.off_chain_updates.OrderPlaceV1.OrderPlacementStatus"></a>
<a id="tocSdydxprotocol.indexer.off_chain_updates.orderplacev1.orderplacementstatus"></a>
<a id="tocsdydxprotocol.indexer.off_chain_updates.orderplacev1.orderplacementstatus"></a>

```json
"ORDER_PLACEMENT_STATUS_UNSPECIFIED"

```

OrderPlacementStatus is an enum for the resulting status after an order is
placed.

 - ORDER_PLACEMENT_STATUS_UNSPECIFIED: Default value, this is invalid and unused.
 - ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED: A best effort opened order is one that has only been confirmed to be
placed on the dYdX node sending the off-chain update message.
The cases where this happens includes:
- The dYdX node places an order in it's in-memory orderbook during the
  CheckTx flow.
A best effort placed order may not have been placed on other dYdX
nodes including other dYdX validator nodes and may still be excluded in
future order matches.
 - ORDER_PLACEMENT_STATUS_OPENED: An opened order is one that is confirmed to be placed on all dYdX nodes
(discounting dishonest dYdX nodes) and will be included in any future
order matches.
This status is used internally by the indexer and will not be sent
out by protocol.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|OrderPlacementStatus is an enum for the resulting status after an order is<br />placed.<br /><br /> - ORDER_PLACEMENT_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED: A best effort opened order is one that has only been confirmed to be<br />placed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- The dYdX node places an order in it's in-memory orderbook during the<br />  CheckTx flow.<br />A best effort placed order may not have been placed on other dYdX<br />nodes including other dYdX validator nodes and may still be excluded in<br />future order matches.<br /> - ORDER_PLACEMENT_STATUS_OPENED: An opened order is one that is confirmed to be placed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will be included in any future<br />order matches.<br />This status is used internally by the indexer and will not be sent<br />out by protocol.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|ORDER_PLACEMENT_STATUS_UNSPECIFIED|
|*anonymous*|ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED|
|*anonymous*|ORDER_PLACEMENT_STATUS_OPENED|

## dydxprotocol.indexer.off_chain_updates.OrderRemoveV1

<a id="schemadydxprotocol.indexer.off_chain_updates.orderremovev1"></a>
<a id="schema_dydxprotocol.indexer.off_chain_updates.OrderRemoveV1"></a>
<a id="tocSdydxprotocol.indexer.off_chain_updates.orderremovev1"></a>
<a id="tocsdydxprotocol.indexer.off_chain_updates.orderremovev1"></a>

```json
{
  "removed_order_id": {
    "subaccount_id": {
      "owner": "string",
      "number": 0
    },
    "client_id": 0,
    "order_flags": 0,
    "clob_pair_id": 0
  },
  "reason": "ORDER_REMOVAL_REASON_UNSPECIFIED",
  "removal_status": "ORDER_REMOVAL_STATUS_UNSPECIFIED"
}

```

OrderRemove messages contain the id of the order removed, the reason for the
removal and the resulting status from the removal.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|removed_order_id|object|false|none|IndexerOrderId refers to a single order belonging to a Subaccount.|
|» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|reason|string|false|none|OrderRemovalReason is an enum of all the reasons an order was removed.<br /><br /> - ORDER_REMOVAL_REASON_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_REASON_EXPIRED: The order was removed due to being expired.<br /> - ORDER_REMOVAL_REASON_USER_CANCELED: The order was removed due to being canceled by a user.<br /> - ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED: The order was removed due to being undercollateralized.<br /> - ORDER_REMOVAL_REASON_INTERNAL_ERROR: The order caused an internal error during order placement and was<br />removed.<br /> - ORDER_REMOVAL_REASON_SELF_TRADE_ERROR: The order would have matched against another order placed by the same<br />subaccount and was removed.<br /> - ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER: The order would have matched against maker orders on the orderbook<br />despite being a post-only order and was removed.<br /> - ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK: The order was an ICO order and would have been placed on the orderbook as<br />resting liquidity and was removed.<br /> - ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED: The order was a fill-or-kill order that could not be fully filled and was<br />removed.<br /> - ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE: The order was a reduce-only order that was removed due to either:<br />- being a taker order and fully-filling the order would flip the side of<br />   the subaccount's position, in this case the remaining size of the<br />   order is removed<br />- being a maker order resting on the book and being removed when either<br />   the subaccount's position is closed or flipped sides<br /> - ORDER_REMOVAL_REASON_INDEXER_EXPIRED: The order should be expired, according to the Indexer's cached data, but<br />the Indexer has yet to receive a message to remove the order. In order to<br />keep the data cached by the Indexer up-to-date and accurate, clear out<br />the data if it's expired by sending an order removal with this reason.<br />Protocol should never send this reason to Indexer.<br /> - ORDER_REMOVAL_REASON_REPLACED: The order has been replaced.<br /> - ORDER_REMOVAL_REASON_FULLY_FILLED: The order has been fully-filled. Only sent by the Indexer for stateful<br />orders.<br /> - ORDER_REMOVAL_REASON_EQUITY_TIER: The order has been removed since the subaccount does not satisfy the<br />equity tier requirements.<br /> - ORDER_REMOVAL_REASON_FINAL_SETTLEMENT: The order has been removed since its ClobPair has entered final settlement.|
|removal_status|string|false|none|OrderRemovalStatus is an enum for the resulting status after an order is<br />removed.<br /><br /> - ORDER_REMOVAL_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED: A best effort canceled order is one that has only been confirmed to be<br />removed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- the order was removed due to the dYdX node receiving a CancelOrder<br />  transaction for the order.<br />- the order was removed due to being undercollateralized during<br />  optimistic matching.<br />A best effort canceled order may not have been removed on other dYdX<br />nodes including other dYdX validator nodes and may still be included in<br />future order matches.<br /> - ORDER_REMOVAL_STATUS_CANCELED: A canceled order is one that is confirmed to be removed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will not be included in any future<br />order matches.<br />The cases where this happens includes:<br />- the order is expired.<br /> - ORDER_REMOVAL_STATUS_FILLED: An order was fully-filled. Only sent by the Indexer for stateful orders.|

#### Enumerated Values

|Property|Value|
|---|---|
|reason|ORDER_REMOVAL_REASON_UNSPECIFIED|
|reason|ORDER_REMOVAL_REASON_EXPIRED|
|reason|ORDER_REMOVAL_REASON_USER_CANCELED|
|reason|ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED|
|reason|ORDER_REMOVAL_REASON_INTERNAL_ERROR|
|reason|ORDER_REMOVAL_REASON_SELF_TRADE_ERROR|
|reason|ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER|
|reason|ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK|
|reason|ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED|
|reason|ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE|
|reason|ORDER_REMOVAL_REASON_INDEXER_EXPIRED|
|reason|ORDER_REMOVAL_REASON_REPLACED|
|reason|ORDER_REMOVAL_REASON_FULLY_FILLED|
|reason|ORDER_REMOVAL_REASON_EQUITY_TIER|
|reason|ORDER_REMOVAL_REASON_FINAL_SETTLEMENT|
|removal_status|ORDER_REMOVAL_STATUS_UNSPECIFIED|
|removal_status|ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED|
|removal_status|ORDER_REMOVAL_STATUS_CANCELED|
|removal_status|ORDER_REMOVAL_STATUS_FILLED|

## dydxprotocol.indexer.off_chain_updates.OrderRemoveV1.OrderRemovalStatus

<a id="schemadydxprotocol.indexer.off_chain_updates.orderremovev1.orderremovalstatus"></a>
<a id="schema_dydxprotocol.indexer.off_chain_updates.OrderRemoveV1.OrderRemovalStatus"></a>
<a id="tocSdydxprotocol.indexer.off_chain_updates.orderremovev1.orderremovalstatus"></a>
<a id="tocsdydxprotocol.indexer.off_chain_updates.orderremovev1.orderremovalstatus"></a>

```json
"ORDER_REMOVAL_STATUS_UNSPECIFIED"

```

OrderRemovalStatus is an enum for the resulting status after an order is
removed.

 - ORDER_REMOVAL_STATUS_UNSPECIFIED: Default value, this is invalid and unused.
 - ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED: A best effort canceled order is one that has only been confirmed to be
removed on the dYdX node sending the off-chain update message.
The cases where this happens includes:
- the order was removed due to the dYdX node receiving a CancelOrder
  transaction for the order.
- the order was removed due to being undercollateralized during
  optimistic matching.
A best effort canceled order may not have been removed on other dYdX
nodes including other dYdX validator nodes and may still be included in
future order matches.
 - ORDER_REMOVAL_STATUS_CANCELED: A canceled order is one that is confirmed to be removed on all dYdX nodes
(discounting dishonest dYdX nodes) and will not be included in any future
order matches.
The cases where this happens includes:
- the order is expired.
 - ORDER_REMOVAL_STATUS_FILLED: An order was fully-filled. Only sent by the Indexer for stateful orders.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|OrderRemovalStatus is an enum for the resulting status after an order is<br />removed.<br /><br /> - ORDER_REMOVAL_STATUS_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED: A best effort canceled order is one that has only been confirmed to be<br />removed on the dYdX node sending the off-chain update message.<br />The cases where this happens includes:<br />- the order was removed due to the dYdX node receiving a CancelOrder<br />  transaction for the order.<br />- the order was removed due to being undercollateralized during<br />  optimistic matching.<br />A best effort canceled order may not have been removed on other dYdX<br />nodes including other dYdX validator nodes and may still be included in<br />future order matches.<br /> - ORDER_REMOVAL_STATUS_CANCELED: A canceled order is one that is confirmed to be removed on all dYdX nodes<br />(discounting dishonest dYdX nodes) and will not be included in any future<br />order matches.<br />The cases where this happens includes:<br />- the order is expired.<br /> - ORDER_REMOVAL_STATUS_FILLED: An order was fully-filled. Only sent by the Indexer for stateful orders.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|ORDER_REMOVAL_STATUS_UNSPECIFIED|
|*anonymous*|ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED|
|*anonymous*|ORDER_REMOVAL_STATUS_CANCELED|
|*anonymous*|ORDER_REMOVAL_STATUS_FILLED|

## dydxprotocol.indexer.off_chain_updates.OrderUpdateV1

<a id="schemadydxprotocol.indexer.off_chain_updates.orderupdatev1"></a>
<a id="schema_dydxprotocol.indexer.off_chain_updates.OrderUpdateV1"></a>
<a id="tocSdydxprotocol.indexer.off_chain_updates.orderupdatev1"></a>
<a id="tocsdydxprotocol.indexer.off_chain_updates.orderupdatev1"></a>

```json
{
  "order_id": {
    "subaccount_id": {
      "owner": "string",
      "number": 0
    },
    "client_id": 0,
    "order_flags": 0,
    "clob_pair_id": 0
  },
  "total_filled_quantums": "string"
}

```

OrderUpdate messages contain the id of the order being updated, and the
updated total filled quantums of the order.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|order_id|object|false|none|IndexerOrderId refers to a single order belonging to a Subaccount.|
|» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|total_filled_quantums|string(uint64)|false|none|none|

## dydxprotocol.indexer.protocol.v1.IndexerOrder

<a id="schemadydxprotocol.indexer.protocol.v1.indexerorder"></a>
<a id="schema_dydxprotocol.indexer.protocol.v1.IndexerOrder"></a>
<a id="tocSdydxprotocol.indexer.protocol.v1.indexerorder"></a>
<a id="tocsdydxprotocol.indexer.protocol.v1.indexerorder"></a>

```json
{
  "order_id": {
    "subaccount_id": {
      "owner": "string",
      "number": 0
    },
    "client_id": 0,
    "order_flags": 0,
    "clob_pair_id": 0
  },
  "side": "SIDE_UNSPECIFIED",
  "quantums": "string",
  "subticks": "string",
  "good_til_block": 0,
  "good_til_block_time": 0,
  "time_in_force": "TIME_IN_FORCE_UNSPECIFIED",
  "reduce_only": true,
  "client_metadata": 0,
  "condition_type": "CONDITION_TYPE_UNSPECIFIED",
  "conditional_order_trigger_subticks": "string"
}

```

IndexerOrderV1 represents a single order belonging to a `Subaccount`
for a particular `ClobPair`.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|order_id|object|false|none|The unique ID of this order. Meant to be unique across all orders.|
|» subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|» client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|» order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|» clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|
|side|string|false|none|Represents the side of the orderbook the order will be placed on.<br />Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be<br />placed on the orderbook.<br /><br /> - SIDE_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - SIDE_BUY: SIDE_BUY is used to represent a BUY order.<br /> - SIDE_SELL: SIDE_SELL is used to represent a SELL order.|
|quantums|string(uint64)|false|none|The size of this order in base quantums. Must be a multiple of<br />`ClobPair.StepBaseQuantums` (where `ClobPair.Id = orderId.ClobPairId`).|
|subticks|string(uint64)|false|none|The price level that this order will be placed at on the orderbook,<br />in subticks. Must be a multiple of ClobPair.SubticksPerTick<br />(where `ClobPair.Id = orderId.ClobPairId`).|
|good_til_block|integer(int64)|false|none|The last block this order can be executed at (after which it will be<br />unfillable). Used only for Short-Term orders. If this value is non-zero<br />then the order is assumed to be a Short-Term order.|
|good_til_block_time|integer(int64)|false|none|good_til_block_time represents the unix timestamp (in seconds) at which a<br />stateful order will be considered expired. The<br />good_til_block_time is always evaluated against the previous block's<br />`BlockTime` instead of the block in which the order is committed. If this<br />value is non-zero then the order is assumed to be a stateful or<br />conditional order.|
|time_in_force|string|false|none|The time in force of this order.|
|reduce_only|boolean|false|none|Enforces that the order can only reduce the size of an existing position.<br />If a ReduceOnly order would change the side of the existing position,<br />its size is reduced to that of the remaining size of the position.<br />If existing orders on the book with ReduceOnly<br />would already close the position, the least aggressive (out-of-the-money)<br />ReduceOnly orders are resized and canceled first.|
|client_metadata|integer(int64)|false|none|Set of bit flags set arbitrarily by clients and ignored by the protocol.<br />Used by indexer to infer information about a placed order.|
|condition_type|string|false|none|- CONDITION_TYPE_UNSPECIFIED: CONDITION_TYPE_UNSPECIFIED represents the default behavior where an<br />order will be placed immediately on the orderbook.<br /> - CONDITION_TYPE_STOP_LOSS: CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will<br />trigger when the oracle price moves at or above the trigger price for<br />buys, and at or below the trigger price for sells.<br /> - CONDITION_TYPE_TAKE_PROFIT: CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit<br />order will trigger when the oracle price moves at or below the trigger<br />price for buys and at or above the trigger price for sells.|
|conditional_order_trigger_subticks|string(uint64)|false|none|conditional_order_trigger_subticks represents the price at which this order<br />will be triggered. If the condition_type is CONDITION_TYPE_UNSPECIFIED,<br />this value is enforced to be 0. If this value is nonzero, condition_type<br />cannot be CONDITION_TYPE_UNSPECIFIED. Value is in subticks.<br />Must be a multiple of ClobPair.SubticksPerTick (where `ClobPair.Id =<br />orderId.ClobPairId`).|

#### Enumerated Values

|Property|Value|
|---|---|
|side|SIDE_UNSPECIFIED|
|side|SIDE_BUY|
|side|SIDE_SELL|
|time_in_force|TIME_IN_FORCE_UNSPECIFIED|
|time_in_force|TIME_IN_FORCE_IOC|
|time_in_force|TIME_IN_FORCE_POST_ONLY|
|time_in_force|TIME_IN_FORCE_FILL_OR_KILL|
|condition_type|CONDITION_TYPE_UNSPECIFIED|
|condition_type|CONDITION_TYPE_STOP_LOSS|
|condition_type|CONDITION_TYPE_TAKE_PROFIT|

## dydxprotocol.indexer.protocol.v1.IndexerOrder.ConditionType

<a id="schemadydxprotocol.indexer.protocol.v1.indexerorder.conditiontype"></a>
<a id="schema_dydxprotocol.indexer.protocol.v1.IndexerOrder.ConditionType"></a>
<a id="tocSdydxprotocol.indexer.protocol.v1.indexerorder.conditiontype"></a>
<a id="tocsdydxprotocol.indexer.protocol.v1.indexerorder.conditiontype"></a>

```json
"CONDITION_TYPE_UNSPECIFIED"

```

 - CONDITION_TYPE_UNSPECIFIED: CONDITION_TYPE_UNSPECIFIED represents the default behavior where an
order will be placed immediately on the orderbook.
 - CONDITION_TYPE_STOP_LOSS: CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will
trigger when the oracle price moves at or above the trigger price for
buys, and at or below the trigger price for sells.
 - CONDITION_TYPE_TAKE_PROFIT: CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit
order will trigger when the oracle price moves at or below the trigger
price for buys and at or above the trigger price for sells.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|- CONDITION_TYPE_UNSPECIFIED: CONDITION_TYPE_UNSPECIFIED represents the default behavior where an<br />order will be placed immediately on the orderbook.<br /> - CONDITION_TYPE_STOP_LOSS: CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will<br />trigger when the oracle price moves at or above the trigger price for<br />buys, and at or below the trigger price for sells.<br /> - CONDITION_TYPE_TAKE_PROFIT: CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit<br />order will trigger when the oracle price moves at or below the trigger<br />price for buys and at or above the trigger price for sells.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|CONDITION_TYPE_UNSPECIFIED|
|*anonymous*|CONDITION_TYPE_STOP_LOSS|
|*anonymous*|CONDITION_TYPE_TAKE_PROFIT|

## dydxprotocol.indexer.protocol.v1.IndexerOrder.Side

<a id="schemadydxprotocol.indexer.protocol.v1.indexerorder.side"></a>
<a id="schema_dydxprotocol.indexer.protocol.v1.IndexerOrder.Side"></a>
<a id="tocSdydxprotocol.indexer.protocol.v1.indexerorder.side"></a>
<a id="tocsdydxprotocol.indexer.protocol.v1.indexerorder.side"></a>

```json
"SIDE_UNSPECIFIED"

```

Represents the side of the orderbook the order will be placed on.
Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be
placed on the orderbook.

 - SIDE_UNSPECIFIED: Default value. This value is invalid and unused.
 - SIDE_BUY: SIDE_BUY is used to represent a BUY order.
 - SIDE_SELL: SIDE_SELL is used to represent a SELL order.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|Represents the side of the orderbook the order will be placed on.<br />Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be<br />placed on the orderbook.<br /><br /> - SIDE_UNSPECIFIED: Default value. This value is invalid and unused.<br /> - SIDE_BUY: SIDE_BUY is used to represent a BUY order.<br /> - SIDE_SELL: SIDE_SELL is used to represent a SELL order.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|SIDE_UNSPECIFIED|
|*anonymous*|SIDE_BUY|
|*anonymous*|SIDE_SELL|

## dydxprotocol.indexer.protocol.v1.IndexerOrder.TimeInForce

<a id="schemadydxprotocol.indexer.protocol.v1.indexerorder.timeinforce"></a>
<a id="schema_dydxprotocol.indexer.protocol.v1.IndexerOrder.TimeInForce"></a>
<a id="tocSdydxprotocol.indexer.protocol.v1.indexerorder.timeinforce"></a>
<a id="tocsdydxprotocol.indexer.protocol.v1.indexerorder.timeinforce"></a>

```json
"TIME_IN_FORCE_UNSPECIFIED"

```

TimeInForce indicates how long an order will remain active before it
is executed or expires.

 - TIME_IN_FORCE_UNSPECIFIED: TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an
order will first match with existing orders on the book, and any
remaining size will be added to the book as a maker order.
 - TIME_IN_FORCE_IOC: TIME_IN_FORCE_IOC enforces that an order only be matched with
maker orders on the book. If the order has remaining size after
matching with existing orders on the book, the remaining size
is not placed on the book.
 - TIME_IN_FORCE_POST_ONLY: TIME_IN_FORCE_POST_ONLY enforces that an order only be placed
on the book as a maker order. Note this means that validators will cancel
any newly-placed post only orders that would cross with other maker
orders.
 - TIME_IN_FORCE_FILL_OR_KILL: TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled
completely and immediately by maker orders on the book or canceled if the
entire amount can‘t be matched.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|TimeInForce indicates how long an order will remain active before it<br />is executed or expires.<br /><br /> - TIME_IN_FORCE_UNSPECIFIED: TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an<br />order will first match with existing orders on the book, and any<br />remaining size will be added to the book as a maker order.<br /> - TIME_IN_FORCE_IOC: TIME_IN_FORCE_IOC enforces that an order only be matched with<br />maker orders on the book. If the order has remaining size after<br />matching with existing orders on the book, the remaining size<br />is not placed on the book.<br /> - TIME_IN_FORCE_POST_ONLY: TIME_IN_FORCE_POST_ONLY enforces that an order only be placed<br />on the book as a maker order. Note this means that validators will cancel<br />any newly-placed post only orders that would cross with other maker<br />orders.<br /> - TIME_IN_FORCE_FILL_OR_KILL: TIME_IN_FORCE_FILL_OR_KILL enforces that an order will either be filled<br />completely and immediately by maker orders on the book or canceled if the<br />entire amount can‘t be matched.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|TIME_IN_FORCE_UNSPECIFIED|
|*anonymous*|TIME_IN_FORCE_IOC|
|*anonymous*|TIME_IN_FORCE_POST_ONLY|
|*anonymous*|TIME_IN_FORCE_FILL_OR_KILL|

## dydxprotocol.indexer.protocol.v1.IndexerOrderId

<a id="schemadydxprotocol.indexer.protocol.v1.indexerorderid"></a>
<a id="schema_dydxprotocol.indexer.protocol.v1.IndexerOrderId"></a>
<a id="tocSdydxprotocol.indexer.protocol.v1.indexerorderid"></a>
<a id="tocsdydxprotocol.indexer.protocol.v1.indexerorderid"></a>

```json
{
  "subaccount_id": {
    "owner": "string",
    "number": 0
  },
  "client_id": 0,
  "order_flags": 0,
  "clob_pair_id": 0
}

```

IndexerOrderId refers to a single order belonging to a Subaccount.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|subaccount_id|object|false|none|The subaccount ID that opened this order.<br />Note that this field has `gogoproto.nullable = false` so that it is<br />generated as a value instead of a pointer. This is because the `OrderId`<br />proto is used as a key within maps, and map comparisons will compare<br />pointers for equality (when the desired behavior is to compare the values).|
|» owner|string|false|none|The address of the wallet that owns this subaccount.|
|» number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|
|client_id|integer(int64)|false|none|The client ID of this order, unique with respect to the specific<br />sub account (I.E., the same subaccount can't have two orders with<br />the same ClientId).|
|order_flags|integer(int64)|false|none|order_flags represent order flags for the order. This field is invalid if<br />it's greater than 127 (larger than one byte). Each bit in the first byte<br />represents a different flag. Currently only two flags are supported.<br /><br />Starting from the bit after the most MSB (note that the MSB is used in<br />proto varint encoding, and therefore cannot be used): Bit 1 is set if this<br />order is a Long-Term order (0x40, or 64 as a uint8). Bit 2 is set if this<br />order is a Conditional order (0x20, or 32 as a uint8).<br /><br />If neither bit is set, the order is assumed to be a Short-Term order.<br /><br />If both bits are set or bits other than the 2nd and 3rd are set, the order<br />ID is invalid.|
|clob_pair_id|integer(int64)|false|none|ID of the CLOB the order is created for.|

## dydxprotocol.indexer.protocol.v1.IndexerSubaccountId

<a id="schemadydxprotocol.indexer.protocol.v1.indexersubaccountid"></a>
<a id="schema_dydxprotocol.indexer.protocol.v1.IndexerSubaccountId"></a>
<a id="tocSdydxprotocol.indexer.protocol.v1.indexersubaccountid"></a>
<a id="tocsdydxprotocol.indexer.protocol.v1.indexersubaccountid"></a>

```json
{
  "owner": "string",
  "number": 0
}

```

IndexerSubaccountId defines a unique identifier for a Subaccount.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|owner|string|false|none|The address of the wallet that owns this subaccount.|
|number|integer(int64)|false|none|< 128 Since 128 should be enough to start and it fits within<br />1 Byte (1 Bit needed to indicate that the first byte is the last).|

## dydxprotocol.indexer.shared.OrderRemovalReason

<a id="schemadydxprotocol.indexer.shared.orderremovalreason"></a>
<a id="schema_dydxprotocol.indexer.shared.OrderRemovalReason"></a>
<a id="tocSdydxprotocol.indexer.shared.orderremovalreason"></a>
<a id="tocsdydxprotocol.indexer.shared.orderremovalreason"></a>

```json
"ORDER_REMOVAL_REASON_UNSPECIFIED"

```

OrderRemovalReason is an enum of all the reasons an order was removed.

 - ORDER_REMOVAL_REASON_UNSPECIFIED: Default value, this is invalid and unused.
 - ORDER_REMOVAL_REASON_EXPIRED: The order was removed due to being expired.
 - ORDER_REMOVAL_REASON_USER_CANCELED: The order was removed due to being canceled by a user.
 - ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED: The order was removed due to being undercollateralized.
 - ORDER_REMOVAL_REASON_INTERNAL_ERROR: The order caused an internal error during order placement and was
removed.
 - ORDER_REMOVAL_REASON_SELF_TRADE_ERROR: The order would have matched against another order placed by the same
subaccount and was removed.
 - ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER: The order would have matched against maker orders on the orderbook
despite being a post-only order and was removed.
 - ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK: The order was an ICO order and would have been placed on the orderbook as
resting liquidity and was removed.
 - ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED: The order was a fill-or-kill order that could not be fully filled and was
removed.
 - ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE: The order was a reduce-only order that was removed due to either:
- being a taker order and fully-filling the order would flip the side of
   the subaccount's position, in this case the remaining size of the
   order is removed
- being a maker order resting on the book and being removed when either
   the subaccount's position is closed or flipped sides
 - ORDER_REMOVAL_REASON_INDEXER_EXPIRED: The order should be expired, according to the Indexer's cached data, but
the Indexer has yet to receive a message to remove the order. In order to
keep the data cached by the Indexer up-to-date and accurate, clear out
the data if it's expired by sending an order removal with this reason.
Protocol should never send this reason to Indexer.
 - ORDER_REMOVAL_REASON_REPLACED: The order has been replaced.
 - ORDER_REMOVAL_REASON_FULLY_FILLED: The order has been fully-filled. Only sent by the Indexer for stateful
orders.
 - ORDER_REMOVAL_REASON_EQUITY_TIER: The order has been removed since the subaccount does not satisfy the
equity tier requirements.
 - ORDER_REMOVAL_REASON_FINAL_SETTLEMENT: The order has been removed since its ClobPair has entered final settlement.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|OrderRemovalReason is an enum of all the reasons an order was removed.<br /><br /> - ORDER_REMOVAL_REASON_UNSPECIFIED: Default value, this is invalid and unused.<br /> - ORDER_REMOVAL_REASON_EXPIRED: The order was removed due to being expired.<br /> - ORDER_REMOVAL_REASON_USER_CANCELED: The order was removed due to being canceled by a user.<br /> - ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED: The order was removed due to being undercollateralized.<br /> - ORDER_REMOVAL_REASON_INTERNAL_ERROR: The order caused an internal error during order placement and was<br />removed.<br /> - ORDER_REMOVAL_REASON_SELF_TRADE_ERROR: The order would have matched against another order placed by the same<br />subaccount and was removed.<br /> - ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER: The order would have matched against maker orders on the orderbook<br />despite being a post-only order and was removed.<br /> - ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK: The order was an ICO order and would have been placed on the orderbook as<br />resting liquidity and was removed.<br /> - ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED: The order was a fill-or-kill order that could not be fully filled and was<br />removed.<br /> - ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE: The order was a reduce-only order that was removed due to either:<br />- being a taker order and fully-filling the order would flip the side of<br />   the subaccount's position, in this case the remaining size of the<br />   order is removed<br />- being a maker order resting on the book and being removed when either<br />   the subaccount's position is closed or flipped sides<br /> - ORDER_REMOVAL_REASON_INDEXER_EXPIRED: The order should be expired, according to the Indexer's cached data, but<br />the Indexer has yet to receive a message to remove the order. In order to<br />keep the data cached by the Indexer up-to-date and accurate, clear out<br />the data if it's expired by sending an order removal with this reason.<br />Protocol should never send this reason to Indexer.<br /> - ORDER_REMOVAL_REASON_REPLACED: The order has been replaced.<br /> - ORDER_REMOVAL_REASON_FULLY_FILLED: The order has been fully-filled. Only sent by the Indexer for stateful<br />orders.<br /> - ORDER_REMOVAL_REASON_EQUITY_TIER: The order has been removed since the subaccount does not satisfy the<br />equity tier requirements.<br /> - ORDER_REMOVAL_REASON_FINAL_SETTLEMENT: The order has been removed since its ClobPair has entered final settlement.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|ORDER_REMOVAL_REASON_UNSPECIFIED|
|*anonymous*|ORDER_REMOVAL_REASON_EXPIRED|
|*anonymous*|ORDER_REMOVAL_REASON_USER_CANCELED|
|*anonymous*|ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED|
|*anonymous*|ORDER_REMOVAL_REASON_INTERNAL_ERROR|
|*anonymous*|ORDER_REMOVAL_REASON_SELF_TRADE_ERROR|
|*anonymous*|ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER|
|*anonymous*|ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK|
|*anonymous*|ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED|
|*anonymous*|ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE|
|*anonymous*|ORDER_REMOVAL_REASON_INDEXER_EXPIRED|
|*anonymous*|ORDER_REMOVAL_REASON_REPLACED|
|*anonymous*|ORDER_REMOVAL_REASON_FULLY_FILLED|
|*anonymous*|ORDER_REMOVAL_REASON_EQUITY_TIER|
|*anonymous*|ORDER_REMOVAL_REASON_FINAL_SETTLEMENT|

## dydxprotocol.subaccounts.SubaccountId

<a id="schemadydxprotocol.subaccounts.subaccountid"></a>
<a id="schema_dydxprotocol.subaccounts.SubaccountId"></a>
<a id="tocSdydxprotocol.subaccounts.subaccountid"></a>
<a id="tocsdydxprotocol.subaccounts.subaccountid"></a>

```json
{
  "owner": "string",
  "number": 0
}

```

SubaccountId defines a unique identifier for a Subaccount.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|owner|string|false|none|The address of the wallet that owns this subaccount.|
|number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|

## grpc.gateway.runtime.StreamError

<a id="schemagrpc.gateway.runtime.streamerror"></a>
<a id="schema_grpc.gateway.runtime.StreamError"></a>
<a id="tocSgrpc.gateway.runtime.streamerror"></a>
<a id="tocsgrpc.gateway.runtime.streamerror"></a>

```json
{
  "grpc_code": 0,
  "http_code": 0,
  "message": "string",
  "http_status": "string",
  "details": [
    {
      "type_url": "string",
      "value": "string"
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|grpc_code|integer(int32)|false|none|none|
|http_code|integer(int32)|false|none|none|
|message|string|false|none|none|
|http_status|string|false|none|none|
|details|[object]|false|none|none|
|» type_url|string|false|none|none|
|» value|string(byte)|false|none|none|

## dydxprotocol.delaymsg.DelayedMessage

<a id="schemadydxprotocol.delaymsg.delayedmessage"></a>
<a id="schema_dydxprotocol.delaymsg.DelayedMessage"></a>
<a id="tocSdydxprotocol.delaymsg.delayedmessage"></a>
<a id="tocsdydxprotocol.delaymsg.delayedmessage"></a>

```json
{
  "id": 0,
  "msg": {
    "type_url": "string",
    "value": "string"
  },
  "block_height": 0
}

```

DelayedMessage is a message that is delayed until a certain block height.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|The ID of the delayed message.|
|msg|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|block_height|integer(int64)|false|none|The block height at which the message should be executed.|

## dydxprotocol.delaymsg.QueryBlockMessageIdsResponse

<a id="schemadydxprotocol.delaymsg.queryblockmessageidsresponse"></a>
<a id="schema_dydxprotocol.delaymsg.QueryBlockMessageIdsResponse"></a>
<a id="tocSdydxprotocol.delaymsg.queryblockmessageidsresponse"></a>
<a id="tocsdydxprotocol.delaymsg.queryblockmessageidsresponse"></a>

```json
{
  "message_ids": [
    0
  ]
}

```

QueryGetBlockMessageIdsResponse is the response type for the BlockMessageIds
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|message_ids|[integer]|false|none|none|

## dydxprotocol.delaymsg.QueryMessageResponse

<a id="schemadydxprotocol.delaymsg.querymessageresponse"></a>
<a id="schema_dydxprotocol.delaymsg.QueryMessageResponse"></a>
<a id="tocSdydxprotocol.delaymsg.querymessageresponse"></a>
<a id="tocsdydxprotocol.delaymsg.querymessageresponse"></a>

```json
{
  "message": {
    "id": 0,
    "msg": {
      "type_url": "string",
      "value": "string"
    },
    "block_height": 0
  }
}

```

QueryGetMessageResponse is the response type for the Message RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|message|object|false|none|DelayedMessage is a message that is delayed until a certain block height.|
|» id|integer(int64)|false|none|The ID of the delayed message.|
|» msg|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» block_height|integer(int64)|false|none|The block height at which the message should be executed.|

## dydxprotocol.delaymsg.QueryNextDelayedMessageIdResponse

<a id="schemadydxprotocol.delaymsg.querynextdelayedmessageidresponse"></a>
<a id="schema_dydxprotocol.delaymsg.QueryNextDelayedMessageIdResponse"></a>
<a id="tocSdydxprotocol.delaymsg.querynextdelayedmessageidresponse"></a>
<a id="tocsdydxprotocol.delaymsg.querynextdelayedmessageidresponse"></a>

```json
{
  "next_delayed_message_id": 0
}

```

QueryNextDelayedMessageIdResponse is the response type for the
NextDelayedMessageId RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|next_delayed_message_id|integer(int64)|false|none|none|

## dydxprotocol.epochs.EpochInfo

<a id="schemadydxprotocol.epochs.epochinfo"></a>
<a id="schema_dydxprotocol.epochs.EpochInfo"></a>
<a id="tocSdydxprotocol.epochs.epochinfo"></a>
<a id="tocsdydxprotocol.epochs.epochinfo"></a>

```json
{
  "name": "string",
  "next_tick": 0,
  "duration": 0,
  "current_epoch": 0,
  "current_epoch_start_block": 0,
  "is_initialized": true,
  "fast_forward_next_tick": true
}

```

EpochInfo stores metadata of an epoch timer.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|false|none|name is the unique identifier.|
|next_tick|integer(int64)|false|none|next_tick indicates when the next epoch starts (in Unix Epoch seconds),<br />if `EpochInfo` has been initialized.<br />If `EpochInfo` is not initialized yet, `next_tick` indicates the earliest<br />initialization time (see `is_initialized` below).|
|duration|integer(int64)|false|none|duration of the epoch in seconds.|
|current_epoch|integer(int64)|false|none|current epoch is the number of the current epoch.<br />0 if `next_tick` has never been reached, positive otherwise.|
|current_epoch_start_block|integer(int64)|false|none|current_epoch_start_block indicates the block height when the current<br />epoch started. 0 if `current_epoch` is 0.|
|is_initialized|boolean|false|none|none|
|fast_forward_next_tick|boolean|false|none|fast_forward_next_tick specifies whether during initialization, `next_tick`<br />should be fast-forwarded to be greater than the current block time.<br />If `false`, the original `next_tick` value is<br />unchanged during initialization.<br />If `true`, `next_tick` will be set to the smallest value `x` greater than<br />the current block time such that `(x - next_tick) % duration = 0`.|

## dydxprotocol.epochs.QueryEpochInfoAllResponse

<a id="schemadydxprotocol.epochs.queryepochinfoallresponse"></a>
<a id="schema_dydxprotocol.epochs.QueryEpochInfoAllResponse"></a>
<a id="tocSdydxprotocol.epochs.queryepochinfoallresponse"></a>
<a id="tocsdydxprotocol.epochs.queryepochinfoallresponse"></a>

```json
{
  "epoch_info": [
    {
      "name": "string",
      "next_tick": 0,
      "duration": 0,
      "current_epoch": 0,
      "current_epoch_start_block": 0,
      "is_initialized": true,
      "fast_forward_next_tick": true
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryEpochInfoAllResponse is response type for the AllEpochInfo RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|epoch_info|[object]|false|none|none|
|» name|string|false|none|name is the unique identifier.|
|» next_tick|integer(int64)|false|none|next_tick indicates when the next epoch starts (in Unix Epoch seconds),<br />if `EpochInfo` has been initialized.<br />If `EpochInfo` is not initialized yet, `next_tick` indicates the earliest<br />initialization time (see `is_initialized` below).|
|» duration|integer(int64)|false|none|duration of the epoch in seconds.|
|» current_epoch|integer(int64)|false|none|current epoch is the number of the current epoch.<br />0 if `next_tick` has never been reached, positive otherwise.|
|» current_epoch_start_block|integer(int64)|false|none|current_epoch_start_block indicates the block height when the current<br />epoch started. 0 if `current_epoch` is 0.|
|» is_initialized|boolean|false|none|none|
|» fast_forward_next_tick|boolean|false|none|fast_forward_next_tick specifies whether during initialization, `next_tick`<br />should be fast-forwarded to be greater than the current block time.<br />If `false`, the original `next_tick` value is<br />unchanged during initialization.<br />If `true`, `next_tick` will be set to the smallest value `x` greater than<br />the current block time such that `(x - next_tick) % duration = 0`.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## dydxprotocol.epochs.QueryEpochInfoResponse

<a id="schemadydxprotocol.epochs.queryepochinforesponse"></a>
<a id="schema_dydxprotocol.epochs.QueryEpochInfoResponse"></a>
<a id="tocSdydxprotocol.epochs.queryepochinforesponse"></a>
<a id="tocsdydxprotocol.epochs.queryepochinforesponse"></a>

```json
{
  "epoch_info": {
    "name": "string",
    "next_tick": 0,
    "duration": 0,
    "current_epoch": 0,
    "current_epoch_start_block": 0,
    "is_initialized": true,
    "fast_forward_next_tick": true
  }
}

```

QueryEpochInfoResponse is response type for the GetEpochInfo RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|epoch_info|object|false|none|EpochInfo stores metadata of an epoch timer.|
|» name|string|false|none|name is the unique identifier.|
|» next_tick|integer(int64)|false|none|next_tick indicates when the next epoch starts (in Unix Epoch seconds),<br />if `EpochInfo` has been initialized.<br />If `EpochInfo` is not initialized yet, `next_tick` indicates the earliest<br />initialization time (see `is_initialized` below).|
|» duration|integer(int64)|false|none|duration of the epoch in seconds.|
|» current_epoch|integer(int64)|false|none|current epoch is the number of the current epoch.<br />0 if `next_tick` has never been reached, positive otherwise.|
|» current_epoch_start_block|integer(int64)|false|none|current_epoch_start_block indicates the block height when the current<br />epoch started. 0 if `current_epoch` is 0.|
|» is_initialized|boolean|false|none|none|
|» fast_forward_next_tick|boolean|false|none|fast_forward_next_tick specifies whether during initialization, `next_tick`<br />should be fast-forwarded to be greater than the current block time.<br />If `false`, the original `next_tick` value is<br />unchanged during initialization.<br />If `true`, `next_tick` will be set to the smallest value `x` greater than<br />the current block time such that `(x - next_tick) % duration = 0`.|

## dydxprotocol.feetiers.PerpetualFeeParams

<a id="schemadydxprotocol.feetiers.perpetualfeeparams"></a>
<a id="schema_dydxprotocol.feetiers.PerpetualFeeParams"></a>
<a id="tocSdydxprotocol.feetiers.perpetualfeeparams"></a>
<a id="tocsdydxprotocol.feetiers.perpetualfeeparams"></a>

```json
{
  "tiers": [
    {
      "name": "string",
      "absolute_volume_requirement": "string",
      "total_volume_share_requirement_ppm": 0,
      "maker_volume_share_requirement_ppm": 0,
      "maker_fee_ppm": 0,
      "taker_fee_ppm": 0
    }
  ]
}

```

PerpetualFeeParams defines the parameters for perpetual fees.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tiers|[object]|false|none|Sorted fee tiers (lowest requirements first).|
|» A fee tier for perpetuals|object|false|none|none|
|»» name|string|false|none|Human-readable name of the tier, e.g. "Gold".|
|»» absolute_volume_requirement|string(uint64)|false|none|The trader's absolute volume requirement in quote quantums.|
|»» total_volume_share_requirement_ppm|integer(int64)|false|none|The total volume share requirement.|
|»» maker_volume_share_requirement_ppm|integer(int64)|false|none|The maker volume share requirement.|
|»» maker_fee_ppm|integer(int32)|false|none|The maker fee once this tier is reached.|
|»» taker_fee_ppm|integer(int32)|false|none|The taker fee once this tier is reached.|

## dydxprotocol.feetiers.PerpetualFeeTier

<a id="schemadydxprotocol.feetiers.perpetualfeetier"></a>
<a id="schema_dydxprotocol.feetiers.PerpetualFeeTier"></a>
<a id="tocSdydxprotocol.feetiers.perpetualfeetier"></a>
<a id="tocsdydxprotocol.feetiers.perpetualfeetier"></a>

```json
{
  "name": "string",
  "absolute_volume_requirement": "string",
  "total_volume_share_requirement_ppm": 0,
  "maker_volume_share_requirement_ppm": 0,
  "maker_fee_ppm": 0,
  "taker_fee_ppm": 0
}

```

A fee tier for perpetuals

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|false|none|Human-readable name of the tier, e.g. "Gold".|
|absolute_volume_requirement|string(uint64)|false|none|The trader's absolute volume requirement in quote quantums.|
|total_volume_share_requirement_ppm|integer(int64)|false|none|The total volume share requirement.|
|maker_volume_share_requirement_ppm|integer(int64)|false|none|The maker volume share requirement.|
|maker_fee_ppm|integer(int32)|false|none|The maker fee once this tier is reached.|
|taker_fee_ppm|integer(int32)|false|none|The taker fee once this tier is reached.|

## dydxprotocol.feetiers.QueryPerpetualFeeParamsResponse

<a id="schemadydxprotocol.feetiers.queryperpetualfeeparamsresponse"></a>
<a id="schema_dydxprotocol.feetiers.QueryPerpetualFeeParamsResponse"></a>
<a id="tocSdydxprotocol.feetiers.queryperpetualfeeparamsresponse"></a>
<a id="tocsdydxprotocol.feetiers.queryperpetualfeeparamsresponse"></a>

```json
{
  "params": {
    "tiers": [
      {
        "name": "string",
        "absolute_volume_requirement": "string",
        "total_volume_share_requirement_ppm": 0,
        "maker_volume_share_requirement_ppm": 0,
        "maker_fee_ppm": 0,
        "taker_fee_ppm": 0
      }
    ]
  }
}

```

QueryPerpetualFeeParamsResponse is a response type for the PerpetualFeeParams
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|PerpetualFeeParams defines the parameters for perpetual fees.|
|» tiers|[object]|false|none|Sorted fee tiers (lowest requirements first).|
|»» A fee tier for perpetuals|object|false|none|none|
|»»» name|string|false|none|Human-readable name of the tier, e.g. "Gold".|
|»»» absolute_volume_requirement|string(uint64)|false|none|The trader's absolute volume requirement in quote quantums.|
|»»» total_volume_share_requirement_ppm|integer(int64)|false|none|The total volume share requirement.|
|»»» maker_volume_share_requirement_ppm|integer(int64)|false|none|The maker volume share requirement.|
|»»» maker_fee_ppm|integer(int32)|false|none|The maker fee once this tier is reached.|
|»»» taker_fee_ppm|integer(int32)|false|none|The taker fee once this tier is reached.|

## dydxprotocol.feetiers.QueryUserFeeTierResponse

<a id="schemadydxprotocol.feetiers.queryuserfeetierresponse"></a>
<a id="schema_dydxprotocol.feetiers.QueryUserFeeTierResponse"></a>
<a id="tocSdydxprotocol.feetiers.queryuserfeetierresponse"></a>
<a id="tocsdydxprotocol.feetiers.queryuserfeetierresponse"></a>

```json
{
  "index": 0,
  "tier": {
    "name": "string",
    "absolute_volume_requirement": "string",
    "total_volume_share_requirement_ppm": 0,
    "maker_volume_share_requirement_ppm": 0,
    "maker_fee_ppm": 0,
    "taker_fee_ppm": 0
  }
}

```

QueryUserFeeTierResponse is a request type for the UserFeeTier RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|index|integer(int64)|false|none|Index of the fee tier in the list queried from PerpetualFeeParams.|
|tier|object|false|none|none|
|» name|string|false|none|Human-readable name of the tier, e.g. "Gold".|
|» absolute_volume_requirement|string(uint64)|false|none|The trader's absolute volume requirement in quote quantums.|
|» total_volume_share_requirement_ppm|integer(int64)|false|none|The total volume share requirement.|
|» maker_volume_share_requirement_ppm|integer(int64)|false|none|The maker volume share requirement.|
|» maker_fee_ppm|integer(int32)|false|none|The maker fee once this tier is reached.|
|» taker_fee_ppm|integer(int32)|false|none|The taker fee once this tier is reached.|

## dydxprotocol.perpetuals.LiquidityTier

<a id="schemadydxprotocol.perpetuals.liquiditytier"></a>
<a id="schema_dydxprotocol.perpetuals.LiquidityTier"></a>
<a id="tocSdydxprotocol.perpetuals.liquiditytier"></a>
<a id="tocsdydxprotocol.perpetuals.liquiditytier"></a>

```json
{
  "id": 0,
  "name": "string",
  "initial_margin_ppm": 0,
  "maintenance_fraction_ppm": 0,
  "base_position_notional": "string",
  "impact_notional": "string",
  "open_interest_lower_cap": "string",
  "open_interest_upper_cap": "string"
}

```

LiquidityTier stores margin information.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|Unique id.|
|name|string|false|none|The name of the tier purely for mnemonic purposes, e.g. "Gold".|
|initial_margin_ppm|integer(int64)|false|none|The margin fraction needed to open a position.<br />In parts-per-million.|
|maintenance_fraction_ppm|integer(int64)|false|none|The fraction of the initial-margin that the maintenance-margin is,<br />e.g. 50%. In parts-per-million.|
|base_position_notional|string(uint64)|false|none|The maximum position size at which the margin requirements are<br />not increased over the default values. Above this position size,<br />the margin requirements increase at a rate of sqrt(size).<br /><br />Deprecated since v3.x.|
|impact_notional|string(uint64)|false|none|The impact notional amount (in quote quantums) is used to determine impact<br />bid/ask prices and its recommended value is 500 USDC / initial margin<br />fraction.<br />- Impact bid price = average execution price for a market sell of the<br />impact notional value.<br />- Impact ask price = average execution price for a market buy of the<br />impact notional value.|
|open_interest_lower_cap|string(uint64)|false|none|Lower cap for Open Interest Margin Fracton (OIMF), in quote quantums.<br />IMF is not affected when OI <= open_interest_lower_cap.|
|open_interest_upper_cap|string(uint64)|false|none|Upper cap for Open Interest Margin Fracton (OIMF), in quote quantums.<br />IMF scales linearly to 100% as OI approaches open_interest_upper_cap.<br />If zero, then the IMF does not scale with OI.|

## dydxprotocol.perpetuals.MarketPremiums

<a id="schemadydxprotocol.perpetuals.marketpremiums"></a>
<a id="schema_dydxprotocol.perpetuals.MarketPremiums"></a>
<a id="tocSdydxprotocol.perpetuals.marketpremiums"></a>
<a id="tocsdydxprotocol.perpetuals.marketpremiums"></a>

```json
{
  "perpetual_id": 0,
  "premiums": [
    0
  ]
}

```

MarketPremiums stores a list of premiums for a single perpetual market.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|perpetual_id|integer(int64)|false|none|perpetual_id is the Id of the perpetual market.|
|premiums|[integer]|false|none|premiums is a list of premium values for a perpetual market. Since most<br />premiums are zeros under "stable" market conditions, only non-zero values<br />are stored in this list.|

## dydxprotocol.perpetuals.Params

<a id="schemadydxprotocol.perpetuals.params"></a>
<a id="schema_dydxprotocol.perpetuals.Params"></a>
<a id="tocSdydxprotocol.perpetuals.params"></a>
<a id="tocsdydxprotocol.perpetuals.params"></a>

```json
{
  "funding_rate_clamp_factor_ppm": 0,
  "premium_vote_clamp_factor_ppm": 0,
  "min_num_votes_per_sample": 0
}

```

Params defines the parameters for x/perpetuals module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|funding_rate_clamp_factor_ppm|integer(int64)|false|none|Funding rate clamp factor in parts-per-million, used for clamping 8-hour<br />funding rates according to equation: |R| <= funding_rate_clamp_factor *<br />(initial margin - maintenance margin).|
|premium_vote_clamp_factor_ppm|integer(int64)|false|none|Premium vote clamp factor in parts-per-million, used for clamping premium<br />votes according to equation: |V| <= premium_vote_clamp_factor *<br />(initial margin - maintenance margin).|
|min_num_votes_per_sample|integer(int64)|false|none|Minimum number of premium votes per premium sample. If number of premium<br />votes is smaller than this number, pad with zeros up to this number.|

## dydxprotocol.perpetuals.Perpetual

<a id="schemadydxprotocol.perpetuals.perpetual"></a>
<a id="schema_dydxprotocol.perpetuals.Perpetual"></a>
<a id="tocSdydxprotocol.perpetuals.perpetual"></a>
<a id="tocsdydxprotocol.perpetuals.perpetual"></a>

```json
{
  "params": {
    "id": 0,
    "ticker": "string",
    "market_id": 0,
    "atomic_resolution": 0,
    "default_funding_ppm": 0,
    "liquidity_tier": 0,
    "market_type": "PERPETUAL_MARKET_TYPE_UNSPECIFIED"
  },
  "funding_index": "string",
  "open_interest": "string"
}

```

Perpetual represents a perpetual on the dYdX exchange.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|PerpetualParams is the parameters of the perpetual.|
|» id|integer(int64)|false|none|Unique, sequentially-generated.|
|» ticker|string|false|none|The name of the `Perpetual` (e.g. `BTC-USD`).|
|» market_id|integer(int64)|false|none|The market associated with this `Perpetual`. It<br />acts as the oracle price for the purposes of calculating<br />collateral, margin requirements, and funding rates.|
|» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (`size = 1`)<br />to a full coin. For example, if `AtomicResolution = -8`<br />then a `PerpetualPosition` with `size = 1e8` is equivalent to<br />a position size of one full coin.|
|» default_funding_ppm|integer(int32)|false|none|The default funding payment if there is no price premium. In<br />parts-per-million.|
|» liquidity_tier|integer(int64)|false|none|The liquidity_tier that this perpetual is associated with.|
|» market_type|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|
|funding_index|string(byte)|false|none|The current index determined by the cumulative all-time<br />history of the funding mechanism. Starts at zero.|
|open_interest|string(byte)|false|none|Total size of open long contracts, measured in base_quantums.|

#### Enumerated Values

|Property|Value|
|---|---|
|market_type|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|market_type|PERPETUAL_MARKET_TYPE_CROSS|
|market_type|PERPETUAL_MARKET_TYPE_ISOLATED|

## dydxprotocol.perpetuals.PerpetualMarketType

<a id="schemadydxprotocol.perpetuals.perpetualmarkettype"></a>
<a id="schema_dydxprotocol.perpetuals.PerpetualMarketType"></a>
<a id="tocSdydxprotocol.perpetuals.perpetualmarkettype"></a>
<a id="tocsdydxprotocol.perpetuals.perpetualmarkettype"></a>

```json
"PERPETUAL_MARKET_TYPE_UNSPECIFIED"

```

 - PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.
 - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.
 - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|*anonymous*|PERPETUAL_MARKET_TYPE_CROSS|
|*anonymous*|PERPETUAL_MARKET_TYPE_ISOLATED|

## dydxprotocol.perpetuals.PerpetualParams

<a id="schemadydxprotocol.perpetuals.perpetualparams"></a>
<a id="schema_dydxprotocol.perpetuals.PerpetualParams"></a>
<a id="tocSdydxprotocol.perpetuals.perpetualparams"></a>
<a id="tocsdydxprotocol.perpetuals.perpetualparams"></a>

```json
{
  "id": 0,
  "ticker": "string",
  "market_id": 0,
  "atomic_resolution": 0,
  "default_funding_ppm": 0,
  "liquidity_tier": 0,
  "market_type": "PERPETUAL_MARKET_TYPE_UNSPECIFIED"
}

```

PerpetualParams represents the parameters of a perpetual on the dYdX
exchange.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|Unique, sequentially-generated.|
|ticker|string|false|none|The name of the `Perpetual` (e.g. `BTC-USD`).|
|market_id|integer(int64)|false|none|The market associated with this `Perpetual`. It<br />acts as the oracle price for the purposes of calculating<br />collateral, margin requirements, and funding rates.|
|atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (`size = 1`)<br />to a full coin. For example, if `AtomicResolution = -8`<br />then a `PerpetualPosition` with `size = 1e8` is equivalent to<br />a position size of one full coin.|
|default_funding_ppm|integer(int32)|false|none|The default funding payment if there is no price premium. In<br />parts-per-million.|
|liquidity_tier|integer(int64)|false|none|The liquidity_tier that this perpetual is associated with.|
|market_type|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|

#### Enumerated Values

|Property|Value|
|---|---|
|market_type|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|market_type|PERPETUAL_MARKET_TYPE_CROSS|
|market_type|PERPETUAL_MARKET_TYPE_ISOLATED|

## dydxprotocol.perpetuals.PremiumStore

<a id="schemadydxprotocol.perpetuals.premiumstore"></a>
<a id="schema_dydxprotocol.perpetuals.PremiumStore"></a>
<a id="tocSdydxprotocol.perpetuals.premiumstore"></a>
<a id="tocsdydxprotocol.perpetuals.premiumstore"></a>

```json
{
  "all_market_premiums": [
    {
      "perpetual_id": 0,
      "premiums": [
        0
      ]
    }
  ],
  "num_premiums": 0
}

```

PremiumStore is a struct to store a perpetual premiums for all
perpetual markets. It stores a list of `MarketPremiums`, each of which
corresponds to a perpetual market and stores a list of non-zero premium
values for that market.
This struct can either be used to store `PremiumVotes` or
`PremiumSamples`.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|all_market_premiums|[object]|false|none|all_market_premiums a list of `MarketPremiums`, each corresponding to<br />a perpetual market.|
|» perpetual_id|integer(int64)|false|none|perpetual_id is the Id of the perpetual market.|
|» premiums|[integer]|false|none|premiums is a list of premium values for a perpetual market. Since most<br />premiums are zeros under "stable" market conditions, only non-zero values<br />are stored in this list.|
|num_premiums|integer(int64)|false|none|number of rounds where premium values were added. This value indicates<br />the total number of premiums (zeros and non-zeros) for each<br />`MarketPremiums` struct. Note that in the edge case a perpetual market was<br />added in the middle of a epoch, we don't keep a seperate count for that<br />market. This means we treat this market as having zero premiums before it<br />was added.|

## dydxprotocol.perpetuals.QueryAllLiquidityTiersResponse

<a id="schemadydxprotocol.perpetuals.queryallliquiditytiersresponse"></a>
<a id="schema_dydxprotocol.perpetuals.QueryAllLiquidityTiersResponse"></a>
<a id="tocSdydxprotocol.perpetuals.queryallliquiditytiersresponse"></a>
<a id="tocsdydxprotocol.perpetuals.queryallliquiditytiersresponse"></a>

```json
{
  "liquidity_tiers": [
    {
      "id": 0,
      "name": "string",
      "initial_margin_ppm": 0,
      "maintenance_fraction_ppm": 0,
      "base_position_notional": "string",
      "impact_notional": "string",
      "open_interest_lower_cap": "string",
      "open_interest_upper_cap": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllLiquidityTiersResponse is response type for the AllLiquidityTiers RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|liquidity_tiers|[object]|false|none|none|
|» id|integer(int64)|false|none|Unique id.|
|» name|string|false|none|The name of the tier purely for mnemonic purposes, e.g. "Gold".|
|» initial_margin_ppm|integer(int64)|false|none|The margin fraction needed to open a position.<br />In parts-per-million.|
|» maintenance_fraction_ppm|integer(int64)|false|none|The fraction of the initial-margin that the maintenance-margin is,<br />e.g. 50%. In parts-per-million.|
|» base_position_notional|string(uint64)|false|none|The maximum position size at which the margin requirements are<br />not increased over the default values. Above this position size,<br />the margin requirements increase at a rate of sqrt(size).<br /><br />Deprecated since v3.x.|
|» impact_notional|string(uint64)|false|none|The impact notional amount (in quote quantums) is used to determine impact<br />bid/ask prices and its recommended value is 500 USDC / initial margin<br />fraction.<br />- Impact bid price = average execution price for a market sell of the<br />impact notional value.<br />- Impact ask price = average execution price for a market buy of the<br />impact notional value.|
|» open_interest_lower_cap|string(uint64)|false|none|Lower cap for Open Interest Margin Fracton (OIMF), in quote quantums.<br />IMF is not affected when OI <= open_interest_lower_cap.|
|» open_interest_upper_cap|string(uint64)|false|none|Upper cap for Open Interest Margin Fracton (OIMF), in quote quantums.<br />IMF scales linearly to 100% as OI approaches open_interest_upper_cap.<br />If zero, then the IMF does not scale with OI.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## dydxprotocol.perpetuals.QueryAllPerpetualsResponse

<a id="schemadydxprotocol.perpetuals.queryallperpetualsresponse"></a>
<a id="schema_dydxprotocol.perpetuals.QueryAllPerpetualsResponse"></a>
<a id="tocSdydxprotocol.perpetuals.queryallperpetualsresponse"></a>
<a id="tocsdydxprotocol.perpetuals.queryallperpetualsresponse"></a>

```json
{
  "perpetual": [
    {
      "params": {
        "id": 0,
        "ticker": "string",
        "market_id": 0,
        "atomic_resolution": 0,
        "default_funding_ppm": 0,
        "liquidity_tier": 0,
        "market_type": "PERPETUAL_MARKET_TYPE_UNSPECIFIED"
      },
      "funding_index": "string",
      "open_interest": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllPerpetualsResponse is response type for the AllPerpetuals RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|perpetual|[object]|false|none|none|
|» params|object|false|none|PerpetualParams is the parameters of the perpetual.|
|»» id|integer(int64)|false|none|Unique, sequentially-generated.|
|»» ticker|string|false|none|The name of the `Perpetual` (e.g. `BTC-USD`).|
|»» market_id|integer(int64)|false|none|The market associated with this `Perpetual`. It<br />acts as the oracle price for the purposes of calculating<br />collateral, margin requirements, and funding rates.|
|»» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (`size = 1`)<br />to a full coin. For example, if `AtomicResolution = -8`<br />then a `PerpetualPosition` with `size = 1e8` is equivalent to<br />a position size of one full coin.|
|»» default_funding_ppm|integer(int32)|false|none|The default funding payment if there is no price premium. In<br />parts-per-million.|
|»» liquidity_tier|integer(int64)|false|none|The liquidity_tier that this perpetual is associated with.|
|»» market_type|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|
|» funding_index|string(byte)|false|none|The current index determined by the cumulative all-time<br />history of the funding mechanism. Starts at zero.|
|» open_interest|string(byte)|false|none|Total size of open long contracts, measured in base_quantums.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|market_type|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|market_type|PERPETUAL_MARKET_TYPE_CROSS|
|market_type|PERPETUAL_MARKET_TYPE_ISOLATED|

## dydxprotocol.perpetuals.QueryParamsResponse

<a id="schemadydxprotocol.perpetuals.queryparamsresponse"></a>
<a id="schema_dydxprotocol.perpetuals.QueryParamsResponse"></a>
<a id="tocSdydxprotocol.perpetuals.queryparamsresponse"></a>
<a id="tocsdydxprotocol.perpetuals.queryparamsresponse"></a>

```json
{
  "params": {
    "funding_rate_clamp_factor_ppm": 0,
    "premium_vote_clamp_factor_ppm": 0,
    "min_num_votes_per_sample": 0
  }
}

```

QueryParamsResponse is the response type for the Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|Params defines the parameters for x/perpetuals module.|
|» funding_rate_clamp_factor_ppm|integer(int64)|false|none|Funding rate clamp factor in parts-per-million, used for clamping 8-hour<br />funding rates according to equation: |R| <= funding_rate_clamp_factor *<br />(initial margin - maintenance margin).|
|» premium_vote_clamp_factor_ppm|integer(int64)|false|none|Premium vote clamp factor in parts-per-million, used for clamping premium<br />votes according to equation: |V| <= premium_vote_clamp_factor *<br />(initial margin - maintenance margin).|
|» min_num_votes_per_sample|integer(int64)|false|none|Minimum number of premium votes per premium sample. If number of premium<br />votes is smaller than this number, pad with zeros up to this number.|

## dydxprotocol.perpetuals.QueryPerpetualResponse

<a id="schemadydxprotocol.perpetuals.queryperpetualresponse"></a>
<a id="schema_dydxprotocol.perpetuals.QueryPerpetualResponse"></a>
<a id="tocSdydxprotocol.perpetuals.queryperpetualresponse"></a>
<a id="tocsdydxprotocol.perpetuals.queryperpetualresponse"></a>

```json
{
  "perpetual": {
    "params": {
      "id": 0,
      "ticker": "string",
      "market_id": 0,
      "atomic_resolution": 0,
      "default_funding_ppm": 0,
      "liquidity_tier": 0,
      "market_type": "PERPETUAL_MARKET_TYPE_UNSPECIFIED"
    },
    "funding_index": "string",
    "open_interest": "string"
  }
}

```

QueryPerpetualResponse is response type for the Perpetual RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|perpetual|object|false|none|Perpetual represents a perpetual on the dYdX exchange.|
|» params|object|false|none|PerpetualParams is the parameters of the perpetual.|
|»» id|integer(int64)|false|none|Unique, sequentially-generated.|
|»» ticker|string|false|none|The name of the `Perpetual` (e.g. `BTC-USD`).|
|»» market_id|integer(int64)|false|none|The market associated with this `Perpetual`. It<br />acts as the oracle price for the purposes of calculating<br />collateral, margin requirements, and funding rates.|
|»» atomic_resolution|integer(int32)|false|none|The exponent for converting an atomic amount (`size = 1`)<br />to a full coin. For example, if `AtomicResolution = -8`<br />then a `PerpetualPosition` with `size = 1e8` is equivalent to<br />a position size of one full coin.|
|»» default_funding_ppm|integer(int32)|false|none|The default funding payment if there is no price premium. In<br />parts-per-million.|
|»» liquidity_tier|integer(int64)|false|none|The liquidity_tier that this perpetual is associated with.|
|»» market_type|string|false|none|- PERPETUAL_MARKET_TYPE_UNSPECIFIED: Unspecified market type.<br /> - PERPETUAL_MARKET_TYPE_CROSS: Market type for cross margin perpetual markets.<br /> - PERPETUAL_MARKET_TYPE_ISOLATED: Market type for isolated margin perpetual markets.|
|» funding_index|string(byte)|false|none|The current index determined by the cumulative all-time<br />history of the funding mechanism. Starts at zero.|
|» open_interest|string(byte)|false|none|Total size of open long contracts, measured in base_quantums.|

#### Enumerated Values

|Property|Value|
|---|---|
|market_type|PERPETUAL_MARKET_TYPE_UNSPECIFIED|
|market_type|PERPETUAL_MARKET_TYPE_CROSS|
|market_type|PERPETUAL_MARKET_TYPE_ISOLATED|

## dydxprotocol.perpetuals.QueryPremiumSamplesResponse

<a id="schemadydxprotocol.perpetuals.querypremiumsamplesresponse"></a>
<a id="schema_dydxprotocol.perpetuals.QueryPremiumSamplesResponse"></a>
<a id="tocSdydxprotocol.perpetuals.querypremiumsamplesresponse"></a>
<a id="tocsdydxprotocol.perpetuals.querypremiumsamplesresponse"></a>

```json
{
  "premium_samples": {
    "all_market_premiums": [
      {
        "perpetual_id": 0,
        "premiums": [
          0
        ]
      }
    ],
    "num_premiums": 0
  }
}

```

QueryPremiumSamplesResponse is the response type for the PremiumSamples RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|premium_samples|object|false|none|PremiumStore is a struct to store a perpetual premiums for all<br />perpetual markets. It stores a list of `MarketPremiums`, each of which<br />corresponds to a perpetual market and stores a list of non-zero premium<br />values for that market.<br />This struct can either be used to store `PremiumVotes` or<br />`PremiumSamples`.|
|» all_market_premiums|[object]|false|none|all_market_premiums a list of `MarketPremiums`, each corresponding to<br />a perpetual market.|
|»» perpetual_id|integer(int64)|false|none|perpetual_id is the Id of the perpetual market.|
|»» premiums|[integer]|false|none|premiums is a list of premium values for a perpetual market. Since most<br />premiums are zeros under "stable" market conditions, only non-zero values<br />are stored in this list.|
|» num_premiums|integer(int64)|false|none|number of rounds where premium values were added. This value indicates<br />the total number of premiums (zeros and non-zeros) for each<br />`MarketPremiums` struct. Note that in the edge case a perpetual market was<br />added in the middle of a epoch, we don't keep a seperate count for that<br />market. This means we treat this market as having zero premiums before it<br />was added.|

## dydxprotocol.perpetuals.QueryPremiumVotesResponse

<a id="schemadydxprotocol.perpetuals.querypremiumvotesresponse"></a>
<a id="schema_dydxprotocol.perpetuals.QueryPremiumVotesResponse"></a>
<a id="tocSdydxprotocol.perpetuals.querypremiumvotesresponse"></a>
<a id="tocsdydxprotocol.perpetuals.querypremiumvotesresponse"></a>

```json
{
  "premium_votes": {
    "all_market_premiums": [
      {
        "perpetual_id": 0,
        "premiums": [
          0
        ]
      }
    ],
    "num_premiums": 0
  }
}

```

QueryPremiumVotesResponse is the response type for the PremiumVotes RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|premium_votes|object|false|none|PremiumStore is a struct to store a perpetual premiums for all<br />perpetual markets. It stores a list of `MarketPremiums`, each of which<br />corresponds to a perpetual market and stores a list of non-zero premium<br />values for that market.<br />This struct can either be used to store `PremiumVotes` or<br />`PremiumSamples`.|
|» all_market_premiums|[object]|false|none|all_market_premiums a list of `MarketPremiums`, each corresponding to<br />a perpetual market.|
|»» perpetual_id|integer(int64)|false|none|perpetual_id is the Id of the perpetual market.|
|»» premiums|[integer]|false|none|premiums is a list of premium values for a perpetual market. Since most<br />premiums are zeros under "stable" market conditions, only non-zero values<br />are stored in this list.|
|» num_premiums|integer(int64)|false|none|number of rounds where premium values were added. This value indicates<br />the total number of premiums (zeros and non-zeros) for each<br />`MarketPremiums` struct. Note that in the edge case a perpetual market was<br />added in the middle of a epoch, we don't keep a seperate count for that<br />market. This means we treat this market as having zero premiums before it<br />was added.|

## dydxprotocol.prices.MarketParam

<a id="schemadydxprotocol.prices.marketparam"></a>
<a id="schema_dydxprotocol.prices.MarketParam"></a>
<a id="tocSdydxprotocol.prices.marketparam"></a>
<a id="tocsdydxprotocol.prices.marketparam"></a>

```json
{
  "id": 0,
  "pair": "string",
  "exponent": 0,
  "min_exchanges": 0,
  "min_price_change_ppm": 0,
  "exchange_config_json": "string"
}

```

MarketParam represents the x/prices configuration for markets, including
representing price values, resolving markets on individual exchanges, and
generating price updates. This configuration is specific to the quote
currency.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|Unique, sequentially-generated value.|
|pair|string|false|none|The human-readable name of the market pair (e.g. `BTC-USD`).|
|exponent|integer(int32)|false|none|Static value. The exponent of the price.<br />For example if `Exponent == -5` then a `Value` of `1,000,000,000`<br />represents ``$10,000`. Therefore `10 ^ Exponent` represents the smallest<br />price step (in dollars) that can be recorded.|
|min_exchanges|integer(int64)|false|none|The minimum number of exchanges that should be reporting a live price for<br />a price update to be considered valid.|
|min_price_change_ppm|integer(int64)|false|none|The minimum allowable change in `price` value that would cause a price<br />update on the network. Measured as `1e-6` (parts per million).|
|exchange_config_json|string|false|none|A string of json that encodes the configuration for resolving the price<br />of this market on various exchanges.|

## dydxprotocol.prices.MarketPrice

<a id="schemadydxprotocol.prices.marketprice"></a>
<a id="schema_dydxprotocol.prices.MarketPrice"></a>
<a id="tocSdydxprotocol.prices.marketprice"></a>
<a id="tocsdydxprotocol.prices.marketprice"></a>

```json
{
  "id": 0,
  "exponent": 0,
  "price": "string"
}

```

MarketPrice is used by the application to store/retrieve oracle price.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|integer(int64)|false|none|Unique, sequentially-generated value that matches `MarketParam`.|
|exponent|integer(int32)|false|none|Static value. The exponent of the price. See the comment on the duplicate<br />MarketParam field for more information.|
|price|string(uint64)|false|none|The variable value that is updated by oracle price updates. `0` if it has<br />never been updated, `>0` otherwise.|

## dydxprotocol.prices.QueryAllMarketParamsResponse

<a id="schemadydxprotocol.prices.queryallmarketparamsresponse"></a>
<a id="schema_dydxprotocol.prices.QueryAllMarketParamsResponse"></a>
<a id="tocSdydxprotocol.prices.queryallmarketparamsresponse"></a>
<a id="tocsdydxprotocol.prices.queryallmarketparamsresponse"></a>

```json
{
  "market_params": [
    {
      "id": 0,
      "pair": "string",
      "exponent": 0,
      "min_exchanges": 0,
      "min_price_change_ppm": 0,
      "exchange_config_json": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllMarketParamsResponse is response type for the Query/Params
`AllMarketParams` RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|market_params|[object]|false|none|none|
|» id|integer(int64)|false|none|Unique, sequentially-generated value.|
|» pair|string|false|none|The human-readable name of the market pair (e.g. `BTC-USD`).|
|» exponent|integer(int32)|false|none|Static value. The exponent of the price.<br />For example if `Exponent == -5` then a `Value` of `1,000,000,000`<br />represents ``$10,000`. Therefore `10 ^ Exponent` represents the smallest<br />price step (in dollars) that can be recorded.|
|» min_exchanges|integer(int64)|false|none|The minimum number of exchanges that should be reporting a live price for<br />a price update to be considered valid.|
|» min_price_change_ppm|integer(int64)|false|none|The minimum allowable change in `price` value that would cause a price<br />update on the network. Measured as `1e-6` (parts per million).|
|» exchange_config_json|string|false|none|A string of json that encodes the configuration for resolving the price<br />of this market on various exchanges.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## dydxprotocol.prices.QueryAllMarketPricesResponse

<a id="schemadydxprotocol.prices.queryallmarketpricesresponse"></a>
<a id="schema_dydxprotocol.prices.QueryAllMarketPricesResponse"></a>
<a id="tocSdydxprotocol.prices.queryallmarketpricesresponse"></a>
<a id="tocsdydxprotocol.prices.queryallmarketpricesresponse"></a>

```json
{
  "market_prices": [
    {
      "id": 0,
      "exponent": 0,
      "price": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllMarketPricesResponse is response type for the Query/Params
`AllMarketPrices` RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|market_prices|[object]|false|none|none|
|» id|integer(int64)|false|none|Unique, sequentially-generated value that matches `MarketParam`.|
|» exponent|integer(int32)|false|none|Static value. The exponent of the price. See the comment on the duplicate<br />MarketParam field for more information.|
|» price|string(uint64)|false|none|The variable value that is updated by oracle price updates. `0` if it has<br />never been updated, `>0` otherwise.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## dydxprotocol.prices.QueryMarketParamResponse

<a id="schemadydxprotocol.prices.querymarketparamresponse"></a>
<a id="schema_dydxprotocol.prices.QueryMarketParamResponse"></a>
<a id="tocSdydxprotocol.prices.querymarketparamresponse"></a>
<a id="tocsdydxprotocol.prices.querymarketparamresponse"></a>

```json
{
  "market_param": {
    "id": 0,
    "pair": "string",
    "exponent": 0,
    "min_exchanges": 0,
    "min_price_change_ppm": 0,
    "exchange_config_json": "string"
  }
}

```

QueryMarketParamResponse is response type for the Query/Params `MarketParams`
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|market_param|object|false|none|MarketParam represents the x/prices configuration for markets, including<br />representing price values, resolving markets on individual exchanges, and<br />generating price updates. This configuration is specific to the quote<br />currency.|
|» id|integer(int64)|false|none|Unique, sequentially-generated value.|
|» pair|string|false|none|The human-readable name of the market pair (e.g. `BTC-USD`).|
|» exponent|integer(int32)|false|none|Static value. The exponent of the price.<br />For example if `Exponent == -5` then a `Value` of `1,000,000,000`<br />represents ``$10,000`. Therefore `10 ^ Exponent` represents the smallest<br />price step (in dollars) that can be recorded.|
|» min_exchanges|integer(int64)|false|none|The minimum number of exchanges that should be reporting a live price for<br />a price update to be considered valid.|
|» min_price_change_ppm|integer(int64)|false|none|The minimum allowable change in `price` value that would cause a price<br />update on the network. Measured as `1e-6` (parts per million).|
|» exchange_config_json|string|false|none|A string of json that encodes the configuration for resolving the price<br />of this market on various exchanges.|

## dydxprotocol.prices.QueryMarketPriceResponse

<a id="schemadydxprotocol.prices.querymarketpriceresponse"></a>
<a id="schema_dydxprotocol.prices.QueryMarketPriceResponse"></a>
<a id="tocSdydxprotocol.prices.querymarketpriceresponse"></a>
<a id="tocsdydxprotocol.prices.querymarketpriceresponse"></a>

```json
{
  "market_price": {
    "id": 0,
    "exponent": 0,
    "price": "string"
  }
}

```

QueryMarketPriceResponse is response type for the Query/Params `MarketPrice`
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|market_price|object|false|none|MarketPrice is used by the application to store/retrieve oracle price.|
|» id|integer(int64)|false|none|Unique, sequentially-generated value that matches `MarketParam`.|
|» exponent|integer(int32)|false|none|Static value. The exponent of the price. See the comment on the duplicate<br />MarketParam field for more information.|
|» price|string(uint64)|false|none|The variable value that is updated by oracle price updates. `0` if it has<br />never been updated, `>0` otherwise.|

## dydxprotocol.rewards.Params

<a id="schemadydxprotocol.rewards.params"></a>
<a id="schema_dydxprotocol.rewards.Params"></a>
<a id="tocSdydxprotocol.rewards.params"></a>
<a id="tocsdydxprotocol.rewards.params"></a>

```json
{
  "treasury_account": "string",
  "denom": "string",
  "denom_exponent": 0,
  "market_id": 0,
  "fee_multiplier_ppm": 0
}

```

Params defines the parameters for x/rewards module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|treasury_account|string|false|none|The module account to distribute rewards from.|
|denom|string|false|none|The denom of the rewards token.|
|denom_exponent|integer(int32)|false|none|The exponent of converting one unit of `denom` to a full coin.<br />For example, `denom=uatom, denom_exponent=-6` defines that<br />`1 uatom = 10^(-6) ATOM`. This conversion is needed since the<br />`market_id` retrieves the price of a full coin of the reward token.|
|market_id|integer(int64)|false|none|The id of the market that has the price of the rewards token.|
|fee_multiplier_ppm|integer(int64)|false|none|The amount (in ppm) that fees are multiplied by to get<br />the maximum rewards amount.|

## dydxprotocol.rewards.QueryParamsResponse

<a id="schemadydxprotocol.rewards.queryparamsresponse"></a>
<a id="schema_dydxprotocol.rewards.QueryParamsResponse"></a>
<a id="tocSdydxprotocol.rewards.queryparamsresponse"></a>
<a id="tocsdydxprotocol.rewards.queryparamsresponse"></a>

```json
{
  "params": {
    "treasury_account": "string",
    "denom": "string",
    "denom_exponent": 0,
    "market_id": 0,
    "fee_multiplier_ppm": 0
  }
}

```

QueryParamsResponse is a response type for the Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|Params defines the parameters for x/rewards module.|
|» treasury_account|string|false|none|The module account to distribute rewards from.|
|» denom|string|false|none|The denom of the rewards token.|
|» denom_exponent|integer(int32)|false|none|The exponent of converting one unit of `denom` to a full coin.<br />For example, `denom=uatom, denom_exponent=-6` defines that<br />`1 uatom = 10^(-6) ATOM`. This conversion is needed since the<br />`market_id` retrieves the price of a full coin of the reward token.|
|» market_id|integer(int64)|false|none|The id of the market that has the price of the rewards token.|
|» fee_multiplier_ppm|integer(int64)|false|none|The amount (in ppm) that fees are multiplied by to get<br />the maximum rewards amount.|

## dydxprotocol.stats.GlobalStats

<a id="schemadydxprotocol.stats.globalstats"></a>
<a id="schema_dydxprotocol.stats.GlobalStats"></a>
<a id="tocSdydxprotocol.stats.globalstats"></a>
<a id="tocsdydxprotocol.stats.globalstats"></a>

```json
{
  "notional_traded": "string"
}

```

GlobalStats stores global stats

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|notional_traded|string(uint64)|false|none|none|

## dydxprotocol.stats.Params

<a id="schemadydxprotocol.stats.params"></a>
<a id="schema_dydxprotocol.stats.Params"></a>
<a id="tocSdydxprotocol.stats.params"></a>
<a id="tocsdydxprotocol.stats.params"></a>

```json
{
  "window_duration": "string"
}

```

Params defines the parameters for x/stats module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|window_duration|string|false|none|The desired number of seconds in the look-back window.|

## dydxprotocol.stats.QueryGlobalStatsResponse

<a id="schemadydxprotocol.stats.queryglobalstatsresponse"></a>
<a id="schema_dydxprotocol.stats.QueryGlobalStatsResponse"></a>
<a id="tocSdydxprotocol.stats.queryglobalstatsresponse"></a>
<a id="tocsdydxprotocol.stats.queryglobalstatsresponse"></a>

```json
{
  "stats": {
    "notional_traded": "string"
  }
}

```

QueryGlobalStatsResponse is a response type for the GlobalStats RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|stats|object|false|none|none|
|» notional_traded|string(uint64)|false|none|none|

## dydxprotocol.stats.QueryParamsResponse

<a id="schemadydxprotocol.stats.queryparamsresponse"></a>
<a id="schema_dydxprotocol.stats.QueryParamsResponse"></a>
<a id="tocSdydxprotocol.stats.queryparamsresponse"></a>
<a id="tocsdydxprotocol.stats.queryparamsresponse"></a>

```json
{
  "params": {
    "window_duration": "string"
  }
}

```

QueryParamsResponse is a response type for the Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|Params defines the parameters for x/stats module.|
|» window_duration|string|false|none|The desired number of seconds in the look-back window.|

## dydxprotocol.stats.QueryStatsMetadataResponse

<a id="schemadydxprotocol.stats.querystatsmetadataresponse"></a>
<a id="schema_dydxprotocol.stats.QueryStatsMetadataResponse"></a>
<a id="tocSdydxprotocol.stats.querystatsmetadataresponse"></a>
<a id="tocsdydxprotocol.stats.querystatsmetadataresponse"></a>

```json
{
  "metadata": {
    "trailing_epoch": 0
  }
}

```

QueryStatsMetadataResponse is a response type for the StatsMetadata RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metadata|object|false|none|none|
|» trailing_epoch|integer(int64)|false|none|The oldest epoch that is included in the stats. The next epoch to be<br />removed from the window.|

## dydxprotocol.stats.QueryUserStatsResponse

<a id="schemadydxprotocol.stats.queryuserstatsresponse"></a>
<a id="schema_dydxprotocol.stats.QueryUserStatsResponse"></a>
<a id="tocSdydxprotocol.stats.queryuserstatsresponse"></a>
<a id="tocsdydxprotocol.stats.queryuserstatsresponse"></a>

```json
{
  "stats": {
    "taker_notional": "string",
    "maker_notional": "string"
  }
}

```

QueryUserStatsResponse is a request type for the UserStats RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|stats|object|false|none|none|
|» taker_notional|string(uint64)|false|none|none|
|» maker_notional|string(uint64)|false|none|none|

## dydxprotocol.stats.StatsMetadata

<a id="schemadydxprotocol.stats.statsmetadata"></a>
<a id="schema_dydxprotocol.stats.StatsMetadata"></a>
<a id="tocSdydxprotocol.stats.statsmetadata"></a>
<a id="tocsdydxprotocol.stats.statsmetadata"></a>

```json
{
  "trailing_epoch": 0
}

```

StatsMetadata stores metadata for the x/stats module

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|trailing_epoch|integer(int64)|false|none|The oldest epoch that is included in the stats. The next epoch to be<br />removed from the window.|

## dydxprotocol.stats.UserStats

<a id="schemadydxprotocol.stats.userstats"></a>
<a id="schema_dydxprotocol.stats.UserStats"></a>
<a id="tocSdydxprotocol.stats.userstats"></a>
<a id="tocsdydxprotocol.stats.userstats"></a>

```json
{
  "taker_notional": "string",
  "maker_notional": "string"
}

```

UserStats stores stats for a User

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|taker_notional|string(uint64)|false|none|none|
|maker_notional|string(uint64)|false|none|none|

## dydxprotocol.subaccounts.AssetPosition

<a id="schemadydxprotocol.subaccounts.assetposition"></a>
<a id="schema_dydxprotocol.subaccounts.AssetPosition"></a>
<a id="tocSdydxprotocol.subaccounts.assetposition"></a>
<a id="tocsdydxprotocol.subaccounts.assetposition"></a>

```json
{
  "asset_id": 0,
  "quantums": "string",
  "index": "string"
}

```

AssetPositions define an account’s positions of an `Asset`.
Therefore they hold any information needed to trade on Spot and Margin.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|asset_id|integer(int64)|false|none|The `Id` of the `Asset`.|
|quantums|string(byte)|false|none|The absolute size of the position in base quantums.|
|index|string(uint64)|false|none|The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last<br />time this position was settled<br />TODO(DEC-582): pending margin trading being added.|

## dydxprotocol.subaccounts.PerpetualPosition

<a id="schemadydxprotocol.subaccounts.perpetualposition"></a>
<a id="schema_dydxprotocol.subaccounts.PerpetualPosition"></a>
<a id="tocSdydxprotocol.subaccounts.perpetualposition"></a>
<a id="tocsdydxprotocol.subaccounts.perpetualposition"></a>

```json
{
  "perpetual_id": 0,
  "quantums": "string",
  "funding_index": "string"
}

```

PerpetualPositions are an account’s positions of a `Perpetual`.
Therefore they hold any information needed to trade perpetuals.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|perpetual_id|integer(int64)|false|none|The `Id` of the `Perpetual`.|
|quantums|string(byte)|false|none|The size of the position in base quantums.|
|funding_index|string(byte)|false|none|The funding_index of the `Perpetual` the last time this position was<br />settled.|

## dydxprotocol.subaccounts.QueryCollateralPoolAddressResponse

<a id="schemadydxprotocol.subaccounts.querycollateralpooladdressresponse"></a>
<a id="schema_dydxprotocol.subaccounts.QueryCollateralPoolAddressResponse"></a>
<a id="tocSdydxprotocol.subaccounts.querycollateralpooladdressresponse"></a>
<a id="tocsdydxprotocol.subaccounts.querycollateralpooladdressresponse"></a>

```json
{
  "collateral_pool_address": "string"
}

```

QueryCollateralPoolAddressResponse is a response type for fetching the
account address of the collateral pool associated with the passed in
perpetual id.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|collateral_pool_address|string|false|none|none|

## dydxprotocol.subaccounts.QueryGetWithdrawalAndTransfersBlockedInfoResponse

<a id="schemadydxprotocol.subaccounts.querygetwithdrawalandtransfersblockedinforesponse"></a>
<a id="schema_dydxprotocol.subaccounts.QueryGetWithdrawalAndTransfersBlockedInfoResponse"></a>
<a id="tocSdydxprotocol.subaccounts.querygetwithdrawalandtransfersblockedinforesponse"></a>
<a id="tocsdydxprotocol.subaccounts.querygetwithdrawalandtransfersblockedinforesponse"></a>

```json
{
  "negative_tnc_subaccount_seen_at_block": 0,
  "chain_outage_seen_at_block": 0,
  "withdrawals_and_transfers_unblocked_at_block": 0
}

```

QueryGetWithdrawalAndTransfersBlockedInfoRequest is a response type for
fetching information about whether withdrawals and transfers are blocked.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|negative_tnc_subaccount_seen_at_block|integer(int64)|false|none|none|
|chain_outage_seen_at_block|integer(int64)|false|none|none|
|withdrawals_and_transfers_unblocked_at_block|integer(int64)|false|none|none|

## dydxprotocol.subaccounts.QuerySubaccountAllResponse

<a id="schemadydxprotocol.subaccounts.querysubaccountallresponse"></a>
<a id="schema_dydxprotocol.subaccounts.QuerySubaccountAllResponse"></a>
<a id="tocSdydxprotocol.subaccounts.querysubaccountallresponse"></a>
<a id="tocsdydxprotocol.subaccounts.querysubaccountallresponse"></a>

```json
{
  "subaccount": [
    {
      "id": {
        "owner": "string",
        "number": 0
      },
      "asset_positions": [
        {
          "asset_id": 0,
          "quantums": "string",
          "index": "string"
        }
      ],
      "perpetual_positions": [
        {
          "perpetual_id": 0,
          "quantums": "string",
          "funding_index": "string"
        }
      ],
      "margin_enabled": true
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QuerySubaccountAllResponse is response type for the Query RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|subaccount|[object]|false|none|none|
|» id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|» asset_positions|[object]|false|none|All `AssetPosition`s associated with this subaccount.<br />Always sorted ascending by `asset_id`.|
|»» asset_id|integer(int64)|false|none|The `Id` of the `Asset`.|
|»» quantums|string(byte)|false|none|The absolute size of the position in base quantums.|
|»» index|string(uint64)|false|none|The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last<br />time this position was settled<br />TODO(DEC-582): pending margin trading being added.|
|» perpetual_positions|[object]|false|none|All `PerpetualPosition`s associated with this subaccount.<br />Always sorted ascending by `perpetual_id.|
|»» perpetual_id|integer(int64)|false|none|The `Id` of the `Perpetual`.|
|»» quantums|string(byte)|false|none|The size of the position in base quantums.|
|»» funding_index|string(byte)|false|none|The funding_index of the `Perpetual` the last time this position was<br />settled.|
|» margin_enabled|boolean|false|none|Set by the owner. If true, then margin trades can be made in this<br />subaccount.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## dydxprotocol.subaccounts.QuerySubaccountResponse

<a id="schemadydxprotocol.subaccounts.querysubaccountresponse"></a>
<a id="schema_dydxprotocol.subaccounts.QuerySubaccountResponse"></a>
<a id="tocSdydxprotocol.subaccounts.querysubaccountresponse"></a>
<a id="tocsdydxprotocol.subaccounts.querysubaccountresponse"></a>

```json
{
  "subaccount": {
    "id": {
      "owner": "string",
      "number": 0
    },
    "asset_positions": [
      {
        "asset_id": 0,
        "quantums": "string",
        "index": "string"
      }
    ],
    "perpetual_positions": [
      {
        "perpetual_id": 0,
        "quantums": "string",
        "funding_index": "string"
      }
    ],
    "margin_enabled": true
  }
}

```

QuerySubaccountResponse is response type for the Query RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|subaccount|object|false|none|Subaccount defines a single sub-account for a given address.<br />Subaccounts are uniquely indexed by a subaccountNumber/owner pair.|
|» id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|»» owner|string|false|none|The address of the wallet that owns this subaccount.|
|»» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|» asset_positions|[object]|false|none|All `AssetPosition`s associated with this subaccount.<br />Always sorted ascending by `asset_id`.|
|»» asset_id|integer(int64)|false|none|The `Id` of the `Asset`.|
|»» quantums|string(byte)|false|none|The absolute size of the position in base quantums.|
|»» index|string(uint64)|false|none|The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last<br />time this position was settled<br />TODO(DEC-582): pending margin trading being added.|
|» perpetual_positions|[object]|false|none|All `PerpetualPosition`s associated with this subaccount.<br />Always sorted ascending by `perpetual_id.|
|»» perpetual_id|integer(int64)|false|none|The `Id` of the `Perpetual`.|
|»» quantums|string(byte)|false|none|The size of the position in base quantums.|
|»» funding_index|string(byte)|false|none|The funding_index of the `Perpetual` the last time this position was<br />settled.|
|» margin_enabled|boolean|false|none|Set by the owner. If true, then margin trades can be made in this<br />subaccount.|

## dydxprotocol.subaccounts.Subaccount

<a id="schemadydxprotocol.subaccounts.subaccount"></a>
<a id="schema_dydxprotocol.subaccounts.Subaccount"></a>
<a id="tocSdydxprotocol.subaccounts.subaccount"></a>
<a id="tocsdydxprotocol.subaccounts.subaccount"></a>

```json
{
  "id": {
    "owner": "string",
    "number": 0
  },
  "asset_positions": [
    {
      "asset_id": 0,
      "quantums": "string",
      "index": "string"
    }
  ],
  "perpetual_positions": [
    {
      "perpetual_id": 0,
      "quantums": "string",
      "funding_index": "string"
    }
  ],
  "margin_enabled": true
}

```

Subaccount defines a single sub-account for a given address.
Subaccounts are uniquely indexed by a subaccountNumber/owner pair.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|object|false|none|SubaccountId defines a unique identifier for a Subaccount.|
|» owner|string|false|none|The address of the wallet that owns this subaccount.|
|» number|integer(int64)|false|none|The unique number of this subaccount for the owner.<br />Currently limited to 128*1000 subaccounts per owner.|
|asset_positions|[object]|false|none|All `AssetPosition`s associated with this subaccount.<br />Always sorted ascending by `asset_id`.|
|» asset_id|integer(int64)|false|none|The `Id` of the `Asset`.|
|» quantums|string(byte)|false|none|The absolute size of the position in base quantums.|
|» index|string(uint64)|false|none|The `Index` (either `LongIndex` or `ShortIndex`) of the `Asset` the last<br />time this position was settled<br />TODO(DEC-582): pending margin trading being added.|
|perpetual_positions|[object]|false|none|All `PerpetualPosition`s associated with this subaccount.<br />Always sorted ascending by `perpetual_id.|
|» perpetual_id|integer(int64)|false|none|The `Id` of the `Perpetual`.|
|» quantums|string(byte)|false|none|The size of the position in base quantums.|
|» funding_index|string(byte)|false|none|The funding_index of the `Perpetual` the last time this position was<br />settled.|
|margin_enabled|boolean|false|none|Set by the owner. If true, then margin trades can be made in this<br />subaccount.|

## dydxprotocol.vest.QueryVestEntryResponse

<a id="schemadydxprotocol.vest.queryvestentryresponse"></a>
<a id="schema_dydxprotocol.vest.QueryVestEntryResponse"></a>
<a id="tocSdydxprotocol.vest.queryvestentryresponse"></a>
<a id="tocsdydxprotocol.vest.queryvestentryresponse"></a>

```json
{
  "entry": {
    "vester_account": "string",
    "treasury_account": "string",
    "denom": "string",
    "start_time": "2019-08-24T14:15:22Z",
    "end_time": "2019-08-24T14:15:22Z"
  }
}

```

QueryVestEntryResponse is a response type for the VestEntry RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|entry|object|false|none|VestEntry specifies a Vester Account and the rate at which tokens are<br />dripped into the corresponding Treasury Account.|
|» vester_account|string|false|none|The module account to vest tokens from.<br />This is also the key to this `VestEntry` in state.|
|» treasury_account|string|false|none|The module account to vest tokens to.|
|» denom|string|false|none|The denom of the token to vest.|
|» start_time|string(date-time)|false|none|The start time of vest. Before this time, no vest will occur.|
|» end_time|string(date-time)|false|none|The end time of vest. At this target date, all funds should be in the<br />Treasury Account and none left in the Vester Account.|

## dydxprotocol.vest.VestEntry

<a id="schemadydxprotocol.vest.vestentry"></a>
<a id="schema_dydxprotocol.vest.VestEntry"></a>
<a id="tocSdydxprotocol.vest.vestentry"></a>
<a id="tocsdydxprotocol.vest.vestentry"></a>

```json
{
  "vester_account": "string",
  "treasury_account": "string",
  "denom": "string",
  "start_time": "2019-08-24T14:15:22Z",
  "end_time": "2019-08-24T14:15:22Z"
}

```

VestEntry specifies a Vester Account and the rate at which tokens are
dripped into the corresponding Treasury Account.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|vester_account|string|false|none|The module account to vest tokens from.<br />This is also the key to this `VestEntry` in state.|
|treasury_account|string|false|none|The module account to vest tokens to.|
|denom|string|false|none|The denom of the token to vest.|
|start_time|string(date-time)|false|none|The start time of vest. Before this time, no vest will occur.|
|end_time|string(date-time)|false|none|The end time of vest. At this target date, all funds should be in the<br />Treasury Account and none left in the Vester Account.|

## ibc.applications.transfer.v1.DenomTrace

<a id="schemaibc.applications.transfer.v1.denomtrace"></a>
<a id="schema_ibc.applications.transfer.v1.DenomTrace"></a>
<a id="tocSibc.applications.transfer.v1.denomtrace"></a>
<a id="tocsibc.applications.transfer.v1.denomtrace"></a>

```json
{
  "path": "string",
  "base_denom": "string"
}

```

DenomTrace contains the base denomination for ICS20 fungible tokens and the
source tracing information path.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|path|string|false|none|path defines the chain of port/channel identifiers used for tracing the<br />source of the fungible token.|
|base_denom|string|false|none|base denomination of the relayed fungible token.|

## ibc.applications.transfer.v1.Params

<a id="schemaibc.applications.transfer.v1.params"></a>
<a id="schema_ibc.applications.transfer.v1.Params"></a>
<a id="tocSibc.applications.transfer.v1.params"></a>
<a id="tocsibc.applications.transfer.v1.params"></a>

```json
{
  "send_enabled": true,
  "receive_enabled": true
}

```

Params defines the set of IBC transfer parameters.
NOTE: To prevent a single token from being transferred, set the
TransfersEnabled parameter to true and then set the bank module's SendEnabled
parameter for the denomination to false.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|send_enabled|boolean|false|none|send_enabled enables or disables all cross-chain token transfers from this<br />chain.|
|receive_enabled|boolean|false|none|receive_enabled enables or disables all cross-chain token transfers to this<br />chain.|

## ibc.applications.transfer.v1.QueryDenomHashResponse

<a id="schemaibc.applications.transfer.v1.querydenomhashresponse"></a>
<a id="schema_ibc.applications.transfer.v1.QueryDenomHashResponse"></a>
<a id="tocSibc.applications.transfer.v1.querydenomhashresponse"></a>
<a id="tocsibc.applications.transfer.v1.querydenomhashresponse"></a>

```json
{
  "hash": "string"
}

```

QueryDenomHashResponse is the response type for the Query/DenomHash RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|hash|string|false|none|hash (in hex format) of the denomination trace information.|

## ibc.applications.transfer.v1.QueryDenomTraceResponse

<a id="schemaibc.applications.transfer.v1.querydenomtraceresponse"></a>
<a id="schema_ibc.applications.transfer.v1.QueryDenomTraceResponse"></a>
<a id="tocSibc.applications.transfer.v1.querydenomtraceresponse"></a>
<a id="tocsibc.applications.transfer.v1.querydenomtraceresponse"></a>

```json
{
  "denom_trace": {
    "path": "string",
    "base_denom": "string"
  }
}

```

QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom_trace|object|false|none|DenomTrace contains the base denomination for ICS20 fungible tokens and the<br />source tracing information path.|
|» path|string|false|none|path defines the chain of port/channel identifiers used for tracing the<br />source of the fungible token.|
|» base_denom|string|false|none|base denomination of the relayed fungible token.|

## ibc.applications.transfer.v1.QueryDenomTracesResponse

<a id="schemaibc.applications.transfer.v1.querydenomtracesresponse"></a>
<a id="schema_ibc.applications.transfer.v1.QueryDenomTracesResponse"></a>
<a id="tocSibc.applications.transfer.v1.querydenomtracesresponse"></a>
<a id="tocsibc.applications.transfer.v1.querydenomtracesresponse"></a>

```json
{
  "denom_traces": [
    {
      "path": "string",
      "base_denom": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom_traces|[object]|false|none|denom_traces returns all denominations trace information.|
|» path|string|false|none|path defines the chain of port/channel identifiers used for tracing the<br />source of the fungible token.|
|» base_denom|string|false|none|base denomination of the relayed fungible token.|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## ibc.applications.transfer.v1.QueryEscrowAddressResponse

<a id="schemaibc.applications.transfer.v1.queryescrowaddressresponse"></a>
<a id="schema_ibc.applications.transfer.v1.QueryEscrowAddressResponse"></a>
<a id="tocSibc.applications.transfer.v1.queryescrowaddressresponse"></a>
<a id="tocsibc.applications.transfer.v1.queryescrowaddressresponse"></a>

```json
{
  "escrow_address": "string"
}

```

QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|escrow_address|string|false|none|none|

## ibc.applications.transfer.v1.QueryParamsResponse

<a id="schemaibc.applications.transfer.v1.queryparamsresponse"></a>
<a id="schema_ibc.applications.transfer.v1.QueryParamsResponse"></a>
<a id="tocSibc.applications.transfer.v1.queryparamsresponse"></a>
<a id="tocsibc.applications.transfer.v1.queryparamsresponse"></a>

```json
{
  "params": {
    "send_enabled": true,
    "receive_enabled": true
  }
}

```

QueryParamsResponse is the response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» send_enabled|boolean|false|none|send_enabled enables or disables all cross-chain token transfers from this<br />chain.|
|» receive_enabled|boolean|false|none|receive_enabled enables or disables all cross-chain token transfers to this<br />chain.|

## ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse

<a id="schemaibc.applications.transfer.v1.querytotalescrowfordenomresponse"></a>
<a id="schema_ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse"></a>
<a id="tocSibc.applications.transfer.v1.querytotalescrowfordenomresponse"></a>
<a id="tocsibc.applications.transfer.v1.querytotalescrowfordenomresponse"></a>

```json
{
  "amount": {
    "denom": "string",
    "amount": "string"
  }
}

```

QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amount|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## ibc.core.client.v1.ConsensusStateWithHeight

<a id="schemaibc.core.client.v1.consensusstatewithheight"></a>
<a id="schema_ibc.core.client.v1.ConsensusStateWithHeight"></a>
<a id="tocSibc.core.client.v1.consensusstatewithheight"></a>
<a id="tocsibc.core.client.v1.consensusstatewithheight"></a>

```json
{
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  },
  "consensus_state": {
    "type_url": "string",
    "value": "string"
  }
}

```

ConsensusStateWithHeight defines a consensus state with an additional height
field.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|
|consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## ibc.core.client.v1.Height

<a id="schemaibc.core.client.v1.height"></a>
<a id="schema_ibc.core.client.v1.Height"></a>
<a id="tocSibc.core.client.v1.height"></a>
<a id="tocsibc.core.client.v1.height"></a>

```json
{
  "revision_number": "string",
  "revision_height": "string"
}

```

Height is a monotonically increasing data type
that can be compared against another Height for the purposes of updating and
freezing clients

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|revision_number|string(uint64)|false|none|none|
|revision_height|string(uint64)|false|none|none|

## ibc.core.client.v1.IdentifiedClientState

<a id="schemaibc.core.client.v1.identifiedclientstate"></a>
<a id="schema_ibc.core.client.v1.IdentifiedClientState"></a>
<a id="tocSibc.core.client.v1.identifiedclientstate"></a>
<a id="tocsibc.core.client.v1.identifiedclientstate"></a>

```json
{
  "client_id": "string",
  "client_state": {
    "type_url": "string",
    "value": "string"
  }
}

```

IdentifiedClientState defines a client state with an additional client
identifier field.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|client_id|string|false|none|none|
|client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## ibc.core.client.v1.Params

<a id="schemaibc.core.client.v1.params"></a>
<a id="schema_ibc.core.client.v1.Params"></a>
<a id="tocSibc.core.client.v1.params"></a>
<a id="tocsibc.core.client.v1.params"></a>

```json
{
  "allowed_clients": [
    "string"
  ]
}

```

Params defines the set of IBC light client parameters.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|allowed_clients|[string]|false|none|allowed_clients defines the list of allowed client state types which can be created<br />and interacted with. If a client type is removed from the allowed clients list, usage<br />of this client will be disabled until it is added again to the list.|

## ibc.core.client.v1.QueryClientParamsResponse

<a id="schemaibc.core.client.v1.queryclientparamsresponse"></a>
<a id="schema_ibc.core.client.v1.QueryClientParamsResponse"></a>
<a id="tocSibc.core.client.v1.queryclientparamsresponse"></a>
<a id="tocsibc.core.client.v1.queryclientparamsresponse"></a>

```json
{
  "params": {
    "allowed_clients": [
      "string"
    ]
  }
}

```

QueryClientParamsResponse is the response type for the Query/ClientParams RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» allowed_clients|[string]|false|none|allowed_clients defines the list of allowed client state types which can be created<br />and interacted with. If a client type is removed from the allowed clients list, usage<br />of this client will be disabled until it is added again to the list.|

## ibc.core.client.v1.QueryClientStateResponse

<a id="schemaibc.core.client.v1.queryclientstateresponse"></a>
<a id="schema_ibc.core.client.v1.QueryClientStateResponse"></a>
<a id="tocSibc.core.client.v1.queryclientstateresponse"></a>
<a id="tocsibc.core.client.v1.queryclientstateresponse"></a>

```json
{
  "client_state": {
    "type_url": "string",
    "value": "string"
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryClientStateResponse is the response type for the Query/ClientState RPC
method. Besides the client state, it includes a proof and the height from
which the proof was retrieved.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.client.v1.QueryClientStatesResponse

<a id="schemaibc.core.client.v1.queryclientstatesresponse"></a>
<a id="schema_ibc.core.client.v1.QueryClientStatesResponse"></a>
<a id="tocSibc.core.client.v1.queryclientstatesresponse"></a>
<a id="tocsibc.core.client.v1.queryclientstatesresponse"></a>

```json
{
  "client_states": [
    {
      "client_id": "string",
      "client_state": {
        "type_url": "string",
        "value": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryClientStatesResponse is the response type for the Query/ClientStates RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|client_states|[object]|false|none|list of stored ClientStates of the chain.|
|» client_id|string|false|none|none|
|» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## ibc.core.client.v1.QueryClientStatusResponse

<a id="schemaibc.core.client.v1.queryclientstatusresponse"></a>
<a id="schema_ibc.core.client.v1.QueryClientStatusResponse"></a>
<a id="tocSibc.core.client.v1.queryclientstatusresponse"></a>
<a id="tocsibc.core.client.v1.queryclientstatusresponse"></a>

```json
{
  "status": "string"
}

```

QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
method. It returns the current status of the IBC client.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|status|string|false|none|none|

## ibc.core.client.v1.QueryConsensusStateHeightsResponse

<a id="schemaibc.core.client.v1.queryconsensusstateheightsresponse"></a>
<a id="schema_ibc.core.client.v1.QueryConsensusStateHeightsResponse"></a>
<a id="tocSibc.core.client.v1.queryconsensusstateheightsresponse"></a>
<a id="tocsibc.core.client.v1.queryconsensusstateheightsresponse"></a>

```json
{
  "consensus_state_heights": [
    {
      "revision_number": "string",
      "revision_height": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryConsensusStateHeightsResponse is the response type for the
Query/ConsensusStateHeights RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|consensus_state_heights|[object]|false|none|none|
|» Height is a monotonically increasing data type
that can be compared against another Height for the purposes of updating and
freezing clients|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## ibc.core.client.v1.QueryConsensusStateResponse

<a id="schemaibc.core.client.v1.queryconsensusstateresponse"></a>
<a id="schema_ibc.core.client.v1.QueryConsensusStateResponse"></a>
<a id="tocSibc.core.client.v1.queryconsensusstateresponse"></a>
<a id="tocsibc.core.client.v1.queryconsensusstateresponse"></a>

```json
{
  "consensus_state": {
    "type_url": "string",
    "value": "string"
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryConsensusStateResponse is the response type for the Query/ConsensusState
RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.client.v1.QueryConsensusStatesResponse

<a id="schemaibc.core.client.v1.queryconsensusstatesresponse"></a>
<a id="schema_ibc.core.client.v1.QueryConsensusStatesResponse"></a>
<a id="tocSibc.core.client.v1.queryconsensusstatesresponse"></a>
<a id="tocsibc.core.client.v1.queryconsensusstatesresponse"></a>

```json
{
  "consensus_states": [
    {
      "height": {
        "revision_number": "string",
        "revision_height": "string"
      },
      "consensus_state": {
        "type_url": "string",
        "value": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryConsensusStatesResponse is the response type for the
Query/ConsensusStates RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|consensus_states|[object]|false|none|none|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|
|» consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## ibc.core.client.v1.QueryUpgradedClientStateResponse

<a id="schemaibc.core.client.v1.queryupgradedclientstateresponse"></a>
<a id="schema_ibc.core.client.v1.QueryUpgradedClientStateResponse"></a>
<a id="tocSibc.core.client.v1.queryupgradedclientstateresponse"></a>
<a id="tocsibc.core.client.v1.queryupgradedclientstateresponse"></a>

```json
{
  "upgraded_client_state": {
    "type_url": "string",
    "value": "string"
  }
}

```

QueryUpgradedClientStateResponse is the response type for the
Query/UpgradedClientState RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|upgraded_client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## ibc.core.client.v1.QueryUpgradedConsensusStateResponse

<a id="schemaibc.core.client.v1.queryupgradedconsensusstateresponse"></a>
<a id="schema_ibc.core.client.v1.QueryUpgradedConsensusStateResponse"></a>
<a id="tocSibc.core.client.v1.queryupgradedconsensusstateresponse"></a>
<a id="tocsibc.core.client.v1.queryupgradedconsensusstateresponse"></a>

```json
{
  "upgraded_consensus_state": {
    "type_url": "string",
    "value": "string"
  }
}

```

QueryUpgradedConsensusStateResponse is the response type for the
Query/UpgradedConsensusState RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|upgraded_consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## ibc.core.client.v1.QueryVerifyMembershipRequest

<a id="schemaibc.core.client.v1.queryverifymembershiprequest"></a>
<a id="schema_ibc.core.client.v1.QueryVerifyMembershipRequest"></a>
<a id="tocSibc.core.client.v1.queryverifymembershiprequest"></a>
<a id="tocsibc.core.client.v1.queryverifymembershiprequest"></a>

```json
{
  "client_id": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  },
  "merkle_path": {
    "key_path": [
      "string"
    ]
  },
  "value": "string",
  "time_delay": "string",
  "block_delay": "string"
}

```

QueryVerifyMembershipRequest is the request type for the Query/VerifyMembership RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|client_id|string|false|none|client unique identifier.|
|proof|string(byte)|false|none|the proof to be verified by the client.|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|
|merkle_path|object|false|none|the commitment key path.|
|» key_path|[string]|false|none|none|
|value|string(byte)|false|none|the value which is proven.|
|time_delay|string(uint64)|false|none|none|
|block_delay|string(uint64)|false|none|none|

## ibc.core.client.v1.QueryVerifyMembershipResponse

<a id="schemaibc.core.client.v1.queryverifymembershipresponse"></a>
<a id="schema_ibc.core.client.v1.QueryVerifyMembershipResponse"></a>
<a id="tocSibc.core.client.v1.queryverifymembershipresponse"></a>
<a id="tocsibc.core.client.v1.queryverifymembershipresponse"></a>

```json
{
  "success": true
}

```

QueryVerifyMembershipResponse is the response type for the Query/VerifyMembership RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|success|boolean|false|none|boolean indicating success or failure of proof verification.|

## ibc.core.commitment.v1.MerklePath

<a id="schemaibc.core.commitment.v1.merklepath"></a>
<a id="schema_ibc.core.commitment.v1.MerklePath"></a>
<a id="tocSibc.core.commitment.v1.merklepath"></a>
<a id="tocsibc.core.commitment.v1.merklepath"></a>

```json
{
  "key_path": [
    "string"
  ]
}

```

MerklePath is the path used to verify commitment proofs, which can be an
arbitrary structured object (defined by a commitment type).
MerklePath is represented from root-to-leaf

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|key_path|[string]|false|none|none|

## ibc.core.commitment.v1.MerklePrefix

<a id="schemaibc.core.commitment.v1.merkleprefix"></a>
<a id="schema_ibc.core.commitment.v1.MerklePrefix"></a>
<a id="tocSibc.core.commitment.v1.merkleprefix"></a>
<a id="tocsibc.core.commitment.v1.merkleprefix"></a>

```json
{
  "key_prefix": "string"
}

```

MerklePrefix is merkle path prefixed to the key.
The constructed key from the Path and the key will be append(Path.KeyPath,
append(Path.KeyPrefix, key...))

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|key_prefix|string(byte)|false|none|none|

## ibc.core.connection.v1.ConnectionEnd

<a id="schemaibc.core.connection.v1.connectionend"></a>
<a id="schema_ibc.core.connection.v1.ConnectionEnd"></a>
<a id="tocSibc.core.connection.v1.connectionend"></a>
<a id="tocsibc.core.connection.v1.connectionend"></a>

```json
{
  "client_id": "string",
  "versions": [
    {
      "identifier": "string",
      "features": [
        "string"
      ]
    }
  ],
  "state": "STATE_UNINITIALIZED_UNSPECIFIED",
  "counterparty": {
    "client_id": "string",
    "connection_id": "string",
    "prefix": {
      "key_prefix": "string"
    }
  },
  "delay_period": "string"
}

```

ConnectionEnd defines a stateful object on a chain connected to another
separate one.
NOTE: there must only be 2 defined ConnectionEnds to establish
a connection between two chains.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|client_id|string|false|none|client associated with this connection.|
|versions|[object]|false|none|IBC version which can be utilised to determine encodings or protocols for<br />channels or packets utilising this connection.|
|» identifier|string|false|none|none|
|» features|[string]|false|none|none|
|state|string|false|none|current state of the connection end.|
|counterparty|object|false|none|counterparty chain associated with this connection.|
|» client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|» connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|» prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|»» key_prefix|string(byte)|false|none|none|
|delay_period|string(uint64)|false|none|delay period that must pass before a consensus state can be used for<br />packet-verification NOTE: delay period logic is only implemented by some<br />clients.|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|

## ibc.core.connection.v1.Counterparty

<a id="schemaibc.core.connection.v1.counterparty"></a>
<a id="schema_ibc.core.connection.v1.Counterparty"></a>
<a id="tocSibc.core.connection.v1.counterparty"></a>
<a id="tocsibc.core.connection.v1.counterparty"></a>

```json
{
  "client_id": "string",
  "connection_id": "string",
  "prefix": {
    "key_prefix": "string"
  }
}

```

Counterparty defines the counterparty chain associated with a connection end.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|» key_prefix|string(byte)|false|none|none|

## ibc.core.connection.v1.IdentifiedConnection

<a id="schemaibc.core.connection.v1.identifiedconnection"></a>
<a id="schema_ibc.core.connection.v1.IdentifiedConnection"></a>
<a id="tocSibc.core.connection.v1.identifiedconnection"></a>
<a id="tocsibc.core.connection.v1.identifiedconnection"></a>

```json
{
  "id": "string",
  "client_id": "string",
  "versions": [
    {
      "identifier": "string",
      "features": [
        "string"
      ]
    }
  ],
  "state": "STATE_UNINITIALIZED_UNSPECIFIED",
  "counterparty": {
    "client_id": "string",
    "connection_id": "string",
    "prefix": {
      "key_prefix": "string"
    }
  },
  "delay_period": "string"
}

```

IdentifiedConnection defines a connection with additional connection
identifier field.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|id|string|false|none|connection identifier.|
|client_id|string|false|none|client associated with this connection.|
|versions|[object]|false|none|none|
|» identifier|string|false|none|none|
|» features|[string]|false|none|none|
|state|string|false|none|current state of the connection end.|
|counterparty|object|false|none|counterparty chain associated with this connection.|
|» client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|» connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|» prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|»» key_prefix|string(byte)|false|none|none|
|delay_period|string(uint64)|false|none|delay period associated with this connection.|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|

## ibc.core.connection.v1.Params

<a id="schemaibc.core.connection.v1.params"></a>
<a id="schema_ibc.core.connection.v1.Params"></a>
<a id="tocSibc.core.connection.v1.params"></a>
<a id="tocsibc.core.connection.v1.params"></a>

```json
{
  "max_expected_time_per_block": "string"
}

```

Params defines the set of Connection parameters.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|max_expected_time_per_block|string(uint64)|false|none|maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the<br />largest amount of time that the chain might reasonably take to produce the next block under normal operating<br />conditions. A safe choice is 3-5x the expected time per block.|

## ibc.core.connection.v1.QueryClientConnectionsResponse

<a id="schemaibc.core.connection.v1.queryclientconnectionsresponse"></a>
<a id="schema_ibc.core.connection.v1.QueryClientConnectionsResponse"></a>
<a id="tocSibc.core.connection.v1.queryclientconnectionsresponse"></a>
<a id="tocsibc.core.connection.v1.queryclientconnectionsresponse"></a>

```json
{
  "connection_paths": [
    "string"
  ],
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryClientConnectionsResponse is the response type for the
Query/ClientConnections RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|connection_paths|[string]|false|none|slice of all the connection paths associated with a client.|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.connection.v1.QueryConnectionClientStateResponse

<a id="schemaibc.core.connection.v1.queryconnectionclientstateresponse"></a>
<a id="schema_ibc.core.connection.v1.QueryConnectionClientStateResponse"></a>
<a id="tocSibc.core.connection.v1.queryconnectionclientstateresponse"></a>
<a id="tocsibc.core.connection.v1.queryconnectionclientstateresponse"></a>

```json
{
  "identified_client_state": {
    "client_id": "string",
    "client_state": {
      "type_url": "string",
      "value": "string"
    }
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryConnectionClientStateResponse is the response type for the
Query/ConnectionClientState RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|identified_client_state|object|false|none|IdentifiedClientState defines a client state with an additional client<br />identifier field.|
|» client_id|string|false|none|none|
|» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.connection.v1.QueryConnectionConsensusStateResponse

<a id="schemaibc.core.connection.v1.queryconnectionconsensusstateresponse"></a>
<a id="schema_ibc.core.connection.v1.QueryConnectionConsensusStateResponse"></a>
<a id="tocSibc.core.connection.v1.queryconnectionconsensusstateresponse"></a>
<a id="tocsibc.core.connection.v1.queryconnectionconsensusstateresponse"></a>

```json
{
  "consensus_state": {
    "type_url": "string",
    "value": "string"
  },
  "client_id": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryConnectionConsensusStateResponse is the response type for the
Query/ConnectionConsensusState RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|client_id|string|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.connection.v1.QueryConnectionParamsResponse

<a id="schemaibc.core.connection.v1.queryconnectionparamsresponse"></a>
<a id="schema_ibc.core.connection.v1.QueryConnectionParamsResponse"></a>
<a id="tocSibc.core.connection.v1.queryconnectionparamsresponse"></a>
<a id="tocsibc.core.connection.v1.queryconnectionparamsresponse"></a>

```json
{
  "params": {
    "max_expected_time_per_block": "string"
  }
}

```

QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» max_expected_time_per_block|string(uint64)|false|none|maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the<br />largest amount of time that the chain might reasonably take to produce the next block under normal operating<br />conditions. A safe choice is 3-5x the expected time per block.|

## ibc.core.connection.v1.QueryConnectionResponse

<a id="schemaibc.core.connection.v1.queryconnectionresponse"></a>
<a id="schema_ibc.core.connection.v1.QueryConnectionResponse"></a>
<a id="tocSibc.core.connection.v1.queryconnectionresponse"></a>
<a id="tocsibc.core.connection.v1.queryconnectionresponse"></a>

```json
{
  "connection": {
    "client_id": "string",
    "versions": [
      {
        "identifier": "string",
        "features": [
          "string"
        ]
      }
    ],
    "state": "STATE_UNINITIALIZED_UNSPECIFIED",
    "counterparty": {
      "client_id": "string",
      "connection_id": "string",
      "prefix": {
        "key_prefix": "string"
      }
    },
    "delay_period": "string"
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryConnectionResponse is the response type for the Query/Connection RPC
method. Besides the connection end, it includes a proof and the height from
which the proof was retrieved.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|connection|object|false|none|ConnectionEnd defines a stateful object on a chain connected to another<br />separate one.<br />NOTE: there must only be 2 defined ConnectionEnds to establish<br />a connection between two chains.|
|» client_id|string|false|none|client associated with this connection.|
|» versions|[object]|false|none|IBC version which can be utilised to determine encodings or protocols for<br />channels or packets utilising this connection.|
|»» identifier|string|false|none|none|
|»» features|[string]|false|none|none|
|» state|string|false|none|current state of the connection end.|
|» counterparty|object|false|none|counterparty chain associated with this connection.|
|»» client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|»» connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|»» prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|»»» key_prefix|string(byte)|false|none|none|
|» delay_period|string(uint64)|false|none|delay period that must pass before a consensus state can be used for<br />packet-verification NOTE: delay period logic is only implemented by some<br />clients.|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|

## ibc.core.connection.v1.QueryConnectionsResponse

<a id="schemaibc.core.connection.v1.queryconnectionsresponse"></a>
<a id="schema_ibc.core.connection.v1.QueryConnectionsResponse"></a>
<a id="tocSibc.core.connection.v1.queryconnectionsresponse"></a>
<a id="tocsibc.core.connection.v1.queryconnectionsresponse"></a>

```json
{
  "connections": [
    {
      "id": "string",
      "client_id": "string",
      "versions": [
        {
          "identifier": "string",
          "features": [
            "string"
          ]
        }
      ],
      "state": "STATE_UNINITIALIZED_UNSPECIFIED",
      "counterparty": {
        "client_id": "string",
        "connection_id": "string",
        "prefix": {
          "key_prefix": "string"
        }
      },
      "delay_period": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  },
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryConnectionsResponse is the response type for the Query/Connections RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|connections|[object]|false|none|list of stored connections of the chain.|
|» id|string|false|none|connection identifier.|
|» client_id|string|false|none|client associated with this connection.|
|» versions|[object]|false|none|none|
|»» identifier|string|false|none|none|
|»» features|[string]|false|none|none|
|» state|string|false|none|current state of the connection end.|
|» counterparty|object|false|none|counterparty chain associated with this connection.|
|»» client_id|string|false|none|identifies the client on the counterparty chain associated with a given<br />connection.|
|»» connection_id|string|false|none|identifies the connection end on the counterparty chain associated with a<br />given connection.|
|»» prefix|object|false|none|commitment merkle prefix of the counterparty chain.|
|»»» key_prefix|string(byte)|false|none|none|
|» delay_period|string(uint64)|false|none|delay period associated with this connection.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|

## ibc.core.connection.v1.State

<a id="schemaibc.core.connection.v1.state"></a>
<a id="schema_ibc.core.connection.v1.State"></a>
<a id="tocSibc.core.connection.v1.state"></a>
<a id="tocsibc.core.connection.v1.state"></a>

```json
"STATE_UNINITIALIZED_UNSPECIFIED"

```

State defines if a connection is in one of the following states:
INIT, TRYOPEN, OPEN or UNINITIALIZED.

 - STATE_UNINITIALIZED_UNSPECIFIED: Default State
 - STATE_INIT: A connection end has just started the opening handshake.
 - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty
chain.
 - STATE_OPEN: A connection end has completed the handshake.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|State defines if a connection is in one of the following states:<br />INIT, TRYOPEN, OPEN or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A connection end has just started the opening handshake.<br /> - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty<br />chain.<br /> - STATE_OPEN: A connection end has completed the handshake.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|STATE_UNINITIALIZED_UNSPECIFIED|
|*anonymous*|STATE_INIT|
|*anonymous*|STATE_TRYOPEN|
|*anonymous*|STATE_OPEN|

## ibc.core.connection.v1.Version

<a id="schemaibc.core.connection.v1.version"></a>
<a id="schema_ibc.core.connection.v1.Version"></a>
<a id="tocSibc.core.connection.v1.version"></a>
<a id="tocsibc.core.connection.v1.version"></a>

```json
{
  "identifier": "string",
  "features": [
    "string"
  ]
}

```

Version defines the versioning scheme used to negotiate the IBC version in
the connection handshake.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|identifier|string|false|none|none|
|features|[string]|false|none|none|

## ibc.core.channel.v1.Channel

<a id="schemaibc.core.channel.v1.channel"></a>
<a id="schema_ibc.core.channel.v1.Channel"></a>
<a id="tocSibc.core.channel.v1.channel"></a>
<a id="tocsibc.core.channel.v1.channel"></a>

```json
{
  "state": "STATE_UNINITIALIZED_UNSPECIFIED",
  "ordering": "ORDER_NONE_UNSPECIFIED",
  "counterparty": {
    "port_id": "string",
    "channel_id": "string"
  },
  "connection_hops": [
    "string"
  ],
  "version": "string",
  "upgrade_sequence": "string"
}

```

Channel defines pipeline for exactly-once packet delivery between specific
modules on separate blockchains, which has at least one end capable of
sending packets and one end capable of receiving packets.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|counterparty|object|false|none|none|
|» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|» channel_id|string|false|none|none|
|connection_hops|[string]|false|none|none|
|version|string|false|none|none|
|upgrade_sequence|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.Counterparty

<a id="schemaibc.core.channel.v1.counterparty"></a>
<a id="schema_ibc.core.channel.v1.Counterparty"></a>
<a id="tocSibc.core.channel.v1.counterparty"></a>
<a id="tocsibc.core.channel.v1.counterparty"></a>

```json
{
  "port_id": "string",
  "channel_id": "string"
}

```

Counterparty defines a channel end counterparty

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|channel_id|string|false|none|none|

## ibc.core.channel.v1.ErrorReceipt

<a id="schemaibc.core.channel.v1.errorreceipt"></a>
<a id="schema_ibc.core.channel.v1.ErrorReceipt"></a>
<a id="tocSibc.core.channel.v1.errorreceipt"></a>
<a id="tocsibc.core.channel.v1.errorreceipt"></a>

```json
{
  "sequence": "string",
  "message": "string"
}

```

ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the
upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the
next sequence.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|sequence|string(uint64)|false|none|none|
|message|string|false|none|none|

## ibc.core.channel.v1.IdentifiedChannel

<a id="schemaibc.core.channel.v1.identifiedchannel"></a>
<a id="schema_ibc.core.channel.v1.IdentifiedChannel"></a>
<a id="tocSibc.core.channel.v1.identifiedchannel"></a>
<a id="tocsibc.core.channel.v1.identifiedchannel"></a>

```json
{
  "state": "STATE_UNINITIALIZED_UNSPECIFIED",
  "ordering": "ORDER_NONE_UNSPECIFIED",
  "counterparty": {
    "port_id": "string",
    "channel_id": "string"
  },
  "connection_hops": [
    "string"
  ],
  "version": "string",
  "port_id": "string",
  "channel_id": "string",
  "upgrade_sequence": "string"
}

```

IdentifiedChannel defines a channel with additional port and channel
identifier fields.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|counterparty|object|false|none|none|
|» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|» channel_id|string|false|none|none|
|connection_hops|[string]|false|none|none|
|version|string|false|none|none|
|port_id|string|false|none|none|
|channel_id|string|false|none|none|
|upgrade_sequence|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.Order

<a id="schemaibc.core.channel.v1.order"></a>
<a id="schema_ibc.core.channel.v1.Order"></a>
<a id="tocSibc.core.channel.v1.order"></a>
<a id="tocsibc.core.channel.v1.order"></a>

```json
"ORDER_NONE_UNSPECIFIED"

```

Order defines if a channel is ORDERED or UNORDERED

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|Order defines if a channel is ORDERED or UNORDERED|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|

#### Enumerated Values

|Property|Value|
|---|---|
|Order defines if a channel is ORDERED or UNORDERED|ORDER_NONE_UNSPECIFIED|
|Order defines if a channel is ORDERED or UNORDERED|ORDER_UNORDERED|
|Order defines if a channel is ORDERED or UNORDERED|ORDER_ORDERED|

## ibc.core.channel.v1.PacketState

<a id="schemaibc.core.channel.v1.packetstate"></a>
<a id="schema_ibc.core.channel.v1.PacketState"></a>
<a id="tocSibc.core.channel.v1.packetstate"></a>
<a id="tocsibc.core.channel.v1.packetstate"></a>

```json
{
  "port_id": "string",
  "channel_id": "string",
  "sequence": "string",
  "data": "string"
}

```

PacketState defines the generic type necessary to retrieve and store
packet commitments, acknowledgements, and receipts.
Caller is responsible for knowing the context necessary to interpret this
state as a commitment, acknowledgement, or a receipt.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|port_id|string|false|none|channel port identifier.|
|channel_id|string|false|none|channel unique identifier.|
|sequence|string(uint64)|false|none|packet sequence.|
|data|string(byte)|false|none|embedded data that represents packet state.|

## ibc.core.channel.v1.Params

<a id="schemaibc.core.channel.v1.params"></a>
<a id="schema_ibc.core.channel.v1.Params"></a>
<a id="tocSibc.core.channel.v1.params"></a>
<a id="tocsibc.core.channel.v1.params"></a>

```json
{
  "upgrade_timeout": {
    "height": {
      "revision_number": "string",
      "revision_height": "string"
    },
    "timestamp": "string"
  }
}

```

Params defines the set of IBC channel parameters.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|upgrade_timeout|object|false|none|Timeout defines an execution deadline structure for 04-channel handlers.<br />This includes packet lifecycle handlers as well as the upgrade handshake handlers.<br />A valid Timeout contains either one or both of a timestamp and block height (sequence).|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|
|» timestamp|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryChannelClientStateResponse

<a id="schemaibc.core.channel.v1.querychannelclientstateresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryChannelClientStateResponse"></a>
<a id="tocSibc.core.channel.v1.querychannelclientstateresponse"></a>
<a id="tocsibc.core.channel.v1.querychannelclientstateresponse"></a>

```json
{
  "identified_client_state": {
    "client_id": "string",
    "client_state": {
      "type_url": "string",
      "value": "string"
    }
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|identified_client_state|object|false|none|IdentifiedClientState defines a client state with an additional client<br />identifier field.|
|» client_id|string|false|none|none|
|» client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryChannelConsensusStateResponse

<a id="schemaibc.core.channel.v1.querychannelconsensusstateresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryChannelConsensusStateResponse"></a>
<a id="tocSibc.core.channel.v1.querychannelconsensusstateresponse"></a>
<a id="tocsibc.core.channel.v1.querychannelconsensusstateresponse"></a>

```json
{
  "consensus_state": {
    "type_url": "string",
    "value": "string"
  },
  "client_id": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|consensus_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|client_id|string|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryChannelParamsResponse

<a id="schemaibc.core.channel.v1.querychannelparamsresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryChannelParamsResponse"></a>
<a id="tocSibc.core.channel.v1.querychannelparamsresponse"></a>
<a id="tocsibc.core.channel.v1.querychannelparamsresponse"></a>

```json
{
  "params": {
    "upgrade_timeout": {
      "height": {
        "revision_number": "string",
        "revision_height": "string"
      },
      "timestamp": "string"
    }
  }
}

```

QueryChannelParamsResponse is the response type for the Query/ChannelParams RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» upgrade_timeout|object|false|none|Timeout defines an execution deadline structure for 04-channel handlers.<br />This includes packet lifecycle handlers as well as the upgrade handshake handlers.<br />A valid Timeout contains either one or both of a timestamp and block height (sequence).|
|»» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»»» revision_number|string(uint64)|false|none|none|
|»»» revision_height|string(uint64)|false|none|none|
|»» timestamp|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryChannelResponse

<a id="schemaibc.core.channel.v1.querychannelresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryChannelResponse"></a>
<a id="tocSibc.core.channel.v1.querychannelresponse"></a>
<a id="tocsibc.core.channel.v1.querychannelresponse"></a>

```json
{
  "channel": {
    "state": "STATE_UNINITIALIZED_UNSPECIFIED",
    "ordering": "ORDER_NONE_UNSPECIFIED",
    "counterparty": {
      "port_id": "string",
      "channel_id": "string"
    },
    "connection_hops": [
      "string"
    ],
    "version": "string",
    "upgrade_sequence": "string"
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryChannelResponse is the response type for the Query/Channel RPC method.
Besides the Channel end, it includes a proof and the height from which the
proof was retrieved.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|channel|object|false|none|Channel defines pipeline for exactly-once packet delivery between specific<br />modules on separate blockchains, which has at least one end capable of<br />sending packets and one end capable of receiving packets.|
|» state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|» counterparty|object|false|none|none|
|»» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|»» channel_id|string|false|none|none|
|» connection_hops|[string]|false|none|none|
|» version|string|false|none|none|
|» upgrade_sequence|string(uint64)|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.QueryChannelsResponse

<a id="schemaibc.core.channel.v1.querychannelsresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryChannelsResponse"></a>
<a id="tocSibc.core.channel.v1.querychannelsresponse"></a>
<a id="tocsibc.core.channel.v1.querychannelsresponse"></a>

```json
{
  "channels": [
    {
      "state": "STATE_UNINITIALIZED_UNSPECIFIED",
      "ordering": "ORDER_NONE_UNSPECIFIED",
      "counterparty": {
        "port_id": "string",
        "channel_id": "string"
      },
      "connection_hops": [
        "string"
      ],
      "version": "string",
      "port_id": "string",
      "channel_id": "string",
      "upgrade_sequence": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  },
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryChannelsResponse is the response type for the Query/Channels RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|channels|[object]|false|none|list of stored channels of the chain.|
|» state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|» counterparty|object|false|none|none|
|»» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|»» channel_id|string|false|none|none|
|» connection_hops|[string]|false|none|none|
|» version|string|false|none|none|
|» port_id|string|false|none|none|
|» channel_id|string|false|none|none|
|» upgrade_sequence|string(uint64)|false|none|none|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.QueryConnectionChannelsResponse

<a id="schemaibc.core.channel.v1.queryconnectionchannelsresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryConnectionChannelsResponse"></a>
<a id="tocSibc.core.channel.v1.queryconnectionchannelsresponse"></a>
<a id="tocsibc.core.channel.v1.queryconnectionchannelsresponse"></a>

```json
{
  "channels": [
    {
      "state": "STATE_UNINITIALIZED_UNSPECIFIED",
      "ordering": "ORDER_NONE_UNSPECIFIED",
      "counterparty": {
        "port_id": "string",
        "channel_id": "string"
      },
      "connection_hops": [
        "string"
      ],
      "version": "string",
      "port_id": "string",
      "channel_id": "string",
      "upgrade_sequence": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  },
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryConnectionChannelsResponse is the Response type for the
Query/QueryConnectionChannels RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|channels|[object]|false|none|list of channels associated with a connection.|
|» state|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|
|» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|» counterparty|object|false|none|none|
|»» port_id|string|false|none|port on the counterparty chain which owns the other end of the channel.|
|»» channel_id|string|false|none|none|
|» connection_hops|[string]|false|none|none|
|» version|string|false|none|none|
|» port_id|string|false|none|none|
|» channel_id|string|false|none|none|
|» upgrade_sequence|string(uint64)|false|none|none|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|state|STATE_UNINITIALIZED_UNSPECIFIED|
|state|STATE_INIT|
|state|STATE_TRYOPEN|
|state|STATE_OPEN|
|state|STATE_CLOSED|
|state|STATE_FLUSHING|
|state|STATE_FLUSHCOMPLETE|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.QueryNextSequenceReceiveResponse

<a id="schemaibc.core.channel.v1.querynextsequencereceiveresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryNextSequenceReceiveResponse"></a>
<a id="tocSibc.core.channel.v1.querynextsequencereceiveresponse"></a>
<a id="tocsibc.core.channel.v1.querynextsequencereceiveresponse"></a>

```json
{
  "next_sequence_receive": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QuerySequenceResponse is the response type for the
Query/QueryNextSequenceReceiveResponse RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|next_sequence_receive|string(uint64)|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryNextSequenceSendResponse

<a id="schemaibc.core.channel.v1.querynextsequencesendresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryNextSequenceSendResponse"></a>
<a id="tocSibc.core.channel.v1.querynextsequencesendresponse"></a>
<a id="tocsibc.core.channel.v1.querynextsequencesendresponse"></a>

```json
{
  "next_sequence_send": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryNextSequenceSendResponse is the request type for the
Query/QueryNextSequenceSend RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|next_sequence_send|string(uint64)|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryPacketAcknowledgementResponse

<a id="schemaibc.core.channel.v1.querypacketacknowledgementresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryPacketAcknowledgementResponse"></a>
<a id="tocSibc.core.channel.v1.querypacketacknowledgementresponse"></a>
<a id="tocsibc.core.channel.v1.querypacketacknowledgementresponse"></a>

```json
{
  "acknowledgement": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryPacketAcknowledgementResponse defines the client query response for a
packet which also includes a proof and the height from which the
proof was retrieved

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|acknowledgement|string(byte)|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryPacketAcknowledgementsResponse

<a id="schemaibc.core.channel.v1.querypacketacknowledgementsresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryPacketAcknowledgementsResponse"></a>
<a id="tocSibc.core.channel.v1.querypacketacknowledgementsresponse"></a>
<a id="tocsibc.core.channel.v1.querypacketacknowledgementsresponse"></a>

```json
{
  "acknowledgements": [
    {
      "port_id": "string",
      "channel_id": "string",
      "sequence": "string",
      "data": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  },
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryPacketAcknowledgemetsResponse is the request type for the
Query/QueryPacketAcknowledgements RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|acknowledgements|[object]|false|none|none|
|» port_id|string|false|none|channel port identifier.|
|» channel_id|string|false|none|channel unique identifier.|
|» sequence|string(uint64)|false|none|packet sequence.|
|» data|string(byte)|false|none|embedded data that represents packet state.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryPacketCommitmentResponse

<a id="schemaibc.core.channel.v1.querypacketcommitmentresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryPacketCommitmentResponse"></a>
<a id="tocSibc.core.channel.v1.querypacketcommitmentresponse"></a>
<a id="tocsibc.core.channel.v1.querypacketcommitmentresponse"></a>

```json
{
  "commitment": "string",
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryPacketCommitmentResponse defines the client query response for a packet
which also includes a proof and the height from which the proof was
retrieved

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|commitment|string(byte)|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryPacketCommitmentsResponse

<a id="schemaibc.core.channel.v1.querypacketcommitmentsresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryPacketCommitmentsResponse"></a>
<a id="tocSibc.core.channel.v1.querypacketcommitmentsresponse"></a>
<a id="tocsibc.core.channel.v1.querypacketcommitmentsresponse"></a>

```json
{
  "commitments": [
    {
      "port_id": "string",
      "channel_id": "string",
      "sequence": "string",
      "data": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  },
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryPacketCommitmentsResponse is the request type for the
Query/QueryPacketCommitments RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|commitments|[object]|false|none|none|
|» port_id|string|false|none|channel port identifier.|
|» channel_id|string|false|none|channel unique identifier.|
|» sequence|string(uint64)|false|none|packet sequence.|
|» data|string(byte)|false|none|embedded data that represents packet state.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryPacketReceiptResponse

<a id="schemaibc.core.channel.v1.querypacketreceiptresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryPacketReceiptResponse"></a>
<a id="tocSibc.core.channel.v1.querypacketreceiptresponse"></a>
<a id="tocsibc.core.channel.v1.querypacketreceiptresponse"></a>

```json
{
  "received": true,
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryPacketReceiptResponse defines the client query response for a packet
receipt which also includes a proof, and the height from which the proof was
retrieved

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|received|boolean|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryUnreceivedAcksResponse

<a id="schemaibc.core.channel.v1.queryunreceivedacksresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryUnreceivedAcksResponse"></a>
<a id="tocSibc.core.channel.v1.queryunreceivedacksresponse"></a>
<a id="tocsibc.core.channel.v1.queryunreceivedacksresponse"></a>

```json
{
  "sequences": [
    "string"
  ],
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryUnreceivedAcksResponse is the response type for the
Query/UnreceivedAcks RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|sequences|[string]|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryUnreceivedPacketsResponse

<a id="schemaibc.core.channel.v1.queryunreceivedpacketsresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryUnreceivedPacketsResponse"></a>
<a id="tocSibc.core.channel.v1.queryunreceivedpacketsresponse"></a>
<a id="tocsibc.core.channel.v1.queryunreceivedpacketsresponse"></a>

```json
{
  "sequences": [
    "string"
  ],
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryUnreceivedPacketsResponse is the response type for the
Query/UnreceivedPacketCommitments RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|sequences|[string]|false|none|none|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryUpgradeErrorResponse

<a id="schemaibc.core.channel.v1.queryupgradeerrorresponse"></a>
<a id="schema_ibc.core.channel.v1.QueryUpgradeErrorResponse"></a>
<a id="tocSibc.core.channel.v1.queryupgradeerrorresponse"></a>
<a id="tocsibc.core.channel.v1.queryupgradeerrorresponse"></a>

```json
{
  "error_receipt": {
    "sequence": "string",
    "message": "string"
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryUpgradeErrorResponse is the response type for the Query/QueryUpgradeError RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|error_receipt|object|false|none|ErrorReceipt defines a type which encapsulates the upgrade sequence and error associated with the<br />upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the<br />next sequence.|
|» sequence|string(uint64)|false|none|none|
|» message|string|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

## ibc.core.channel.v1.QueryUpgradeResponse

<a id="schemaibc.core.channel.v1.queryupgraderesponse"></a>
<a id="schema_ibc.core.channel.v1.QueryUpgradeResponse"></a>
<a id="tocSibc.core.channel.v1.queryupgraderesponse"></a>
<a id="tocsibc.core.channel.v1.queryupgraderesponse"></a>

```json
{
  "upgrade": {
    "fields": {
      "ordering": "ORDER_NONE_UNSPECIFIED",
      "connection_hops": [
        "string"
      ],
      "version": "string"
    },
    "timeout": {
      "height": {
        "revision_number": "string",
        "revision_height": "string"
      },
      "timestamp": "string"
    },
    "next_sequence_send": "string"
  },
  "proof": "string",
  "proof_height": {
    "revision_number": "string",
    "revision_height": "string"
  }
}

```

QueryUpgradeResponse is the response type for the QueryUpgradeResponse RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|upgrade|object|false|none|Upgrade is a verifiable type which contains the relevant information<br />for an attempted upgrade. It provides the proposed changes to the channel<br />end, the timeout for this upgrade attempt and the next packet sequence<br />which allows the counterparty to efficiently know the highest sequence it has received.<br />The next sequence send is used for pruning and upgrading from unordered to ordered channels.|
|» fields|object|false|none|UpgradeFields are the fields in a channel end which may be changed<br />during a channel upgrade.|
|»» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|»» connection_hops|[string]|false|none|none|
|»» version|string|false|none|none|
|» timeout|object|false|none|Timeout defines an execution deadline structure for 04-channel handlers.<br />This includes packet lifecycle handlers as well as the upgrade handshake handlers.<br />A valid Timeout contains either one or both of a timestamp and block height (sequence).|
|»» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»»» revision_number|string(uint64)|false|none|none|
|»»» revision_height|string(uint64)|false|none|none|
|»» timestamp|string(uint64)|false|none|none|
|» next_sequence_send|string(uint64)|false|none|none|
|proof|string(byte)|false|none|none|
|proof_height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.State

<a id="schemaibc.core.channel.v1.state"></a>
<a id="schema_ibc.core.channel.v1.State"></a>
<a id="tocSibc.core.channel.v1.state"></a>
<a id="tocsibc.core.channel.v1.state"></a>

```json
"STATE_UNINITIALIZED_UNSPECIFIED"

```

State defines if a channel is in one of the following states:
CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.

 - STATE_UNINITIALIZED_UNSPECIFIED: Default State
 - STATE_INIT: A channel has just started the opening handshake.
 - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
 - STATE_OPEN: A channel has completed the handshake. Open channels are
ready to send and receive packets.
 - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
packets.
 - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
 - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|State defines if a channel is in one of the following states:<br />CLOSED, INIT, TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.<br /><br /> - STATE_UNINITIALIZED_UNSPECIFIED: Default State<br /> - STATE_INIT: A channel has just started the opening handshake.<br /> - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.<br /> - STATE_OPEN: A channel has completed the handshake. Open channels are<br />ready to send and receive packets.<br /> - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive<br />packets.<br /> - STATE_FLUSHING: A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.<br /> - STATE_FLUSHCOMPLETE: A channel has just completed flushing any in-flight packets.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|STATE_UNINITIALIZED_UNSPECIFIED|
|*anonymous*|STATE_INIT|
|*anonymous*|STATE_TRYOPEN|
|*anonymous*|STATE_OPEN|
|*anonymous*|STATE_CLOSED|
|*anonymous*|STATE_FLUSHING|
|*anonymous*|STATE_FLUSHCOMPLETE|

## ibc.core.channel.v1.Timeout

<a id="schemaibc.core.channel.v1.timeout"></a>
<a id="schema_ibc.core.channel.v1.Timeout"></a>
<a id="tocSibc.core.channel.v1.timeout"></a>
<a id="tocsibc.core.channel.v1.timeout"></a>

```json
{
  "height": {
    "revision_number": "string",
    "revision_height": "string"
  },
  "timestamp": "string"
}

```

Timeout defines an execution deadline structure for 04-channel handlers.
This includes packet lifecycle handlers as well as the upgrade handshake handlers.
A valid Timeout contains either one or both of a timestamp and block height (sequence).

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|» revision_number|string(uint64)|false|none|none|
|» revision_height|string(uint64)|false|none|none|
|timestamp|string(uint64)|false|none|none|

## ibc.core.channel.v1.Upgrade

<a id="schemaibc.core.channel.v1.upgrade"></a>
<a id="schema_ibc.core.channel.v1.Upgrade"></a>
<a id="tocSibc.core.channel.v1.upgrade"></a>
<a id="tocsibc.core.channel.v1.upgrade"></a>

```json
{
  "fields": {
    "ordering": "ORDER_NONE_UNSPECIFIED",
    "connection_hops": [
      "string"
    ],
    "version": "string"
  },
  "timeout": {
    "height": {
      "revision_number": "string",
      "revision_height": "string"
    },
    "timestamp": "string"
  },
  "next_sequence_send": "string"
}

```

Upgrade is a verifiable type which contains the relevant information
for an attempted upgrade. It provides the proposed changes to the channel
end, the timeout for this upgrade attempt and the next packet sequence
which allows the counterparty to efficiently know the highest sequence it has received.
The next sequence send is used for pruning and upgrading from unordered to ordered channels.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|fields|object|false|none|UpgradeFields are the fields in a channel end which may be changed<br />during a channel upgrade.|
|» ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|» connection_hops|[string]|false|none|none|
|» version|string|false|none|none|
|timeout|object|false|none|Timeout defines an execution deadline structure for 04-channel handlers.<br />This includes packet lifecycle handlers as well as the upgrade handshake handlers.<br />A valid Timeout contains either one or both of a timestamp and block height (sequence).|
|» height|object|false|none|Normally the RevisionHeight is incremented at each height while keeping<br />RevisionNumber the same. However some consensus algorithms may choose to<br />reset the height in certain conditions e.g. hard forks, state-machine<br />breaking changes In these cases, the RevisionNumber is incremented so that<br />height continues to be monitonically increasing even as the RevisionHeight<br />gets reset|
|»» revision_number|string(uint64)|false|none|none|
|»» revision_height|string(uint64)|false|none|none|
|» timestamp|string(uint64)|false|none|none|
|next_sequence_send|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## ibc.core.channel.v1.UpgradeFields

<a id="schemaibc.core.channel.v1.upgradefields"></a>
<a id="schema_ibc.core.channel.v1.UpgradeFields"></a>
<a id="tocSibc.core.channel.v1.upgradefields"></a>
<a id="tocsibc.core.channel.v1.upgradefields"></a>

```json
{
  "ordering": "ORDER_NONE_UNSPECIFIED",
  "connection_hops": [
    "string"
  ],
  "version": "string"
}

```

UpgradeFields are the fields in a channel end which may be changed
during a channel upgrade.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ordering|string|false|none|- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering<br /> - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in<br />which they were sent.<br /> - ORDER_ORDERED: packets are delivered exactly in the order which they were sent|
|connection_hops|[string]|false|none|none|
|version|string|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|ordering|ORDER_NONE_UNSPECIFIED|
|ordering|ORDER_UNORDERED|
|ordering|ORDER_ORDERED|

## cosmos.auth.v1beta1.AddressBytesToStringResponse

<a id="schemacosmos.auth.v1beta1.addressbytestostringresponse"></a>
<a id="schema_cosmos.auth.v1beta1.AddressBytesToStringResponse"></a>
<a id="tocScosmos.auth.v1beta1.addressbytestostringresponse"></a>
<a id="tocscosmos.auth.v1beta1.addressbytestostringresponse"></a>

```json
{
  "address_string": "string"
}

```

AddressBytesToStringResponse is the response type for AddressString rpc method.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address_string|string|false|none|none|

## cosmos.auth.v1beta1.AddressStringToBytesResponse

<a id="schemacosmos.auth.v1beta1.addressstringtobytesresponse"></a>
<a id="schema_cosmos.auth.v1beta1.AddressStringToBytesResponse"></a>
<a id="tocScosmos.auth.v1beta1.addressstringtobytesresponse"></a>
<a id="tocscosmos.auth.v1beta1.addressstringtobytesresponse"></a>

```json
{
  "address_bytes": "string"
}

```

AddressStringToBytesResponse is the response type for AddressBytes rpc method.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address_bytes|string(byte)|false|none|none|

## cosmos.auth.v1beta1.BaseAccount

<a id="schemacosmos.auth.v1beta1.baseaccount"></a>
<a id="schema_cosmos.auth.v1beta1.BaseAccount"></a>
<a id="tocScosmos.auth.v1beta1.baseaccount"></a>
<a id="tocscosmos.auth.v1beta1.baseaccount"></a>

```json
{
  "address": "string",
  "pub_key": {
    "type_url": "string",
    "value": "string"
  },
  "account_number": "string",
  "sequence": "string"
}

```

BaseAccount defines a base account type. It contains all the necessary fields
for basic account functionality. Any custom account type should extend this
type for additional functionality (e.g. vesting).

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|
|pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|account_number|string(uint64)|false|none|none|
|sequence|string(uint64)|false|none|none|

## cosmos.auth.v1beta1.Bech32PrefixResponse

<a id="schemacosmos.auth.v1beta1.bech32prefixresponse"></a>
<a id="schema_cosmos.auth.v1beta1.Bech32PrefixResponse"></a>
<a id="tocScosmos.auth.v1beta1.bech32prefixresponse"></a>
<a id="tocscosmos.auth.v1beta1.bech32prefixresponse"></a>

```json
{
  "bech32_prefix": "string"
}

```

Bech32PrefixResponse is the response type for Bech32Prefix rpc method.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bech32_prefix|string|false|none|none|

## cosmos.auth.v1beta1.Params

<a id="schemacosmos.auth.v1beta1.params"></a>
<a id="schema_cosmos.auth.v1beta1.Params"></a>
<a id="tocScosmos.auth.v1beta1.params"></a>
<a id="tocscosmos.auth.v1beta1.params"></a>

```json
{
  "max_memo_characters": "string",
  "tx_sig_limit": "string",
  "tx_size_cost_per_byte": "string",
  "sig_verify_cost_ed25519": "string",
  "sig_verify_cost_secp256k1": "string"
}

```

Params defines the parameters for the auth module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|max_memo_characters|string(uint64)|false|none|none|
|tx_sig_limit|string(uint64)|false|none|none|
|tx_size_cost_per_byte|string(uint64)|false|none|none|
|sig_verify_cost_ed25519|string(uint64)|false|none|none|
|sig_verify_cost_secp256k1|string(uint64)|false|none|none|

## cosmos.auth.v1beta1.QueryAccountAddressByIDResponse

<a id="schemacosmos.auth.v1beta1.queryaccountaddressbyidresponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryAccountAddressByIDResponse"></a>
<a id="tocScosmos.auth.v1beta1.queryaccountaddressbyidresponse"></a>
<a id="tocscosmos.auth.v1beta1.queryaccountaddressbyidresponse"></a>

```json
{
  "account_address": "string"
}

```

QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|account_address|string|false|none|none|

## cosmos.auth.v1beta1.QueryAccountInfoResponse

<a id="schemacosmos.auth.v1beta1.queryaccountinforesponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryAccountInfoResponse"></a>
<a id="tocScosmos.auth.v1beta1.queryaccountinforesponse"></a>
<a id="tocscosmos.auth.v1beta1.queryaccountinforesponse"></a>

```json
{
  "info": {
    "address": "string",
    "pub_key": {
      "type_url": "string",
      "value": "string"
    },
    "account_number": "string",
    "sequence": "string"
  }
}

```

QueryAccountInfoResponse is the Query/AccountInfo response type.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|object|false|none|info is the account info which is represented by BaseAccount.|
|» address|string|false|none|none|
|» pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» account_number|string(uint64)|false|none|none|
|» sequence|string(uint64)|false|none|none|

## cosmos.auth.v1beta1.QueryAccountResponse

<a id="schemacosmos.auth.v1beta1.queryaccountresponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryAccountResponse"></a>
<a id="tocScosmos.auth.v1beta1.queryaccountresponse"></a>
<a id="tocscosmos.auth.v1beta1.queryaccountresponse"></a>

```json
{
  "account": {
    "type_url": "string",
    "value": "string"
  }
}

```

QueryAccountResponse is the response type for the Query/Account RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|account|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.auth.v1beta1.QueryAccountsResponse

<a id="schemacosmos.auth.v1beta1.queryaccountsresponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryAccountsResponse"></a>
<a id="tocScosmos.auth.v1beta1.queryaccountsresponse"></a>
<a id="tocscosmos.auth.v1beta1.queryaccountsresponse"></a>

```json
{
  "accounts": [
    {
      "type_url": "string",
      "value": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAccountsResponse is the response type for the Query/Accounts RPC method.

Since: cosmos-sdk 0.43

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|accounts|[object]|false|none|none|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.auth.v1beta1.QueryModuleAccountByNameResponse

<a id="schemacosmos.auth.v1beta1.querymoduleaccountbynameresponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryModuleAccountByNameResponse"></a>
<a id="tocScosmos.auth.v1beta1.querymoduleaccountbynameresponse"></a>
<a id="tocscosmos.auth.v1beta1.querymoduleaccountbynameresponse"></a>

```json
{
  "account": {
    "type_url": "string",
    "value": "string"
  }
}

```

QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|account|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.auth.v1beta1.QueryModuleAccountsResponse

<a id="schemacosmos.auth.v1beta1.querymoduleaccountsresponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryModuleAccountsResponse"></a>
<a id="tocScosmos.auth.v1beta1.querymoduleaccountsresponse"></a>
<a id="tocscosmos.auth.v1beta1.querymoduleaccountsresponse"></a>

```json
{
  "accounts": [
    {
      "type_url": "string",
      "value": "string"
    }
  ]
}

```

QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|accounts|[object]|false|none|none|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.auth.v1beta1.QueryParamsResponse

<a id="schemacosmos.auth.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.auth.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.auth.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.auth.v1beta1.queryparamsresponse"></a>

```json
{
  "params": {
    "max_memo_characters": "string",
    "tx_sig_limit": "string",
    "tx_size_cost_per_byte": "string",
    "sig_verify_cost_ed25519": "string",
    "sig_verify_cost_secp256k1": "string"
  }
}

```

QueryParamsResponse is the response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» max_memo_characters|string(uint64)|false|none|none|
|» tx_sig_limit|string(uint64)|false|none|none|
|» tx_size_cost_per_byte|string(uint64)|false|none|none|
|» sig_verify_cost_ed25519|string(uint64)|false|none|none|
|» sig_verify_cost_secp256k1|string(uint64)|false|none|none|

## cosmos.authz.v1beta1.Grant

<a id="schemacosmos.authz.v1beta1.grant"></a>
<a id="schema_cosmos.authz.v1beta1.Grant"></a>
<a id="tocScosmos.authz.v1beta1.grant"></a>
<a id="tocscosmos.authz.v1beta1.grant"></a>

```json
{
  "authorization": {
    "type_url": "string",
    "value": "string"
  },
  "expiration": "2019-08-24T14:15:22Z"
}

```

Grant gives permissions to execute
the provide method with expiration time.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|expiration|string(date-time)|false|none|none|

## cosmos.authz.v1beta1.GrantAuthorization

<a id="schemacosmos.authz.v1beta1.grantauthorization"></a>
<a id="schema_cosmos.authz.v1beta1.GrantAuthorization"></a>
<a id="tocScosmos.authz.v1beta1.grantauthorization"></a>
<a id="tocscosmos.authz.v1beta1.grantauthorization"></a>

```json
{
  "granter": "string",
  "grantee": "string",
  "authorization": {
    "type_url": "string",
    "value": "string"
  },
  "expiration": "2019-08-24T14:15:22Z"
}

```

GrantAuthorization extends a grant with both the addresses of the grantee and granter.
It is used in genesis.proto and query.proto

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|granter|string|false|none|none|
|grantee|string|false|none|none|
|authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|expiration|string(date-time)|false|none|none|

## cosmos.authz.v1beta1.QueryGranteeGrantsResponse

<a id="schemacosmos.authz.v1beta1.querygranteegrantsresponse"></a>
<a id="schema_cosmos.authz.v1beta1.QueryGranteeGrantsResponse"></a>
<a id="tocScosmos.authz.v1beta1.querygranteegrantsresponse"></a>
<a id="tocscosmos.authz.v1beta1.querygranteegrantsresponse"></a>

```json
{
  "grants": [
    {
      "granter": "string",
      "grantee": "string",
      "authorization": {
        "type_url": "string",
        "value": "string"
      },
      "expiration": "2019-08-24T14:15:22Z"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|grants|[object]|false|none|grants is a list of grants granted to the grantee.|
|» GrantAuthorization extends a grant with both the addresses of the grantee and granter.
It is used in genesis.proto and query.proto|object|false|none|none|
|»» granter|string|false|none|none|
|»» grantee|string|false|none|none|
|»» authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» expiration|string(date-time)|false|none|none|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.authz.v1beta1.QueryGranterGrantsResponse

<a id="schemacosmos.authz.v1beta1.querygrantergrantsresponse"></a>
<a id="schema_cosmos.authz.v1beta1.QueryGranterGrantsResponse"></a>
<a id="tocScosmos.authz.v1beta1.querygrantergrantsresponse"></a>
<a id="tocscosmos.authz.v1beta1.querygrantergrantsresponse"></a>

```json
{
  "grants": [
    {
      "granter": "string",
      "grantee": "string",
      "authorization": {
        "type_url": "string",
        "value": "string"
      },
      "expiration": "2019-08-24T14:15:22Z"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|grants|[object]|false|none|grants is a list of grants granted by the granter.|
|» GrantAuthorization extends a grant with both the addresses of the grantee and granter.
It is used in genesis.proto and query.proto|object|false|none|none|
|»» granter|string|false|none|none|
|»» grantee|string|false|none|none|
|»» authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» expiration|string(date-time)|false|none|none|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.authz.v1beta1.QueryGrantsResponse

<a id="schemacosmos.authz.v1beta1.querygrantsresponse"></a>
<a id="schema_cosmos.authz.v1beta1.QueryGrantsResponse"></a>
<a id="tocScosmos.authz.v1beta1.querygrantsresponse"></a>
<a id="tocscosmos.authz.v1beta1.querygrantsresponse"></a>

```json
{
  "grants": [
    {
      "authorization": {
        "type_url": "string",
        "value": "string"
      },
      "expiration": "2019-08-24T14:15:22Z"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryGrantsResponse is the response type for the Query/Authorizations RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|grants|[object]|false|none|authorizations is a list of grants granted for grantee by granter.|
|» authorization|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» expiration|string(date-time)|false|none|none|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.DenomOwner

<a id="schemacosmos.bank.v1beta1.denomowner"></a>
<a id="schema_cosmos.bank.v1beta1.DenomOwner"></a>
<a id="tocScosmos.bank.v1beta1.denomowner"></a>
<a id="tocscosmos.bank.v1beta1.denomowner"></a>

```json
{
  "address": "string",
  "balance": {
    "denom": "string",
    "amount": "string"
  }
}

```

DenomOwner defines structure representing an account that owns or holds a
particular denominated token. It contains the account address and account
balance of the denominated token.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|address defines the address that owns a particular denomination.|
|balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.bank.v1beta1.DenomUnit

<a id="schemacosmos.bank.v1beta1.denomunit"></a>
<a id="schema_cosmos.bank.v1beta1.DenomUnit"></a>
<a id="tocScosmos.bank.v1beta1.denomunit"></a>
<a id="tocscosmos.bank.v1beta1.denomunit"></a>

```json
{
  "denom": "string",
  "exponent": 0,
  "aliases": [
    "string"
  ]
}

```

DenomUnit represents a struct that describes a given
denomination unit of the basic token.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|aliases|[string]|false|none|none|

## cosmos.bank.v1beta1.Metadata

<a id="schemacosmos.bank.v1beta1.metadata"></a>
<a id="schema_cosmos.bank.v1beta1.Metadata"></a>
<a id="tocScosmos.bank.v1beta1.metadata"></a>
<a id="tocscosmos.bank.v1beta1.metadata"></a>

```json
{
  "description": "string",
  "denom_units": [
    {
      "denom": "string",
      "exponent": 0,
      "aliases": [
        "string"
      ]
    }
  ],
  "base": "string",
  "display": "string",
  "name": "string",
  "symbol": "string",
  "uri": "string",
  "uri_hash": "string"
}

```

Metadata represents a struct that describes
a basic token.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|description|string|false|none|none|
|denom_units|[object]|false|none|none|
|» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|» aliases|[string]|false|none|none|
|base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|name|string|false|none|Since: cosmos-sdk 0.43|
|symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|

## cosmos.bank.v1beta1.Params

<a id="schemacosmos.bank.v1beta1.params"></a>
<a id="schema_cosmos.bank.v1beta1.Params"></a>
<a id="tocScosmos.bank.v1beta1.params"></a>
<a id="tocscosmos.bank.v1beta1.params"></a>

```json
{
  "send_enabled": [
    {
      "denom": "string",
      "enabled": true
    }
  ],
  "default_send_enabled": true
}

```

Params defines the parameters for the bank module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|send_enabled|[object]|false|none|Deprecated: Use of SendEnabled in params is deprecated.<br />For genesis, use the newly added send_enabled field in the genesis object.<br />Storage, lookup, and manipulation of this information is now in the keeper.<br /><br />As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.|
|» denom|string|false|none|none|
|» enabled|boolean|false|none|none|
|default_send_enabled|boolean|false|none|none|

## cosmos.bank.v1beta1.QueryAllBalancesResponse

<a id="schemacosmos.bank.v1beta1.queryallbalancesresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryAllBalancesResponse"></a>
<a id="tocScosmos.bank.v1beta1.queryallbalancesresponse"></a>
<a id="tocscosmos.bank.v1beta1.queryallbalancesresponse"></a>

```json
{
  "balances": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|balances|[object]|false|none|balances is the balances of all the coins.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.QueryBalanceResponse

<a id="schemacosmos.bank.v1beta1.querybalanceresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryBalanceResponse"></a>
<a id="tocScosmos.bank.v1beta1.querybalanceresponse"></a>
<a id="tocscosmos.bank.v1beta1.querybalanceresponse"></a>

```json
{
  "balance": {
    "denom": "string",
    "amount": "string"
  }
}

```

QueryBalanceResponse is the response type for the Query/Balance RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse

<a id="schemacosmos.bank.v1beta1.querydenommetadatabyquerystringresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse"></a>
<a id="tocScosmos.bank.v1beta1.querydenommetadatabyquerystringresponse"></a>
<a id="tocscosmos.bank.v1beta1.querydenommetadatabyquerystringresponse"></a>

```json
{
  "metadata": {
    "description": "string",
    "denom_units": [
      {
        "denom": "string",
        "exponent": 0,
        "aliases": [
          "string"
        ]
      }
    ],
    "base": "string",
    "display": "string",
    "name": "string",
    "symbol": "string",
    "uri": "string",
    "uri_hash": "string"
  }
}

```

QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC
method. Identical with QueryDenomMetadataResponse but receives denom as query string in request.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metadata|object|false|none|Metadata represents a struct that describes<br />a basic token.|
|» description|string|false|none|none|
|» denom_units|[object]|false|none|none|
|»» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|»» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|»» aliases|[string]|false|none|none|
|» base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|» display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|» name|string|false|none|Since: cosmos-sdk 0.43|
|» symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|» uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|» uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|

## cosmos.bank.v1beta1.QueryDenomMetadataResponse

<a id="schemacosmos.bank.v1beta1.querydenommetadataresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryDenomMetadataResponse"></a>
<a id="tocScosmos.bank.v1beta1.querydenommetadataresponse"></a>
<a id="tocscosmos.bank.v1beta1.querydenommetadataresponse"></a>

```json
{
  "metadata": {
    "description": "string",
    "denom_units": [
      {
        "denom": "string",
        "exponent": 0,
        "aliases": [
          "string"
        ]
      }
    ],
    "base": "string",
    "display": "string",
    "name": "string",
    "symbol": "string",
    "uri": "string",
    "uri_hash": "string"
  }
}

```

QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metadata|object|false|none|Metadata represents a struct that describes<br />a basic token.|
|» description|string|false|none|none|
|» denom_units|[object]|false|none|none|
|»» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|»» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|»» aliases|[string]|false|none|none|
|» base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|» display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|» name|string|false|none|Since: cosmos-sdk 0.43|
|» symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|» uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|» uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|

## cosmos.bank.v1beta1.QueryDenomOwnersResponse

<a id="schemacosmos.bank.v1beta1.querydenomownersresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryDenomOwnersResponse"></a>
<a id="tocScosmos.bank.v1beta1.querydenomownersresponse"></a>
<a id="tocscosmos.bank.v1beta1.querydenomownersresponse"></a>

```json
{
  "denom_owners": [
    {
      "address": "string",
      "balance": {
        "denom": "string",
        "amount": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom_owners|[object]|false|none|none|
|» address|string|false|none|address defines the address that owns a particular denomination.|
|» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.QueryDenomsMetadataResponse

<a id="schemacosmos.bank.v1beta1.querydenomsmetadataresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryDenomsMetadataResponse"></a>
<a id="tocScosmos.bank.v1beta1.querydenomsmetadataresponse"></a>
<a id="tocscosmos.bank.v1beta1.querydenomsmetadataresponse"></a>

```json
{
  "metadatas": [
    {
      "description": "string",
      "denom_units": [
        {
          "denom": "string",
          "exponent": 0,
          "aliases": [
            "string"
          ]
        }
      ],
      "base": "string",
      "display": "string",
      "name": "string",
      "symbol": "string",
      "uri": "string",
      "uri_hash": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|metadatas|[object]|false|none|metadata provides the client information for all the registered tokens.|
|» description|string|false|none|none|
|» denom_units|[object]|false|none|none|
|»» denom|string|false|none|denom represents the string name of the given denom unit (e.g uatom).|
|»» exponent|integer(int64)|false|none|exponent represents power of 10 exponent that one must<br />raise the base_denom to in order to equal the given DenomUnit's denom<br />1 denom = 10^exponent base_denom<br />(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with<br />exponent = 6, thus: 1 atom = 10^6 uatom).|
|»» aliases|[string]|false|none|none|
|» base|string|false|none|base represents the base denom (should be the DenomUnit with exponent = 0).|
|» display|string|false|none|display indicates the suggested denom that should be<br />displayed in clients.|
|» name|string|false|none|Since: cosmos-sdk 0.43|
|» symbol|string|false|none|symbol is the token symbol usually shown on exchanges (eg: ATOM). This can<br />be the same as the display.<br /><br />Since: cosmos-sdk 0.43|
|» uri|string|false|none|URI to a document (on or off-chain) that contains additional information. Optional.<br /><br />Since: cosmos-sdk 0.46|
|» uri_hash|string|false|none|URIHash is a sha256 hash of a document pointed by URI. It's used to verify that<br />the document didn't change. Optional.<br /><br />Since: cosmos-sdk 0.46|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.QueryParamsResponse

<a id="schemacosmos.bank.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.bank.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.bank.v1beta1.queryparamsresponse"></a>

```json
{
  "params": {
    "send_enabled": [
      {
        "denom": "string",
        "enabled": true
      }
    ],
    "default_send_enabled": true
  }
}

```

QueryParamsResponse defines the response type for querying x/bank parameters.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params provides the parameters of the bank module.|
|» send_enabled|[object]|false|none|Deprecated: Use of SendEnabled in params is deprecated.<br />For genesis, use the newly added send_enabled field in the genesis object.<br />Storage, lookup, and manipulation of this information is now in the keeper.<br /><br />As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.|
|»» denom|string|false|none|none|
|»» enabled|boolean|false|none|none|
|» default_send_enabled|boolean|false|none|none|

## cosmos.bank.v1beta1.QuerySendEnabledResponse

<a id="schemacosmos.bank.v1beta1.querysendenabledresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QuerySendEnabledResponse"></a>
<a id="tocScosmos.bank.v1beta1.querysendenabledresponse"></a>
<a id="tocscosmos.bank.v1beta1.querysendenabledresponse"></a>

```json
{
  "send_enabled": [
    {
      "denom": "string",
      "enabled": true
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QuerySendEnabledResponse defines the RPC response of a SendEnable query.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|send_enabled|[object]|false|none|none|
|» denom|string|false|none|none|
|» enabled|boolean|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response. This field is only<br />populated if the denoms field in the request is empty.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse

<a id="schemacosmos.bank.v1beta1.queryspendablebalancebydenomresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse"></a>
<a id="tocScosmos.bank.v1beta1.queryspendablebalancebydenomresponse"></a>
<a id="tocscosmos.bank.v1beta1.queryspendablebalancebydenomresponse"></a>

```json
{
  "balance": {
    "denom": "string",
    "amount": "string"
  }
}

```

QuerySpendableBalanceByDenomResponse defines the gRPC response structure for
querying an account's spendable balance for a specific denom.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.bank.v1beta1.QuerySpendableBalancesResponse

<a id="schemacosmos.bank.v1beta1.queryspendablebalancesresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QuerySpendableBalancesResponse"></a>
<a id="tocScosmos.bank.v1beta1.queryspendablebalancesresponse"></a>
<a id="tocscosmos.bank.v1beta1.queryspendablebalancesresponse"></a>

```json
{
  "balances": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QuerySpendableBalancesResponse defines the gRPC response structure for querying
an account's spendable balances.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|balances|[object]|false|none|balances is the spendable balances of all the coins.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.QuerySupplyOfResponse

<a id="schemacosmos.bank.v1beta1.querysupplyofresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QuerySupplyOfResponse"></a>
<a id="tocScosmos.bank.v1beta1.querysupplyofresponse"></a>
<a id="tocscosmos.bank.v1beta1.querysupplyofresponse"></a>

```json
{
  "amount": {
    "denom": "string",
    "amount": "string"
  }
}

```

QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amount|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.bank.v1beta1.QueryTotalSupplyResponse

<a id="schemacosmos.bank.v1beta1.querytotalsupplyresponse"></a>
<a id="schema_cosmos.bank.v1beta1.QueryTotalSupplyResponse"></a>
<a id="tocScosmos.bank.v1beta1.querytotalsupplyresponse"></a>
<a id="tocscosmos.bank.v1beta1.querytotalsupplyresponse"></a>

```json
{
  "supply": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|supply|[object]|false|none|none|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.<br /><br />Since: cosmos-sdk 0.43|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.bank.v1beta1.SendEnabled

<a id="schemacosmos.bank.v1beta1.sendenabled"></a>
<a id="schema_cosmos.bank.v1beta1.SendEnabled"></a>
<a id="tocScosmos.bank.v1beta1.sendenabled"></a>
<a id="tocscosmos.bank.v1beta1.sendenabled"></a>

```json
{
  "denom": "string",
  "enabled": true
}

```

SendEnabled maps coin denom to a send_enabled status (whether a denom is
sendable).

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom|string|false|none|none|
|enabled|boolean|false|none|none|

## cosmos.base.v1beta1.DecCoin

<a id="schemacosmos.base.v1beta1.deccoin"></a>
<a id="schema_cosmos.base.v1beta1.DecCoin"></a>
<a id="tocScosmos.base.v1beta1.deccoin"></a>
<a id="tocscosmos.base.v1beta1.deccoin"></a>

```json
{
  "denom": "string",
  "amount": "string"
}

```

DecCoin defines a token with a denomination and a decimal amount.

NOTE: The amount field is an Dec which implements the custom method
signatures required by gogoproto.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|denom|string|false|none|none|
|amount|string|false|none|none|

## cosmos.distribution.v1beta1.DelegationDelegatorReward

<a id="schemacosmos.distribution.v1beta1.delegationdelegatorreward"></a>
<a id="schema_cosmos.distribution.v1beta1.DelegationDelegatorReward"></a>
<a id="tocScosmos.distribution.v1beta1.delegationdelegatorreward"></a>
<a id="tocscosmos.distribution.v1beta1.delegationdelegatorreward"></a>

```json
{
  "validator_address": "string",
  "reward": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

DelegationDelegatorReward represents the properties
of a delegator's delegation reward.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validator_address|string|false|none|none|
|reward|[object]|false|none|none|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.Params

<a id="schemacosmos.distribution.v1beta1.params"></a>
<a id="schema_cosmos.distribution.v1beta1.Params"></a>
<a id="tocScosmos.distribution.v1beta1.params"></a>
<a id="tocscosmos.distribution.v1beta1.params"></a>

```json
{
  "community_tax": "string",
  "base_proposer_reward": "string",
  "bonus_proposer_reward": "string",
  "withdraw_addr_enabled": true
}

```

Params defines the set of params for the distribution module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|community_tax|string|false|none|none|
|base_proposer_reward|string|false|none|Deprecated: The base_proposer_reward field is deprecated and is no longer used<br />in the x/distribution module's reward mechanism.|
|bonus_proposer_reward|string|false|none|Deprecated: The bonus_proposer_reward field is deprecated and is no longer used<br />in the x/distribution module's reward mechanism.|
|withdraw_addr_enabled|boolean|false|none|none|

## cosmos.distribution.v1beta1.QueryCommunityPoolResponse

<a id="schemacosmos.distribution.v1beta1.querycommunitypoolresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryCommunityPoolResponse"></a>
<a id="tocScosmos.distribution.v1beta1.querycommunitypoolresponse"></a>
<a id="tocscosmos.distribution.v1beta1.querycommunitypoolresponse"></a>

```json
{
  "pool": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

QueryCommunityPoolResponse is the response type for the Query/CommunityPool
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|pool|[object]|false|none|pool defines community pool's coins.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.QueryDelegationRewardsResponse

<a id="schemacosmos.distribution.v1beta1.querydelegationrewardsresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryDelegationRewardsResponse"></a>
<a id="tocScosmos.distribution.v1beta1.querydelegationrewardsresponse"></a>
<a id="tocscosmos.distribution.v1beta1.querydelegationrewardsresponse"></a>

```json
{
  "rewards": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

QueryDelegationRewardsResponse is the response type for the
Query/DelegationRewards RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|rewards|[object]|false|none|rewards defines the rewards accrued by a delegation.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse

<a id="schemacosmos.distribution.v1beta1.querydelegationtotalrewardsresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse"></a>
<a id="tocScosmos.distribution.v1beta1.querydelegationtotalrewardsresponse"></a>
<a id="tocscosmos.distribution.v1beta1.querydelegationtotalrewardsresponse"></a>

```json
{
  "rewards": [
    {
      "validator_address": "string",
      "reward": [
        {
          "denom": "string",
          "amount": "string"
        }
      ]
    }
  ],
  "total": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

QueryDelegationTotalRewardsResponse is the response type for the
Query/DelegationTotalRewards RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|rewards|[object]|false|none|rewards defines all the rewards accrued by a delegator.|
|» validator_address|string|false|none|none|
|» reward|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|total|[object]|false|none|total defines the sum of all the rewards.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse

<a id="schemacosmos.distribution.v1beta1.querydelegatorvalidatorsresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse"></a>
<a id="tocScosmos.distribution.v1beta1.querydelegatorvalidatorsresponse"></a>
<a id="tocscosmos.distribution.v1beta1.querydelegatorvalidatorsresponse"></a>

```json
{
  "validators": [
    "string"
  ]
}

```

QueryDelegatorValidatorsResponse is the response type for the
Query/DelegatorValidators RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validators|[string]|false|none|validators defines the validators a delegator is delegating for.|

## cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse

<a id="schemacosmos.distribution.v1beta1.querydelegatorwithdrawaddressresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse"></a>
<a id="tocScosmos.distribution.v1beta1.querydelegatorwithdrawaddressresponse"></a>
<a id="tocscosmos.distribution.v1beta1.querydelegatorwithdrawaddressresponse"></a>

```json
{
  "withdraw_address": "string"
}

```

QueryDelegatorWithdrawAddressResponse is the response type for the
Query/DelegatorWithdrawAddress RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|withdraw_address|string|false|none|withdraw_address defines the delegator address to query for.|

## cosmos.distribution.v1beta1.QueryParamsResponse

<a id="schemacosmos.distribution.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.distribution.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.distribution.v1beta1.queryparamsresponse"></a>

```json
{
  "params": {
    "community_tax": "string",
    "base_proposer_reward": "string",
    "bonus_proposer_reward": "string",
    "withdraw_addr_enabled": true
  }
}

```

QueryParamsResponse is the response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» community_tax|string|false|none|none|
|» base_proposer_reward|string|false|none|Deprecated: The base_proposer_reward field is deprecated and is no longer used<br />in the x/distribution module's reward mechanism.|
|» bonus_proposer_reward|string|false|none|Deprecated: The bonus_proposer_reward field is deprecated and is no longer used<br />in the x/distribution module's reward mechanism.|
|» withdraw_addr_enabled|boolean|false|none|none|

## cosmos.distribution.v1beta1.QueryValidatorCommissionResponse

<a id="schemacosmos.distribution.v1beta1.queryvalidatorcommissionresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryValidatorCommissionResponse"></a>
<a id="tocScosmos.distribution.v1beta1.queryvalidatorcommissionresponse"></a>
<a id="tocscosmos.distribution.v1beta1.queryvalidatorcommissionresponse"></a>

```json
{
  "commission": {
    "commission": [
      {
        "denom": "string",
        "amount": "string"
      }
    ]
  }
}

```

QueryValidatorCommissionResponse is the response type for the
Query/ValidatorCommission RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|commission|object|false|none|commission defines the commission the validator received.|
|» commission|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

## cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse

<a id="schemacosmos.distribution.v1beta1.queryvalidatordistributioninforesponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse"></a>
<a id="tocScosmos.distribution.v1beta1.queryvalidatordistributioninforesponse"></a>
<a id="tocscosmos.distribution.v1beta1.queryvalidatordistributioninforesponse"></a>

```json
{
  "operator_address": "string",
  "self_bond_rewards": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "commission": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|operator_address|string|false|none|operator_address defines the validator operator address.|
|self_bond_rewards|[object]|false|none|self_bond_rewards defines the self delegations rewards.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|commission|[object]|false|none|commission defines the commission the validator received.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse

<a id="schemacosmos.distribution.v1beta1.queryvalidatoroutstandingrewardsresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse"></a>
<a id="tocScosmos.distribution.v1beta1.queryvalidatoroutstandingrewardsresponse"></a>
<a id="tocscosmos.distribution.v1beta1.queryvalidatoroutstandingrewardsresponse"></a>

```json
{
  "rewards": {
    "rewards": [
      {
        "denom": "string",
        "amount": "string"
      }
    ]
  }
}

```

QueryValidatorOutstandingRewardsResponse is the response type for the
Query/ValidatorOutstandingRewards RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|rewards|object|false|none|ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards<br />for a validator inexpensive to track, allows simple sanity checks.|
|» rewards|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

## cosmos.distribution.v1beta1.QueryValidatorSlashesResponse

<a id="schemacosmos.distribution.v1beta1.queryvalidatorslashesresponse"></a>
<a id="schema_cosmos.distribution.v1beta1.QueryValidatorSlashesResponse"></a>
<a id="tocScosmos.distribution.v1beta1.queryvalidatorslashesresponse"></a>
<a id="tocscosmos.distribution.v1beta1.queryvalidatorslashesresponse"></a>

```json
{
  "slashes": [
    {
      "validator_period": "string",
      "fraction": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryValidatorSlashesResponse is the response type for the
Query/ValidatorSlashes RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|slashes|[object]|false|none|slashes defines the slashes the validator received.|
|» validator_period|string(uint64)|false|none|none|
|» fraction|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.distribution.v1beta1.ValidatorAccumulatedCommission

<a id="schemacosmos.distribution.v1beta1.validatoraccumulatedcommission"></a>
<a id="schema_cosmos.distribution.v1beta1.ValidatorAccumulatedCommission"></a>
<a id="tocScosmos.distribution.v1beta1.validatoraccumulatedcommission"></a>
<a id="tocscosmos.distribution.v1beta1.validatoraccumulatedcommission"></a>

```json
{
  "commission": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

ValidatorAccumulatedCommission represents accumulated commission
for a validator kept as a running counter, can be withdrawn at any time.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|commission|[object]|false|none|none|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.ValidatorOutstandingRewards

<a id="schemacosmos.distribution.v1beta1.validatoroutstandingrewards"></a>
<a id="schema_cosmos.distribution.v1beta1.ValidatorOutstandingRewards"></a>
<a id="tocScosmos.distribution.v1beta1.validatoroutstandingrewards"></a>
<a id="tocscosmos.distribution.v1beta1.validatoroutstandingrewards"></a>

```json
{
  "rewards": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
for a validator inexpensive to track, allows simple sanity checks.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|rewards|[object]|false|none|none|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.distribution.v1beta1.ValidatorSlashEvent

<a id="schemacosmos.distribution.v1beta1.validatorslashevent"></a>
<a id="schema_cosmos.distribution.v1beta1.ValidatorSlashEvent"></a>
<a id="tocScosmos.distribution.v1beta1.validatorslashevent"></a>
<a id="tocscosmos.distribution.v1beta1.validatorslashevent"></a>

```json
{
  "validator_period": "string",
  "fraction": "string"
}

```

ValidatorSlashEvent represents a validator slash event.
Height is implicit within the store key.
This is needed to calculate appropriate amount of staking tokens
for delegations which are withdrawn after a slash has occurred.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validator_period|string(uint64)|false|none|none|
|fraction|string|false|none|none|

## cosmos.evidence.v1beta1.QueryAllEvidenceResponse

<a id="schemacosmos.evidence.v1beta1.queryallevidenceresponse"></a>
<a id="schema_cosmos.evidence.v1beta1.QueryAllEvidenceResponse"></a>
<a id="tocScosmos.evidence.v1beta1.queryallevidenceresponse"></a>
<a id="tocscosmos.evidence.v1beta1.queryallevidenceresponse"></a>

```json
{
  "evidence": [
    {
      "type_url": "string",
      "value": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|evidence|[object]|false|none|evidence returns all evidences.|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.evidence.v1beta1.QueryEvidenceResponse

<a id="schemacosmos.evidence.v1beta1.queryevidenceresponse"></a>
<a id="schema_cosmos.evidence.v1beta1.QueryEvidenceResponse"></a>
<a id="tocScosmos.evidence.v1beta1.queryevidenceresponse"></a>
<a id="tocscosmos.evidence.v1beta1.queryevidenceresponse"></a>

```json
{
  "evidence": {
    "type_url": "string",
    "value": "string"
  }
}

```

QueryEvidenceResponse is the response type for the Query/Evidence RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|evidence|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.feegrant.v1beta1.Grant

<a id="schemacosmos.feegrant.v1beta1.grant"></a>
<a id="schema_cosmos.feegrant.v1beta1.Grant"></a>
<a id="tocScosmos.feegrant.v1beta1.grant"></a>
<a id="tocscosmos.feegrant.v1beta1.grant"></a>

```json
{
  "granter": "string",
  "grantee": "string",
  "allowance": {
    "type_url": "string",
    "value": "string"
  }
}

```

Grant is stored in the KVStore to record a grant with full context

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.feegrant.v1beta1.QueryAllowanceResponse

<a id="schemacosmos.feegrant.v1beta1.queryallowanceresponse"></a>
<a id="schema_cosmos.feegrant.v1beta1.QueryAllowanceResponse"></a>
<a id="tocScosmos.feegrant.v1beta1.queryallowanceresponse"></a>
<a id="tocscosmos.feegrant.v1beta1.queryallowanceresponse"></a>

```json
{
  "allowance": {
    "granter": "string",
    "grantee": "string",
    "allowance": {
      "type_url": "string",
      "value": "string"
    }
  }
}

```

QueryAllowanceResponse is the response type for the Query/Allowance RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|allowance|object|false|none|allowance is a allowance granted for grantee by granter.|
|» granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|» grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|» allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse

<a id="schemacosmos.feegrant.v1beta1.queryallowancesbygranterresponse"></a>
<a id="schema_cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse"></a>
<a id="tocScosmos.feegrant.v1beta1.queryallowancesbygranterresponse"></a>
<a id="tocscosmos.feegrant.v1beta1.queryallowancesbygranterresponse"></a>

```json
{
  "allowances": [
    {
      "granter": "string",
      "grantee": "string",
      "allowance": {
        "type_url": "string",
        "value": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|allowances|[object]|false|none|allowances that have been issued by the granter.|
|» Grant is stored in the KVStore to record a grant with full context|object|false|none|none|
|»» granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|»» grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|»» allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.feegrant.v1beta1.QueryAllowancesResponse

<a id="schemacosmos.feegrant.v1beta1.queryallowancesresponse"></a>
<a id="schema_cosmos.feegrant.v1beta1.QueryAllowancesResponse"></a>
<a id="tocScosmos.feegrant.v1beta1.queryallowancesresponse"></a>
<a id="tocscosmos.feegrant.v1beta1.queryallowancesresponse"></a>

```json
{
  "allowances": [
    {
      "granter": "string",
      "grantee": "string",
      "allowance": {
        "type_url": "string",
        "value": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryAllowancesResponse is the response type for the Query/Allowances RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|allowances|[object]|false|none|allowances are allowance's granted for grantee by granter.|
|» Grant is stored in the KVStore to record a grant with full context|object|false|none|none|
|»» granter|string|false|none|granter is the address of the user granting an allowance of their funds.|
|»» grantee|string|false|none|grantee is the address of the user being granted an allowance of another user's funds.|
|»» allowance|object|false|none|allowance can be any of basic, periodic, allowed fee allowance.|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.gov.v1beta1.Deposit

<a id="schemacosmos.gov.v1beta1.deposit"></a>
<a id="schema_cosmos.gov.v1beta1.Deposit"></a>
<a id="tocScosmos.gov.v1beta1.deposit"></a>
<a id="tocscosmos.gov.v1beta1.deposit"></a>

```json
{
  "proposal_id": "string",
  "depositor": "string",
  "amount": [
    {
      "denom": "string",
      "amount": "string"
    }
  ]
}

```

Deposit defines an amount deposited by an account address to an active
proposal.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|depositor|string|false|none|depositor defines the deposit addresses from the proposals.|
|amount|[object]|false|none|amount to be deposited by depositor.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.gov.v1beta1.DepositParams

<a id="schemacosmos.gov.v1beta1.depositparams"></a>
<a id="schema_cosmos.gov.v1beta1.DepositParams"></a>
<a id="tocScosmos.gov.v1beta1.depositparams"></a>
<a id="tocscosmos.gov.v1beta1.depositparams"></a>

```json
{
  "min_deposit": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "max_deposit_period": "string"
}

```

DepositParams defines the params for deposits on governance proposals.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|min_deposit|[object]|false|none|Minimum deposit for a proposal to enter voting period.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|max_deposit_period|string|false|none|Maximum period for Atom holders to deposit on a proposal. Initial value: 2<br />months.|

## cosmos.gov.v1beta1.Proposal

<a id="schemacosmos.gov.v1beta1.proposal"></a>
<a id="schema_cosmos.gov.v1beta1.Proposal"></a>
<a id="tocScosmos.gov.v1beta1.proposal"></a>
<a id="tocscosmos.gov.v1beta1.proposal"></a>

```json
{
  "proposal_id": "string",
  "content": {
    "type_url": "string",
    "value": "string"
  },
  "status": "PROPOSAL_STATUS_UNSPECIFIED",
  "final_tally_result": {
    "yes": "string",
    "abstain": "string",
    "no": "string",
    "no_with_veto": "string"
  },
  "submit_time": "2019-08-24T14:15:22Z",
  "deposit_end_time": "2019-08-24T14:15:22Z",
  "total_deposit": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "voting_start_time": "2019-08-24T14:15:22Z",
  "voting_end_time": "2019-08-24T14:15:22Z"
}

```

Proposal defines the core field members of a governance proposal.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|content|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|status|string|false|none|status defines the proposal status.|
|final_tally_result|object|false|none|final_tally_result is the final tally result of the proposal. When<br />querying a proposal via gRPC, this field is not populated until the<br />proposal's voting period has ended.|
|» yes|string|false|none|yes is the number of yes votes on a proposal.|
|» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|» no|string|false|none|no is the number of no votes on a proposal.|
|» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|
|submit_time|string(date-time)|false|none|submit_time is the time of proposal submission.|
|deposit_end_time|string(date-time)|false|none|deposit_end_time is the end time for deposition.|
|total_deposit|[object]|false|none|total_deposit is the total deposit on the proposal.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|voting_start_time|string(date-time)|false|none|voting_start_time is the starting time to vote on a proposal.|
|voting_end_time|string(date-time)|false|none|voting_end_time is the end time of voting on a proposal.|

#### Enumerated Values

|Property|Value|
|---|---|
|status|PROPOSAL_STATUS_UNSPECIFIED|
|status|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|status|PROPOSAL_STATUS_VOTING_PERIOD|
|status|PROPOSAL_STATUS_PASSED|
|status|PROPOSAL_STATUS_REJECTED|
|status|PROPOSAL_STATUS_FAILED|

## cosmos.gov.v1beta1.ProposalStatus

<a id="schemacosmos.gov.v1beta1.proposalstatus"></a>
<a id="schema_cosmos.gov.v1beta1.ProposalStatus"></a>
<a id="tocScosmos.gov.v1beta1.proposalstatus"></a>
<a id="tocscosmos.gov.v1beta1.proposalstatus"></a>

```json
"PROPOSAL_STATUS_UNSPECIFIED"

```

ProposalStatus enumerates the valid statuses of a proposal.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|ProposalStatus enumerates the valid statuses of a proposal.<br /><br /> - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.<br /> - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit<br />period.<br /> - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting<br />period.<br /> - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has<br />passed.<br /> - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has<br />been rejected.<br /> - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has<br />failed.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|PROPOSAL_STATUS_UNSPECIFIED|
|*anonymous*|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|*anonymous*|PROPOSAL_STATUS_VOTING_PERIOD|
|*anonymous*|PROPOSAL_STATUS_PASSED|
|*anonymous*|PROPOSAL_STATUS_REJECTED|
|*anonymous*|PROPOSAL_STATUS_FAILED|

## cosmos.gov.v1beta1.QueryDepositResponse

<a id="schemacosmos.gov.v1beta1.querydepositresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryDepositResponse"></a>
<a id="tocScosmos.gov.v1beta1.querydepositresponse"></a>
<a id="tocscosmos.gov.v1beta1.querydepositresponse"></a>

```json
{
  "deposit": {
    "proposal_id": "string",
    "depositor": "string",
    "amount": [
      {
        "denom": "string",
        "amount": "string"
      }
    ]
  }
}

```

QueryDepositResponse is the response type for the Query/Deposit RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|deposit|object|false|none|Deposit defines an amount deposited by an account address to an active<br />proposal.|
|» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|» depositor|string|false|none|depositor defines the deposit addresses from the proposals.|
|» amount|[object]|false|none|amount to be deposited by depositor.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

## cosmos.gov.v1beta1.QueryDepositsResponse

<a id="schemacosmos.gov.v1beta1.querydepositsresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryDepositsResponse"></a>
<a id="tocScosmos.gov.v1beta1.querydepositsresponse"></a>
<a id="tocscosmos.gov.v1beta1.querydepositsresponse"></a>

```json
{
  "deposits": [
    {
      "proposal_id": "string",
      "depositor": "string",
      "amount": [
        {
          "denom": "string",
          "amount": "string"
        }
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryDepositsResponse is the response type for the Query/Deposits RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|deposits|[object]|false|none|deposits defines the requested deposits.|
|» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|» depositor|string|false|none|depositor defines the deposit addresses from the proposals.|
|» amount|[object]|false|none|amount to be deposited by depositor.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.gov.v1beta1.QueryParamsResponse

<a id="schemacosmos.gov.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.gov.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.gov.v1beta1.queryparamsresponse"></a>

```json
{
  "voting_params": {
    "voting_period": "string"
  },
  "deposit_params": {
    "min_deposit": [
      {
        "denom": "string",
        "amount": "string"
      }
    ],
    "max_deposit_period": "string"
  },
  "tally_params": {
    "quorum": "string",
    "threshold": "string",
    "veto_threshold": "string"
  }
}

```

QueryParamsResponse is the response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|voting_params|object|false|none|voting_params defines the parameters related to voting.|
|» voting_period|string|false|none|Duration of the voting period.|
|deposit_params|object|false|none|deposit_params defines the parameters related to deposit.|
|» min_deposit|[object]|false|none|Minimum deposit for a proposal to enter voting period.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» max_deposit_period|string|false|none|Maximum period for Atom holders to deposit on a proposal. Initial value: 2<br />months.|
|tally_params|object|false|none|tally_params defines the parameters related to tally.|
|» quorum|string(byte)|false|none|Minimum percentage of total stake needed to vote for a result to be<br />considered valid.|
|» threshold|string(byte)|false|none|Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.|
|» veto_threshold|string(byte)|false|none|Minimum value of Veto votes to Total votes ratio for proposal to be<br />vetoed. Default value: 1/3.|

## cosmos.gov.v1beta1.QueryProposalResponse

<a id="schemacosmos.gov.v1beta1.queryproposalresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryProposalResponse"></a>
<a id="tocScosmos.gov.v1beta1.queryproposalresponse"></a>
<a id="tocscosmos.gov.v1beta1.queryproposalresponse"></a>

```json
{
  "proposal": {
    "proposal_id": "string",
    "content": {
      "type_url": "string",
      "value": "string"
    },
    "status": "PROPOSAL_STATUS_UNSPECIFIED",
    "final_tally_result": {
      "yes": "string",
      "abstain": "string",
      "no": "string",
      "no_with_veto": "string"
    },
    "submit_time": "2019-08-24T14:15:22Z",
    "deposit_end_time": "2019-08-24T14:15:22Z",
    "total_deposit": [
      {
        "denom": "string",
        "amount": "string"
      }
    ],
    "voting_start_time": "2019-08-24T14:15:22Z",
    "voting_end_time": "2019-08-24T14:15:22Z"
  }
}

```

QueryProposalResponse is the response type for the Query/Proposal RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|proposal|object|false|none|Proposal defines the core field members of a governance proposal.|
|» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|» content|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» status|string|false|none|status defines the proposal status.|
|» final_tally_result|object|false|none|final_tally_result is the final tally result of the proposal. When<br />querying a proposal via gRPC, this field is not populated until the<br />proposal's voting period has ended.|
|»» yes|string|false|none|yes is the number of yes votes on a proposal.|
|»» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|»» no|string|false|none|no is the number of no votes on a proposal.|
|»» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|
|» submit_time|string(date-time)|false|none|submit_time is the time of proposal submission.|
|» deposit_end_time|string(date-time)|false|none|deposit_end_time is the end time for deposition.|
|» total_deposit|[object]|false|none|total_deposit is the total deposit on the proposal.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» voting_start_time|string(date-time)|false|none|voting_start_time is the starting time to vote on a proposal.|
|» voting_end_time|string(date-time)|false|none|voting_end_time is the end time of voting on a proposal.|

#### Enumerated Values

|Property|Value|
|---|---|
|status|PROPOSAL_STATUS_UNSPECIFIED|
|status|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|status|PROPOSAL_STATUS_VOTING_PERIOD|
|status|PROPOSAL_STATUS_PASSED|
|status|PROPOSAL_STATUS_REJECTED|
|status|PROPOSAL_STATUS_FAILED|

## cosmos.gov.v1beta1.QueryProposalsResponse

<a id="schemacosmos.gov.v1beta1.queryproposalsresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryProposalsResponse"></a>
<a id="tocScosmos.gov.v1beta1.queryproposalsresponse"></a>
<a id="tocscosmos.gov.v1beta1.queryproposalsresponse"></a>

```json
{
  "proposals": [
    {
      "proposal_id": "string",
      "content": {
        "type_url": "string",
        "value": "string"
      },
      "status": "PROPOSAL_STATUS_UNSPECIFIED",
      "final_tally_result": {
        "yes": "string",
        "abstain": "string",
        "no": "string",
        "no_with_veto": "string"
      },
      "submit_time": "2019-08-24T14:15:22Z",
      "deposit_end_time": "2019-08-24T14:15:22Z",
      "total_deposit": [
        {
          "denom": "string",
          "amount": "string"
        }
      ],
      "voting_start_time": "2019-08-24T14:15:22Z",
      "voting_end_time": "2019-08-24T14:15:22Z"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryProposalsResponse is the response type for the Query/Proposals RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|proposals|[object]|false|none|proposals defines all the requested governance proposals.|
|» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|» content|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» status|string|false|none|status defines the proposal status.|
|» final_tally_result|object|false|none|final_tally_result is the final tally result of the proposal. When<br />querying a proposal via gRPC, this field is not populated until the<br />proposal's voting period has ended.|
|»» yes|string|false|none|yes is the number of yes votes on a proposal.|
|»» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|»» no|string|false|none|no is the number of no votes on a proposal.|
|»» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|
|» submit_time|string(date-time)|false|none|submit_time is the time of proposal submission.|
|» deposit_end_time|string(date-time)|false|none|deposit_end_time is the end time for deposition.|
|» total_deposit|[object]|false|none|total_deposit is the total deposit on the proposal.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» voting_start_time|string(date-time)|false|none|voting_start_time is the starting time to vote on a proposal.|
|» voting_end_time|string(date-time)|false|none|voting_end_time is the end time of voting on a proposal.|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|PROPOSAL_STATUS_UNSPECIFIED|
|status|PROPOSAL_STATUS_DEPOSIT_PERIOD|
|status|PROPOSAL_STATUS_VOTING_PERIOD|
|status|PROPOSAL_STATUS_PASSED|
|status|PROPOSAL_STATUS_REJECTED|
|status|PROPOSAL_STATUS_FAILED|

## cosmos.gov.v1beta1.QueryTallyResultResponse

<a id="schemacosmos.gov.v1beta1.querytallyresultresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryTallyResultResponse"></a>
<a id="tocScosmos.gov.v1beta1.querytallyresultresponse"></a>
<a id="tocscosmos.gov.v1beta1.querytallyresultresponse"></a>

```json
{
  "tally": {
    "yes": "string",
    "abstain": "string",
    "no": "string",
    "no_with_veto": "string"
  }
}

```

QueryTallyResultResponse is the response type for the Query/Tally RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tally|object|false|none|tally defines the requested tally.|
|» yes|string|false|none|yes is the number of yes votes on a proposal.|
|» abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|» no|string|false|none|no is the number of no votes on a proposal.|
|» no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|

## cosmos.gov.v1beta1.QueryVoteResponse

<a id="schemacosmos.gov.v1beta1.queryvoteresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryVoteResponse"></a>
<a id="tocScosmos.gov.v1beta1.queryvoteresponse"></a>
<a id="tocscosmos.gov.v1beta1.queryvoteresponse"></a>

```json
{
  "vote": {
    "proposal_id": "string",
    "voter": "string",
    "option": "VOTE_OPTION_UNSPECIFIED",
    "options": [
      {
        "option": "VOTE_OPTION_UNSPECIFIED",
        "weight": "string"
      }
    ]
  }
}

```

QueryVoteResponse is the response type for the Query/Vote RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|vote|object|false|none|Vote defines a vote on a governance proposal.<br />A Vote consists of a proposal ID, the voter, and the vote option.|
|» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|» voter|string|false|none|voter is the voter address of the proposal.|
|» option|string|false|none|Deprecated: Prefer to use `options` instead. This field is set in queries<br />if and only if `len(options) == 1` and that option has weight 1. In all<br />other cases, this field will default to VOTE_OPTION_UNSPECIFIED.|
|» options|[object]|false|none|options is the weighted vote options.<br /><br />Since: cosmos-sdk 0.43|
|»» option|string|false|none|option defines the valid vote options, it must not contain duplicate vote options.|
|»» weight|string|false|none|weight is the vote weight associated with the vote option.|

#### Enumerated Values

|Property|Value|
|---|---|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|

## cosmos.gov.v1beta1.QueryVotesResponse

<a id="schemacosmos.gov.v1beta1.queryvotesresponse"></a>
<a id="schema_cosmos.gov.v1beta1.QueryVotesResponse"></a>
<a id="tocScosmos.gov.v1beta1.queryvotesresponse"></a>
<a id="tocscosmos.gov.v1beta1.queryvotesresponse"></a>

```json
{
  "votes": [
    {
      "proposal_id": "string",
      "voter": "string",
      "option": "VOTE_OPTION_UNSPECIFIED",
      "options": [
        {
          "option": "VOTE_OPTION_UNSPECIFIED",
          "weight": "string"
        }
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryVotesResponse is the response type for the Query/Votes RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|votes|[object]|false|none|votes defines the queried votes.|
|» proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|» voter|string|false|none|voter is the voter address of the proposal.|
|» option|string|false|none|Deprecated: Prefer to use `options` instead. This field is set in queries<br />if and only if `len(options) == 1` and that option has weight 1. In all<br />other cases, this field will default to VOTE_OPTION_UNSPECIFIED.|
|» options|[object]|false|none|options is the weighted vote options.<br /><br />Since: cosmos-sdk 0.43|
|»» option|string|false|none|option defines the valid vote options, it must not contain duplicate vote options.|
|»» weight|string|false|none|weight is the vote weight associated with the vote option.|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|

## cosmos.gov.v1beta1.TallyParams

<a id="schemacosmos.gov.v1beta1.tallyparams"></a>
<a id="schema_cosmos.gov.v1beta1.TallyParams"></a>
<a id="tocScosmos.gov.v1beta1.tallyparams"></a>
<a id="tocscosmos.gov.v1beta1.tallyparams"></a>

```json
{
  "quorum": "string",
  "threshold": "string",
  "veto_threshold": "string"
}

```

TallyParams defines the params for tallying votes on governance proposals.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|quorum|string(byte)|false|none|Minimum percentage of total stake needed to vote for a result to be<br />considered valid.|
|threshold|string(byte)|false|none|Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.|
|veto_threshold|string(byte)|false|none|Minimum value of Veto votes to Total votes ratio for proposal to be<br />vetoed. Default value: 1/3.|

## cosmos.gov.v1beta1.TallyResult

<a id="schemacosmos.gov.v1beta1.tallyresult"></a>
<a id="schema_cosmos.gov.v1beta1.TallyResult"></a>
<a id="tocScosmos.gov.v1beta1.tallyresult"></a>
<a id="tocscosmos.gov.v1beta1.tallyresult"></a>

```json
{
  "yes": "string",
  "abstain": "string",
  "no": "string",
  "no_with_veto": "string"
}

```

TallyResult defines a standard tally for a governance proposal.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|yes|string|false|none|yes is the number of yes votes on a proposal.|
|abstain|string|false|none|abstain is the number of abstain votes on a proposal.|
|no|string|false|none|no is the number of no votes on a proposal.|
|no_with_veto|string|false|none|no_with_veto is the number of no with veto votes on a proposal.|

## cosmos.gov.v1beta1.Vote

<a id="schemacosmos.gov.v1beta1.vote"></a>
<a id="schema_cosmos.gov.v1beta1.Vote"></a>
<a id="tocScosmos.gov.v1beta1.vote"></a>
<a id="tocscosmos.gov.v1beta1.vote"></a>

```json
{
  "proposal_id": "string",
  "voter": "string",
  "option": "VOTE_OPTION_UNSPECIFIED",
  "options": [
    {
      "option": "VOTE_OPTION_UNSPECIFIED",
      "weight": "string"
    }
  ]
}

```

Vote defines a vote on a governance proposal.
A Vote consists of a proposal ID, the voter, and the vote option.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|proposal_id|string(uint64)|false|none|proposal_id defines the unique id of the proposal.|
|voter|string|false|none|voter is the voter address of the proposal.|
|option|string|false|none|Deprecated: Prefer to use `options` instead. This field is set in queries<br />if and only if `len(options) == 1` and that option has weight 1. In all<br />other cases, this field will default to VOTE_OPTION_UNSPECIFIED.|
|options|[object]|false|none|options is the weighted vote options.<br /><br />Since: cosmos-sdk 0.43|
|» option|string|false|none|option defines the valid vote options, it must not contain duplicate vote options.|
|» weight|string|false|none|weight is the vote weight associated with the vote option.|

#### Enumerated Values

|Property|Value|
|---|---|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|

## cosmos.gov.v1beta1.VoteOption

<a id="schemacosmos.gov.v1beta1.voteoption"></a>
<a id="schema_cosmos.gov.v1beta1.VoteOption"></a>
<a id="tocScosmos.gov.v1beta1.voteoption"></a>
<a id="tocscosmos.gov.v1beta1.voteoption"></a>

```json
"VOTE_OPTION_UNSPECIFIED"

```

VoteOption enumerates the valid vote options for a given governance proposal.

 - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|VoteOption enumerates the valid vote options for a given governance proposal.<br /><br /> - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.<br /> - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.<br /> - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.<br /> - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.<br /> - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|VOTE_OPTION_UNSPECIFIED|
|*anonymous*|VOTE_OPTION_YES|
|*anonymous*|VOTE_OPTION_ABSTAIN|
|*anonymous*|VOTE_OPTION_NO|
|*anonymous*|VOTE_OPTION_NO_WITH_VETO|

## cosmos.gov.v1beta1.VotingParams

<a id="schemacosmos.gov.v1beta1.votingparams"></a>
<a id="schema_cosmos.gov.v1beta1.VotingParams"></a>
<a id="tocScosmos.gov.v1beta1.votingparams"></a>
<a id="tocscosmos.gov.v1beta1.votingparams"></a>

```json
{
  "voting_period": "string"
}

```

VotingParams defines the params for voting on governance proposals.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|voting_period|string|false|none|Duration of the voting period.|

## cosmos.gov.v1beta1.WeightedVoteOption

<a id="schemacosmos.gov.v1beta1.weightedvoteoption"></a>
<a id="schema_cosmos.gov.v1beta1.WeightedVoteOption"></a>
<a id="tocScosmos.gov.v1beta1.weightedvoteoption"></a>
<a id="tocscosmos.gov.v1beta1.weightedvoteoption"></a>

```json
{
  "option": "VOTE_OPTION_UNSPECIFIED",
  "weight": "string"
}

```

WeightedVoteOption defines a unit of vote for vote split.

Since: cosmos-sdk 0.43

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|option|string|false|none|option defines the valid vote options, it must not contain duplicate vote options.|
|weight|string|false|none|weight is the vote weight associated with the vote option.|

#### Enumerated Values

|Property|Value|
|---|---|
|option|VOTE_OPTION_UNSPECIFIED|
|option|VOTE_OPTION_YES|
|option|VOTE_OPTION_ABSTAIN|
|option|VOTE_OPTION_NO|
|option|VOTE_OPTION_NO_WITH_VETO|

## cosmos.mint.v1beta1.Params

<a id="schemacosmos.mint.v1beta1.params"></a>
<a id="schema_cosmos.mint.v1beta1.Params"></a>
<a id="tocScosmos.mint.v1beta1.params"></a>
<a id="tocscosmos.mint.v1beta1.params"></a>

```json
{
  "mint_denom": "string",
  "inflation_rate_change": "string",
  "inflation_max": "string",
  "inflation_min": "string",
  "goal_bonded": "string",
  "blocks_per_year": "string"
}

```

Params defines the parameters for the x/mint module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|mint_denom|string|false|none|none|
|inflation_rate_change|string|false|none|none|
|inflation_max|string|false|none|none|
|inflation_min|string|false|none|none|
|goal_bonded|string|false|none|none|
|blocks_per_year|string(uint64)|false|none|none|

## cosmos.mint.v1beta1.QueryAnnualProvisionsResponse

<a id="schemacosmos.mint.v1beta1.queryannualprovisionsresponse"></a>
<a id="schema_cosmos.mint.v1beta1.QueryAnnualProvisionsResponse"></a>
<a id="tocScosmos.mint.v1beta1.queryannualprovisionsresponse"></a>
<a id="tocscosmos.mint.v1beta1.queryannualprovisionsresponse"></a>

```json
{
  "annual_provisions": "string"
}

```

QueryAnnualProvisionsResponse is the response type for the
Query/AnnualProvisions RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|annual_provisions|string(byte)|false|none|annual_provisions is the current minting annual provisions value.|

## cosmos.mint.v1beta1.QueryInflationResponse

<a id="schemacosmos.mint.v1beta1.queryinflationresponse"></a>
<a id="schema_cosmos.mint.v1beta1.QueryInflationResponse"></a>
<a id="tocScosmos.mint.v1beta1.queryinflationresponse"></a>
<a id="tocscosmos.mint.v1beta1.queryinflationresponse"></a>

```json
{
  "inflation": "string"
}

```

QueryInflationResponse is the response type for the Query/Inflation RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|inflation|string(byte)|false|none|inflation is the current minting inflation value.|

## cosmos.mint.v1beta1.QueryParamsResponse

<a id="schemacosmos.mint.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.mint.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.mint.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.mint.v1beta1.queryparamsresponse"></a>

```json
{
  "params": {
    "mint_denom": "string",
    "inflation_rate_change": "string",
    "inflation_max": "string",
    "inflation_min": "string",
    "goal_bonded": "string",
    "blocks_per_year": "string"
  }
}

```

QueryParamsResponse is the response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params defines the parameters of the module.|
|» mint_denom|string|false|none|none|
|» inflation_rate_change|string|false|none|none|
|» inflation_max|string|false|none|none|
|» inflation_min|string|false|none|none|
|» goal_bonded|string|false|none|none|
|» blocks_per_year|string(uint64)|false|none|none|

## cosmos.params.v1beta1.ParamChange

<a id="schemacosmos.params.v1beta1.paramchange"></a>
<a id="schema_cosmos.params.v1beta1.ParamChange"></a>
<a id="tocScosmos.params.v1beta1.paramchange"></a>
<a id="tocscosmos.params.v1beta1.paramchange"></a>

```json
{
  "subspace": "string",
  "key": "string",
  "value": "string"
}

```

ParamChange defines an individual parameter change, for use in
ParameterChangeProposal.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|subspace|string|false|none|none|
|key|string|false|none|none|
|value|string|false|none|none|

## cosmos.params.v1beta1.QueryParamsResponse

<a id="schemacosmos.params.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.params.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.params.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.params.v1beta1.queryparamsresponse"></a>

```json
{
  "param": {
    "subspace": "string",
    "key": "string",
    "value": "string"
  }
}

```

QueryParamsResponse is response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|param|object|false|none|param defines the queried parameter.|
|» subspace|string|false|none|none|
|» key|string|false|none|none|
|» value|string|false|none|none|

## cosmos.params.v1beta1.QuerySubspacesResponse

<a id="schemacosmos.params.v1beta1.querysubspacesresponse"></a>
<a id="schema_cosmos.params.v1beta1.QuerySubspacesResponse"></a>
<a id="tocScosmos.params.v1beta1.querysubspacesresponse"></a>
<a id="tocscosmos.params.v1beta1.querysubspacesresponse"></a>

```json
{
  "subspaces": [
    {
      "subspace": "string",
      "keys": [
        "string"
      ]
    }
  ]
}

```

QuerySubspacesResponse defines the response types for querying for all
registered subspaces and all keys for a subspace.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|subspaces|[object]|false|none|none|
|» subspace|string|false|none|none|
|» keys|[string]|false|none|none|

## cosmos.params.v1beta1.Subspace

<a id="schemacosmos.params.v1beta1.subspace"></a>
<a id="schema_cosmos.params.v1beta1.Subspace"></a>
<a id="tocScosmos.params.v1beta1.subspace"></a>
<a id="tocscosmos.params.v1beta1.subspace"></a>

```json
{
  "subspace": "string",
  "keys": [
    "string"
  ]
}

```

Subspace defines a parameter subspace name and all the keys that exist for
the subspace.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|subspace|string|false|none|none|
|keys|[string]|false|none|none|

## cosmos.slashing.v1beta1.Params

<a id="schemacosmos.slashing.v1beta1.params"></a>
<a id="schema_cosmos.slashing.v1beta1.Params"></a>
<a id="tocScosmos.slashing.v1beta1.params"></a>
<a id="tocscosmos.slashing.v1beta1.params"></a>

```json
{
  "signed_blocks_window": "string",
  "min_signed_per_window": "string",
  "downtime_jail_duration": "string",
  "slash_fraction_double_sign": "string",
  "slash_fraction_downtime": "string"
}

```

Params represents the parameters used for by the slashing module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|signed_blocks_window|string(int64)|false|none|none|
|min_signed_per_window|string(byte)|false|none|none|
|downtime_jail_duration|string|false|none|none|
|slash_fraction_double_sign|string(byte)|false|none|none|
|slash_fraction_downtime|string(byte)|false|none|none|

## cosmos.slashing.v1beta1.QueryParamsResponse

<a id="schemacosmos.slashing.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.slashing.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.slashing.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.slashing.v1beta1.queryparamsresponse"></a>

```json
{
  "params": {
    "signed_blocks_window": "string",
    "min_signed_per_window": "string",
    "downtime_jail_duration": "string",
    "slash_fraction_double_sign": "string",
    "slash_fraction_downtime": "string"
  }
}

```

QueryParamsResponse is the response type for the Query/Params RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|Params represents the parameters used for by the slashing module.|
|» signed_blocks_window|string(int64)|false|none|none|
|» min_signed_per_window|string(byte)|false|none|none|
|» downtime_jail_duration|string|false|none|none|
|» slash_fraction_double_sign|string(byte)|false|none|none|
|» slash_fraction_downtime|string(byte)|false|none|none|

## cosmos.slashing.v1beta1.QuerySigningInfoResponse

<a id="schemacosmos.slashing.v1beta1.querysigninginforesponse"></a>
<a id="schema_cosmos.slashing.v1beta1.QuerySigningInfoResponse"></a>
<a id="tocScosmos.slashing.v1beta1.querysigninginforesponse"></a>
<a id="tocscosmos.slashing.v1beta1.querysigninginforesponse"></a>

```json
{
  "val_signing_info": {
    "address": "string",
    "start_height": "string",
    "index_offset": "string",
    "jailed_until": "2019-08-24T14:15:22Z",
    "tombstoned": true,
    "missed_blocks_counter": "string"
  }
}

```

QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|val_signing_info|object|false|none|ValidatorSigningInfo defines a validator's signing info for monitoring their<br />liveness activity.|
|» address|string|false|none|none|
|» start_height|string(int64)|false|none|none|
|» index_offset|string(int64)|false|none|Index which is incremented every time a validator is bonded in a block and<br />_may_ have signed a pre-commit or not. This in conjunction with the<br />signed_blocks_window param determines the index in the missed block bitmap.|
|» jailed_until|string(date-time)|false|none|Timestamp until which the validator is jailed due to liveness downtime.|
|» tombstoned|boolean|false|none|Whether or not a validator has been tombstoned (killed out of validator<br />set). It is set once the validator commits an equivocation or for any other<br />configured misbehavior.|
|» missed_blocks_counter|string(int64)|false|none|A counter of missed (unsigned) blocks. It is used to avoid unnecessary<br />reads in the missed block bitmap.|

## cosmos.slashing.v1beta1.QuerySigningInfosResponse

<a id="schemacosmos.slashing.v1beta1.querysigninginfosresponse"></a>
<a id="schema_cosmos.slashing.v1beta1.QuerySigningInfosResponse"></a>
<a id="tocScosmos.slashing.v1beta1.querysigninginfosresponse"></a>
<a id="tocscosmos.slashing.v1beta1.querysigninginfosresponse"></a>

```json
{
  "info": [
    {
      "address": "string",
      "start_height": "string",
      "index_offset": "string",
      "jailed_until": "2019-08-24T14:15:22Z",
      "tombstoned": true,
      "missed_blocks_counter": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|info|[object]|false|none|none|
|» address|string|false|none|none|
|» start_height|string(int64)|false|none|none|
|» index_offset|string(int64)|false|none|Index which is incremented every time a validator is bonded in a block and<br />_may_ have signed a pre-commit or not. This in conjunction with the<br />signed_blocks_window param determines the index in the missed block bitmap.|
|» jailed_until|string(date-time)|false|none|Timestamp until which the validator is jailed due to liveness downtime.|
|» tombstoned|boolean|false|none|Whether or not a validator has been tombstoned (killed out of validator<br />set). It is set once the validator commits an equivocation or for any other<br />configured misbehavior.|
|» missed_blocks_counter|string(int64)|false|none|A counter of missed (unsigned) blocks. It is used to avoid unnecessary<br />reads in the missed block bitmap.|
|pagination|object|false|none|PageResponse is to be embedded in gRPC response messages where the<br />corresponding request message has used PageRequest.<br /><br /> message SomeResponse {<br />         repeated Bar results = 1;<br />         PageResponse page = 2;<br /> }|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.slashing.v1beta1.ValidatorSigningInfo

<a id="schemacosmos.slashing.v1beta1.validatorsigninginfo"></a>
<a id="schema_cosmos.slashing.v1beta1.ValidatorSigningInfo"></a>
<a id="tocScosmos.slashing.v1beta1.validatorsigninginfo"></a>
<a id="tocscosmos.slashing.v1beta1.validatorsigninginfo"></a>

```json
{
  "address": "string",
  "start_height": "string",
  "index_offset": "string",
  "jailed_until": "2019-08-24T14:15:22Z",
  "tombstoned": true,
  "missed_blocks_counter": "string"
}

```

ValidatorSigningInfo defines a validator's signing info for monitoring their
liveness activity.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|
|start_height|string(int64)|false|none|none|
|index_offset|string(int64)|false|none|Index which is incremented every time a validator is bonded in a block and<br />_may_ have signed a pre-commit or not. This in conjunction with the<br />signed_blocks_window param determines the index in the missed block bitmap.|
|jailed_until|string(date-time)|false|none|Timestamp until which the validator is jailed due to liveness downtime.|
|tombstoned|boolean|false|none|Whether or not a validator has been tombstoned (killed out of validator<br />set). It is set once the validator commits an equivocation or for any other<br />configured misbehavior.|
|missed_blocks_counter|string(int64)|false|none|A counter of missed (unsigned) blocks. It is used to avoid unnecessary<br />reads in the missed block bitmap.|

## cosmos.staking.v1beta1.BondStatus

<a id="schemacosmos.staking.v1beta1.bondstatus"></a>
<a id="schema_cosmos.staking.v1beta1.BondStatus"></a>
<a id="tocScosmos.staking.v1beta1.bondstatus"></a>
<a id="tocscosmos.staking.v1beta1.bondstatus"></a>

```json
"BOND_STATUS_UNSPECIFIED"

```

BondStatus is the status of a validator.

 - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.
 - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.
 - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.
 - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|BondStatus is the status of a validator.<br /><br /> - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.<br /> - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.<br /> - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.<br /> - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|BOND_STATUS_UNSPECIFIED|
|*anonymous*|BOND_STATUS_UNBONDED|
|*anonymous*|BOND_STATUS_UNBONDING|
|*anonymous*|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.Commission

<a id="schemacosmos.staking.v1beta1.commission"></a>
<a id="schema_cosmos.staking.v1beta1.Commission"></a>
<a id="tocScosmos.staking.v1beta1.commission"></a>
<a id="tocscosmos.staking.v1beta1.commission"></a>

```json
{
  "commission_rates": {
    "rate": "string",
    "max_rate": "string",
    "max_change_rate": "string"
  },
  "update_time": "2019-08-24T14:15:22Z"
}

```

Commission defines commission parameters for a given validator.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|

## cosmos.staking.v1beta1.CommissionRates

<a id="schemacosmos.staking.v1beta1.commissionrates"></a>
<a id="schema_cosmos.staking.v1beta1.CommissionRates"></a>
<a id="tocScosmos.staking.v1beta1.commissionrates"></a>
<a id="tocscosmos.staking.v1beta1.commissionrates"></a>

```json
{
  "rate": "string",
  "max_rate": "string",
  "max_change_rate": "string"
}

```

CommissionRates defines the initial commission rates to be used for creating
a validator.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|

## cosmos.staking.v1beta1.Delegation

<a id="schemacosmos.staking.v1beta1.delegation"></a>
<a id="schema_cosmos.staking.v1beta1.Delegation"></a>
<a id="tocScosmos.staking.v1beta1.delegation"></a>
<a id="tocscosmos.staking.v1beta1.delegation"></a>

```json
{
  "delegator_address": "string",
  "validator_address": "string",
  "shares": "string"
}

```

Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|validator_address|string|false|none|validator_address is the encoded address of the validator.|
|shares|string|false|none|shares define the delegation shares received.|

## cosmos.staking.v1beta1.DelegationResponse

<a id="schemacosmos.staking.v1beta1.delegationresponse"></a>
<a id="schema_cosmos.staking.v1beta1.DelegationResponse"></a>
<a id="tocScosmos.staking.v1beta1.delegationresponse"></a>
<a id="tocscosmos.staking.v1beta1.delegationresponse"></a>

```json
{
  "delegation": {
    "delegator_address": "string",
    "validator_address": "string",
    "shares": "string"
  },
  "balance": {
    "denom": "string",
    "amount": "string"
  }
}

```

DelegationResponse is equivalent to Delegation except that it contains a
balance in addition to shares which is more suitable for client responses.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|» shares|string|false|none|shares define the delegation shares received.|
|balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|» denom|string|false|none|none|
|» amount|string|false|none|none|

## cosmos.staking.v1beta1.Description

<a id="schemacosmos.staking.v1beta1.description"></a>
<a id="schema_cosmos.staking.v1beta1.Description"></a>
<a id="tocScosmos.staking.v1beta1.description"></a>
<a id="tocscosmos.staking.v1beta1.description"></a>

```json
{
  "moniker": "string",
  "identity": "string",
  "website": "string",
  "security_contact": "string",
  "details": "string"
}

```

Description defines a validator description.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|moniker|string|false|none|moniker defines a human-readable name for the validator.|
|identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|website|string|false|none|website defines an optional website link.|
|security_contact|string|false|none|security_contact defines an optional email for security contact.|
|details|string|false|none|details define other optional details.|

## cosmos.staking.v1beta1.HistoricalInfo

<a id="schemacosmos.staking.v1beta1.historicalinfo"></a>
<a id="schema_cosmos.staking.v1beta1.HistoricalInfo"></a>
<a id="tocScosmos.staking.v1beta1.historicalinfo"></a>
<a id="tocscosmos.staking.v1beta1.historicalinfo"></a>

```json
{
  "header": {
    "version": {
      "block": "string",
      "app": "string"
    },
    "chain_id": "string",
    "height": "string",
    "time": "2019-08-24T14:15:22Z",
    "last_block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "last_commit_hash": "string",
    "data_hash": "string",
    "validators_hash": "string",
    "next_validators_hash": "string",
    "consensus_hash": "string",
    "app_hash": "string",
    "last_results_hash": "string",
    "evidence_hash": "string",
    "proposer_address": "string"
  },
  "valset": [
    {
      "operator_address": "string",
      "consensus_pubkey": {
        "type_url": "string",
        "value": "string"
      },
      "jailed": true,
      "status": "BOND_STATUS_UNSPECIFIED",
      "tokens": "string",
      "delegator_shares": "string",
      "description": {
        "moniker": "string",
        "identity": "string",
        "website": "string",
        "security_contact": "string",
        "details": "string"
      },
      "unbonding_height": "string",
      "unbonding_time": "2019-08-24T14:15:22Z",
      "commission": {
        "commission_rates": {
          "rate": "string",
          "max_rate": "string",
          "max_change_rate": "string"
        },
        "update_time": "2019-08-24T14:15:22Z"
      },
      "min_self_delegation": "string",
      "unbonding_on_hold_ref_count": "string",
      "unbonding_ids": [
        "string"
      ]
    }
  ]
}

```

HistoricalInfo contains header and validator information for a given block.
It is stored as part of staking module's state, which persists the `n` most
recent HistoricalInfo
(`n` is set by the staking module's `historical_entries` parameter).

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|header|object|false|none|Header defines the structure of a block header.|
|» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»» block|string(uint64)|false|none|none|
|»» app|string(uint64)|false|none|none|
|» chain_id|string|false|none|none|
|» height|string(int64)|false|none|none|
|» time|string(date-time)|false|none|none|
|» last_block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» last_commit_hash|string(byte)|false|none|none|
|» data_hash|string(byte)|false|none|none|
|» validators_hash|string(byte)|false|none|none|
|» next_validators_hash|string(byte)|false|none|none|
|» consensus_hash|string(byte)|false|none|none|
|» app_hash|string(byte)|false|none|none|
|» last_results_hash|string(byte)|false|none|none|
|» evidence_hash|string(byte)|false|none|none|
|» proposer_address|string(byte)|false|none|none|
|valset|[object]|false|none|none|
|» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|» description|object|false|none|description defines the description terms for the validator.|
|»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»» website|string|false|none|website defines an optional website link.|
|»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»» details|string|false|none|details define other optional details.|
|» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|» commission|object|false|none|commission defines the commission parameters.|
|»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.Params

<a id="schemacosmos.staking.v1beta1.params"></a>
<a id="schema_cosmos.staking.v1beta1.Params"></a>
<a id="tocScosmos.staking.v1beta1.params"></a>
<a id="tocscosmos.staking.v1beta1.params"></a>

```json
{
  "unbonding_time": "string",
  "max_validators": 0,
  "max_entries": 0,
  "historical_entries": 0,
  "bond_denom": "string",
  "min_commission_rate": "string"
}

```

Params defines the parameters for the x/staking module.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|unbonding_time|string|false|none|unbonding_time is the time duration of unbonding.|
|max_validators|integer(int64)|false|none|max_validators is the maximum number of validators.|
|max_entries|integer(int64)|false|none|max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).|
|historical_entries|integer(int64)|false|none|historical_entries is the number of historical entries to persist.|
|bond_denom|string|false|none|bond_denom defines the bondable coin denomination.|
|min_commission_rate|string|false|none|none|

## cosmos.staking.v1beta1.Pool

<a id="schemacosmos.staking.v1beta1.pool"></a>
<a id="schema_cosmos.staking.v1beta1.Pool"></a>
<a id="tocScosmos.staking.v1beta1.pool"></a>
<a id="tocscosmos.staking.v1beta1.pool"></a>

```json
{
  "not_bonded_tokens": "string",
  "bonded_tokens": "string"
}

```

Pool is used for tracking bonded and not-bonded token supply of the bond
denomination.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|not_bonded_tokens|string|false|none|none|
|bonded_tokens|string|false|none|none|

## cosmos.staking.v1beta1.QueryDelegationResponse

<a id="schemacosmos.staking.v1beta1.querydelegationresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryDelegationResponse"></a>
<a id="tocScosmos.staking.v1beta1.querydelegationresponse"></a>
<a id="tocscosmos.staking.v1beta1.querydelegationresponse"></a>

```json
{
  "delegation_response": {
    "delegation": {
      "delegator_address": "string",
      "validator_address": "string",
      "shares": "string"
    },
    "balance": {
      "denom": "string",
      "amount": "string"
    }
  }
}

```

QueryDelegationResponse is response type for the Query/Delegation RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegation_response|object|false|none|DelegationResponse is equivalent to Delegation except that it contains a<br />balance in addition to shares which is more suitable for client responses.|
|» delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»» shares|string|false|none|shares define the delegation shares received.|
|» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|

## cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse

<a id="schemacosmos.staking.v1beta1.querydelegatordelegationsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse"></a>
<a id="tocScosmos.staking.v1beta1.querydelegatordelegationsresponse"></a>
<a id="tocscosmos.staking.v1beta1.querydelegatordelegationsresponse"></a>

```json
{
  "delegation_responses": [
    {
      "delegation": {
        "delegator_address": "string",
        "validator_address": "string",
        "shares": "string"
      },
      "balance": {
        "denom": "string",
        "amount": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryDelegatorDelegationsResponse is response type for the
Query/DelegatorDelegations RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegation_responses|[object]|false|none|delegation_responses defines all the delegations' info of a delegator.|
|» delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»» shares|string|false|none|shares define the delegation shares received.|
|» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse

<a id="schemacosmos.staking.v1beta1.querydelegatorunbondingdelegationsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse"></a>
<a id="tocScosmos.staking.v1beta1.querydelegatorunbondingdelegationsresponse"></a>
<a id="tocscosmos.staking.v1beta1.querydelegatorunbondingdelegationsresponse"></a>

```json
{
  "unbonding_responses": [
    {
      "delegator_address": "string",
      "validator_address": "string",
      "entries": [
        {
          "creation_height": "string",
          "completion_time": "2019-08-24T14:15:22Z",
          "initial_balance": "string",
          "balance": "string",
          "unbonding_id": "string",
          "unbonding_on_hold_ref_count": "string"
        }
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryUnbondingDelegatorDelegationsResponse is response type for the
Query/UnbondingDelegatorDelegations RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|unbonding_responses|[object]|false|none|none|
|» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|» entries|[object]|false|none|entries are the unbonding delegation entries.|
|»» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|»» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|»» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|»» balance|string|false|none|balance defines the tokens to receive at completion.|
|»» unbonding_id|string(uint64)|false|none|none|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.staking.v1beta1.QueryDelegatorValidatorResponse

<a id="schemacosmos.staking.v1beta1.querydelegatorvalidatorresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryDelegatorValidatorResponse"></a>
<a id="tocScosmos.staking.v1beta1.querydelegatorvalidatorresponse"></a>
<a id="tocscosmos.staking.v1beta1.querydelegatorvalidatorresponse"></a>

```json
{
  "validator": {
    "operator_address": "string",
    "consensus_pubkey": {
      "type_url": "string",
      "value": "string"
    },
    "jailed": true,
    "status": "BOND_STATUS_UNSPECIFIED",
    "tokens": "string",
    "delegator_shares": "string",
    "description": {
      "moniker": "string",
      "identity": "string",
      "website": "string",
      "security_contact": "string",
      "details": "string"
    },
    "unbonding_height": "string",
    "unbonding_time": "2019-08-24T14:15:22Z",
    "commission": {
      "commission_rates": {
        "rate": "string",
        "max_rate": "string",
        "max_change_rate": "string"
      },
      "update_time": "2019-08-24T14:15:22Z"
    },
    "min_self_delegation": "string",
    "unbonding_on_hold_ref_count": "string",
    "unbonding_ids": [
      "string"
    ]
  }
}

```

QueryDelegatorValidatorResponse response type for the
Query/DelegatorValidator RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validator|object|false|none|Validator defines a validator, together with the total amount of the<br />Validator's bond shares and their exchange rate to coins. Slashing results in<br />a decrease in the exchange rate, allowing correct calculation of future<br />undelegations without iterating over delegators. When coins are delegated to<br />this validator, the validator is credited with a delegation whose number of<br />bond shares is based on the amount of coins delegated divided by the current<br />exchange rate. Voting power can be calculated as total bonded shares<br />multiplied by exchange rate.|
|» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|» description|object|false|none|description defines the description terms for the validator.|
|»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»» website|string|false|none|website defines an optional website link.|
|»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»» details|string|false|none|details define other optional details.|
|» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|» commission|object|false|none|commission defines the commission parameters.|
|»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse

<a id="schemacosmos.staking.v1beta1.querydelegatorvalidatorsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse"></a>
<a id="tocScosmos.staking.v1beta1.querydelegatorvalidatorsresponse"></a>
<a id="tocscosmos.staking.v1beta1.querydelegatorvalidatorsresponse"></a>

```json
{
  "validators": [
    {
      "operator_address": "string",
      "consensus_pubkey": {
        "type_url": "string",
        "value": "string"
      },
      "jailed": true,
      "status": "BOND_STATUS_UNSPECIFIED",
      "tokens": "string",
      "delegator_shares": "string",
      "description": {
        "moniker": "string",
        "identity": "string",
        "website": "string",
        "security_contact": "string",
        "details": "string"
      },
      "unbonding_height": "string",
      "unbonding_time": "2019-08-24T14:15:22Z",
      "commission": {
        "commission_rates": {
          "rate": "string",
          "max_rate": "string",
          "max_change_rate": "string"
        },
        "update_time": "2019-08-24T14:15:22Z"
      },
      "min_self_delegation": "string",
      "unbonding_on_hold_ref_count": "string",
      "unbonding_ids": [
        "string"
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryDelegatorValidatorsResponse is response type for the
Query/DelegatorValidators RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validators|[object]|false|none|validators defines the validators' info of a delegator.|
|» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|» description|object|false|none|description defines the description terms for the validator.|
|»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»» website|string|false|none|website defines an optional website link.|
|»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»» details|string|false|none|details define other optional details.|
|» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|» commission|object|false|none|commission defines the commission parameters.|
|»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» unbonding_ids|[string]|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.QueryHistoricalInfoResponse

<a id="schemacosmos.staking.v1beta1.queryhistoricalinforesponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryHistoricalInfoResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryhistoricalinforesponse"></a>
<a id="tocscosmos.staking.v1beta1.queryhistoricalinforesponse"></a>

```json
{
  "hist": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "valset": [
      {
        "operator_address": "string",
        "consensus_pubkey": {
          "type_url": "string",
          "value": "string"
        },
        "jailed": true,
        "status": "BOND_STATUS_UNSPECIFIED",
        "tokens": "string",
        "delegator_shares": "string",
        "description": {
          "moniker": "string",
          "identity": "string",
          "website": "string",
          "security_contact": "string",
          "details": "string"
        },
        "unbonding_height": "string",
        "unbonding_time": "2019-08-24T14:15:22Z",
        "commission": {
          "commission_rates": {},
          "update_time": "2019-08-24T14:15:22Z"
        },
        "min_self_delegation": "string",
        "unbonding_on_hold_ref_count": "string",
        "unbonding_ids": [
          "string"
        ]
      }
    ]
  }
}

```

QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|hist|object|false|none|hist defines the historical info at the given height.|
|» header|object|false|none|Header defines the structure of a block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string(byte)|false|none|none|
|» valset|[object]|false|none|none|
|»» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|»» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|»» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|»» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|»» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|»» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|»» description|object|false|none|description defines the description terms for the validator.|
|»»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»»» website|string|false|none|website defines an optional website link.|
|»»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»»» details|string|false|none|details define other optional details.|
|»» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|»» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|»» commission|object|false|none|commission defines the commission parameters.|
|»»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|»» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.QueryParamsResponse

<a id="schemacosmos.staking.v1beta1.queryparamsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryParamsResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryparamsresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryparamsresponse"></a>

```json
{
  "params": {
    "unbonding_time": "string",
    "max_validators": 0,
    "max_entries": 0,
    "historical_entries": 0,
    "bond_denom": "string",
    "min_commission_rate": "string"
  }
}

```

QueryParamsResponse is response type for the Query/Params RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|params|object|false|none|params holds all the parameters of this module.|
|» unbonding_time|string|false|none|unbonding_time is the time duration of unbonding.|
|» max_validators|integer(int64)|false|none|max_validators is the maximum number of validators.|
|» max_entries|integer(int64)|false|none|max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).|
|» historical_entries|integer(int64)|false|none|historical_entries is the number of historical entries to persist.|
|» bond_denom|string|false|none|bond_denom defines the bondable coin denomination.|
|» min_commission_rate|string|false|none|none|

## cosmos.staking.v1beta1.QueryPoolResponse

<a id="schemacosmos.staking.v1beta1.querypoolresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryPoolResponse"></a>
<a id="tocScosmos.staking.v1beta1.querypoolresponse"></a>
<a id="tocscosmos.staking.v1beta1.querypoolresponse"></a>

```json
{
  "pool": {
    "not_bonded_tokens": "string",
    "bonded_tokens": "string"
  }
}

```

QueryPoolResponse is response type for the Query/Pool RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|pool|object|false|none|pool defines the pool info.|
|» not_bonded_tokens|string|false|none|none|
|» bonded_tokens|string|false|none|none|

## cosmos.staking.v1beta1.QueryRedelegationsResponse

<a id="schemacosmos.staking.v1beta1.queryredelegationsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryRedelegationsResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryredelegationsresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryredelegationsresponse"></a>

```json
{
  "redelegation_responses": [
    {
      "redelegation": {
        "delegator_address": "string",
        "validator_src_address": "string",
        "validator_dst_address": "string",
        "entries": [
          {
            "creation_height": null,
            "completion_time": null,
            "initial_balance": null,
            "shares_dst": null,
            "unbonding_id": null,
            "unbonding_on_hold_ref_count": null
          }
        ]
      },
      "entries": [
        {
          "redelegation_entry": {
            "creation_height": null,
            "completion_time": null,
            "initial_balance": null,
            "shares_dst": null,
            "unbonding_id": null,
            "unbonding_on_hold_ref_count": null
          },
          "balance": "string"
        }
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryRedelegationsResponse is response type for the Query/Redelegations RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|redelegation_responses|[object]|false|none|none|
|» redelegation|object|false|none|Redelegation contains the list of a particular delegator's redelegating bonds<br />from a particular source validator to a particular destination validator.|
|»» delegator_address|string|false|none|delegator_address is the bech32-encoded address of the delegator.|
|»» validator_src_address|string|false|none|validator_src_address is the validator redelegation source operator address.|
|»» validator_dst_address|string|false|none|validator_dst_address is the validator redelegation destination operator address.|
|»» entries|[object]|false|none|entries are the redelegation entries.|
|»»» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|»»» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|»»» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|»»» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|»»» unbonding_id|string(uint64)|false|none|none|
|»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» entries|[object]|false|none|none|
|»» redelegation_entry|object|false|none|RedelegationEntry defines a redelegation object with relevant metadata.|
|»»» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|»»» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|»»» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|»»» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|»»» unbonding_id|string(uint64)|false|none|none|
|»»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|»» balance|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.staking.v1beta1.QueryUnbondingDelegationResponse

<a id="schemacosmos.staking.v1beta1.queryunbondingdelegationresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryUnbondingDelegationResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryunbondingdelegationresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryunbondingdelegationresponse"></a>

```json
{
  "unbond": {
    "delegator_address": "string",
    "validator_address": "string",
    "entries": [
      {
        "creation_height": "string",
        "completion_time": "2019-08-24T14:15:22Z",
        "initial_balance": "string",
        "balance": "string",
        "unbonding_id": "string",
        "unbonding_on_hold_ref_count": "string"
      }
    ]
  }
}

```

QueryDelegationResponse is response type for the Query/UnbondingDelegation
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|unbond|object|false|none|UnbondingDelegation stores all of a single delegator's unbonding bonds<br />for a single validator in an time-ordered list.|
|» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|» entries|[object]|false|none|entries are the unbonding delegation entries.|
|»» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|»» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|»» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|»» balance|string|false|none|balance defines the tokens to receive at completion.|
|»» unbonding_id|string(uint64)|false|none|none|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|

## cosmos.staking.v1beta1.QueryValidatorDelegationsResponse

<a id="schemacosmos.staking.v1beta1.queryvalidatordelegationsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryValidatorDelegationsResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryvalidatordelegationsresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryvalidatordelegationsresponse"></a>

```json
{
  "delegation_responses": [
    {
      "delegation": {
        "delegator_address": "string",
        "validator_address": "string",
        "shares": "string"
      },
      "balance": {
        "denom": "string",
        "amount": "string"
      }
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryValidatorDelegationsResponse is response type for the
Query/ValidatorDelegations RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegation_responses|[object]|false|none|none|
|» delegation|object|false|none|Delegation represents the bond with tokens held by an account. It is<br />owned by one delegator, and is associated with the voting power of one<br />validator.|
|»» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|»» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|»» shares|string|false|none|shares define the delegation shares received.|
|» balance|object|false|none|Coin defines a token with a denomination and an amount.<br /><br />NOTE: The amount field is an Int which implements the custom method<br />signatures required by gogoproto.|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.staking.v1beta1.QueryValidatorResponse

<a id="schemacosmos.staking.v1beta1.queryvalidatorresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryValidatorResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryvalidatorresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryvalidatorresponse"></a>

```json
{
  "validator": {
    "operator_address": "string",
    "consensus_pubkey": {
      "type_url": "string",
      "value": "string"
    },
    "jailed": true,
    "status": "BOND_STATUS_UNSPECIFIED",
    "tokens": "string",
    "delegator_shares": "string",
    "description": {
      "moniker": "string",
      "identity": "string",
      "website": "string",
      "security_contact": "string",
      "details": "string"
    },
    "unbonding_height": "string",
    "unbonding_time": "2019-08-24T14:15:22Z",
    "commission": {
      "commission_rates": {
        "rate": "string",
        "max_rate": "string",
        "max_change_rate": "string"
      },
      "update_time": "2019-08-24T14:15:22Z"
    },
    "min_self_delegation": "string",
    "unbonding_on_hold_ref_count": "string",
    "unbonding_ids": [
      "string"
    ]
  }
}

```

QueryValidatorResponse is response type for the Query/Validator RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validator|object|false|none|Validator defines a validator, together with the total amount of the<br />Validator's bond shares and their exchange rate to coins. Slashing results in<br />a decrease in the exchange rate, allowing correct calculation of future<br />undelegations without iterating over delegators. When coins are delegated to<br />this validator, the validator is credited with a delegation whose number of<br />bond shares is based on the amount of coins delegated divided by the current<br />exchange rate. Voting power can be calculated as total bonded shares<br />multiplied by exchange rate.|
|» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|» description|object|false|none|description defines the description terms for the validator.|
|»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»» website|string|false|none|website defines an optional website link.|
|»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»» details|string|false|none|details define other optional details.|
|» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|» commission|object|false|none|commission defines the commission parameters.|
|»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse

<a id="schemacosmos.staking.v1beta1.queryvalidatorunbondingdelegationsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryvalidatorunbondingdelegationsresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryvalidatorunbondingdelegationsresponse"></a>

```json
{
  "unbonding_responses": [
    {
      "delegator_address": "string",
      "validator_address": "string",
      "entries": [
        {
          "creation_height": "string",
          "completion_time": "2019-08-24T14:15:22Z",
          "initial_balance": "string",
          "balance": "string",
          "unbonding_id": "string",
          "unbonding_on_hold_ref_count": "string"
        }
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryValidatorUnbondingDelegationsResponse is response type for the
Query/ValidatorUnbondingDelegations RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|unbonding_responses|[object]|false|none|none|
|» delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|» validator_address|string|false|none|validator_address is the encoded address of the validator.|
|» entries|[object]|false|none|entries are the unbonding delegation entries.|
|»» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|»» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|»» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|»» balance|string|false|none|balance defines the tokens to receive at completion.|
|»» unbonding_id|string(uint64)|false|none|none|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.staking.v1beta1.QueryValidatorsResponse

<a id="schemacosmos.staking.v1beta1.queryvalidatorsresponse"></a>
<a id="schema_cosmos.staking.v1beta1.QueryValidatorsResponse"></a>
<a id="tocScosmos.staking.v1beta1.queryvalidatorsresponse"></a>
<a id="tocscosmos.staking.v1beta1.queryvalidatorsresponse"></a>

```json
{
  "validators": [
    {
      "operator_address": "string",
      "consensus_pubkey": {
        "type_url": "string",
        "value": "string"
      },
      "jailed": true,
      "status": "BOND_STATUS_UNSPECIFIED",
      "tokens": "string",
      "delegator_shares": "string",
      "description": {
        "moniker": "string",
        "identity": "string",
        "website": "string",
        "security_contact": "string",
        "details": "string"
      },
      "unbonding_height": "string",
      "unbonding_time": "2019-08-24T14:15:22Z",
      "commission": {
        "commission_rates": {
          "rate": "string",
          "max_rate": "string",
          "max_change_rate": "string"
        },
        "update_time": "2019-08-24T14:15:22Z"
      },
      "min_self_delegation": "string",
      "unbonding_on_hold_ref_count": "string",
      "unbonding_ids": [
        "string"
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

QueryValidatorsResponse is response type for the Query/Validators RPC method

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validators|[object]|false|none|validators contains all the queried validators.|
|» operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|» consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|» status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|» tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|» delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|» description|object|false|none|description defines the description terms for the validator.|
|»» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|»» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|»» website|string|false|none|website defines an optional website link.|
|»» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|»» details|string|false|none|details define other optional details.|
|» unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|» unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|» commission|object|false|none|commission defines the commission parameters.|
|»» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|»» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|» min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» unbonding_ids|[string]|false|none|none|
|pagination|object|false|none|pagination defines the pagination in the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## cosmos.staking.v1beta1.Redelegation

<a id="schemacosmos.staking.v1beta1.redelegation"></a>
<a id="schema_cosmos.staking.v1beta1.Redelegation"></a>
<a id="tocScosmos.staking.v1beta1.redelegation"></a>
<a id="tocscosmos.staking.v1beta1.redelegation"></a>

```json
{
  "delegator_address": "string",
  "validator_src_address": "string",
  "validator_dst_address": "string",
  "entries": [
    {
      "creation_height": "string",
      "completion_time": "2019-08-24T14:15:22Z",
      "initial_balance": "string",
      "shares_dst": "string",
      "unbonding_id": "string",
      "unbonding_on_hold_ref_count": "string"
    }
  ]
}

```

Redelegation contains the list of a particular delegator's redelegating bonds
from a particular source validator to a particular destination validator.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegator_address|string|false|none|delegator_address is the bech32-encoded address of the delegator.|
|validator_src_address|string|false|none|validator_src_address is the validator redelegation source operator address.|
|validator_dst_address|string|false|none|validator_dst_address is the validator redelegation destination operator address.|
|entries|[object]|false|none|entries are the redelegation entries.|
|» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|» unbonding_id|string(uint64)|false|none|none|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|

## cosmos.staking.v1beta1.RedelegationEntry

<a id="schemacosmos.staking.v1beta1.redelegationentry"></a>
<a id="schema_cosmos.staking.v1beta1.RedelegationEntry"></a>
<a id="tocScosmos.staking.v1beta1.redelegationentry"></a>
<a id="tocscosmos.staking.v1beta1.redelegationentry"></a>

```json
{
  "creation_height": "string",
  "completion_time": "2019-08-24T14:15:22Z",
  "initial_balance": "string",
  "shares_dst": "string",
  "unbonding_id": "string",
  "unbonding_on_hold_ref_count": "string"
}

```

RedelegationEntry defines a redelegation object with relevant metadata.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|unbonding_id|string(uint64)|false|none|none|
|unbonding_on_hold_ref_count|string(int64)|false|none|none|

## cosmos.staking.v1beta1.RedelegationEntryResponse

<a id="schemacosmos.staking.v1beta1.redelegationentryresponse"></a>
<a id="schema_cosmos.staking.v1beta1.RedelegationEntryResponse"></a>
<a id="tocScosmos.staking.v1beta1.redelegationentryresponse"></a>
<a id="tocscosmos.staking.v1beta1.redelegationentryresponse"></a>

```json
{
  "redelegation_entry": {
    "creation_height": "string",
    "completion_time": "2019-08-24T14:15:22Z",
    "initial_balance": "string",
    "shares_dst": "string",
    "unbonding_id": "string",
    "unbonding_on_hold_ref_count": "string"
  },
  "balance": "string"
}

```

RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
contains a balance in addition to shares which is more suitable for client
responses.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|redelegation_entry|object|false|none|RedelegationEntry defines a redelegation object with relevant metadata.|
|» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|» unbonding_id|string(uint64)|false|none|none|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|balance|string|false|none|none|

## cosmos.staking.v1beta1.RedelegationResponse

<a id="schemacosmos.staking.v1beta1.redelegationresponse"></a>
<a id="schema_cosmos.staking.v1beta1.RedelegationResponse"></a>
<a id="tocScosmos.staking.v1beta1.redelegationresponse"></a>
<a id="tocscosmos.staking.v1beta1.redelegationresponse"></a>

```json
{
  "redelegation": {
    "delegator_address": "string",
    "validator_src_address": "string",
    "validator_dst_address": "string",
    "entries": [
      {
        "creation_height": "string",
        "completion_time": "2019-08-24T14:15:22Z",
        "initial_balance": "string",
        "shares_dst": "string",
        "unbonding_id": "string",
        "unbonding_on_hold_ref_count": "string"
      }
    ]
  },
  "entries": [
    {
      "redelegation_entry": {
        "creation_height": "string",
        "completion_time": "2019-08-24T14:15:22Z",
        "initial_balance": "string",
        "shares_dst": "string",
        "unbonding_id": "string",
        "unbonding_on_hold_ref_count": "string"
      },
      "balance": "string"
    }
  ]
}

```

RedelegationResponse is equivalent to a Redelegation except that its entries
contain a balance in addition to shares which is more suitable for client
responses.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|redelegation|object|false|none|Redelegation contains the list of a particular delegator's redelegating bonds<br />from a particular source validator to a particular destination validator.|
|» delegator_address|string|false|none|delegator_address is the bech32-encoded address of the delegator.|
|» validator_src_address|string|false|none|validator_src_address is the validator redelegation source operator address.|
|» validator_dst_address|string|false|none|validator_dst_address is the validator redelegation destination operator address.|
|» entries|[object]|false|none|entries are the redelegation entries.|
|»» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|»» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|»» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|»» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|»» unbonding_id|string(uint64)|false|none|none|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|entries|[object]|false|none|none|
|» redelegation_entry|object|false|none|RedelegationEntry defines a redelegation object with relevant metadata.|
|»» creation_height|string(int64)|false|none|creation_height  defines the height which the redelegation took place.|
|»» completion_time|string(date-time)|false|none|completion_time defines the unix time for redelegation completion.|
|»» initial_balance|string|false|none|initial_balance defines the initial balance when redelegation started.|
|»» shares_dst|string|false|none|shares_dst is the amount of destination-validator shares created by redelegation.|
|»» unbonding_id|string(uint64)|false|none|none|
|»» unbonding_on_hold_ref_count|string(int64)|false|none|none|
|» balance|string|false|none|none|

## cosmos.staking.v1beta1.UnbondingDelegation

<a id="schemacosmos.staking.v1beta1.unbondingdelegation"></a>
<a id="schema_cosmos.staking.v1beta1.UnbondingDelegation"></a>
<a id="tocScosmos.staking.v1beta1.unbondingdelegation"></a>
<a id="tocscosmos.staking.v1beta1.unbondingdelegation"></a>

```json
{
  "delegator_address": "string",
  "validator_address": "string",
  "entries": [
    {
      "creation_height": "string",
      "completion_time": "2019-08-24T14:15:22Z",
      "initial_balance": "string",
      "balance": "string",
      "unbonding_id": "string",
      "unbonding_on_hold_ref_count": "string"
    }
  ]
}

```

UnbondingDelegation stores all of a single delegator's unbonding bonds
for a single validator in an time-ordered list.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|delegator_address|string|false|none|delegator_address is the encoded address of the delegator.|
|validator_address|string|false|none|validator_address is the encoded address of the validator.|
|entries|[object]|false|none|entries are the unbonding delegation entries.|
|» creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|» completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|» initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|» balance|string|false|none|balance defines the tokens to receive at completion.|
|» unbonding_id|string(uint64)|false|none|none|
|» unbonding_on_hold_ref_count|string(int64)|false|none|none|

## cosmos.staking.v1beta1.UnbondingDelegationEntry

<a id="schemacosmos.staking.v1beta1.unbondingdelegationentry"></a>
<a id="schema_cosmos.staking.v1beta1.UnbondingDelegationEntry"></a>
<a id="tocScosmos.staking.v1beta1.unbondingdelegationentry"></a>
<a id="tocscosmos.staking.v1beta1.unbondingdelegationentry"></a>

```json
{
  "creation_height": "string",
  "completion_time": "2019-08-24T14:15:22Z",
  "initial_balance": "string",
  "balance": "string",
  "unbonding_id": "string",
  "unbonding_on_hold_ref_count": "string"
}

```

UnbondingDelegationEntry defines an unbonding object with relevant metadata.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|creation_height|string(int64)|false|none|creation_height is the height which the unbonding took place.|
|completion_time|string(date-time)|false|none|completion_time is the unix time for unbonding completion.|
|initial_balance|string|false|none|initial_balance defines the tokens initially scheduled to receive at completion.|
|balance|string|false|none|balance defines the tokens to receive at completion.|
|unbonding_id|string(uint64)|false|none|none|
|unbonding_on_hold_ref_count|string(int64)|false|none|none|

## cosmos.staking.v1beta1.Validator

<a id="schemacosmos.staking.v1beta1.validator"></a>
<a id="schema_cosmos.staking.v1beta1.Validator"></a>
<a id="tocScosmos.staking.v1beta1.validator"></a>
<a id="tocscosmos.staking.v1beta1.validator"></a>

```json
{
  "operator_address": "string",
  "consensus_pubkey": {
    "type_url": "string",
    "value": "string"
  },
  "jailed": true,
  "status": "BOND_STATUS_UNSPECIFIED",
  "tokens": "string",
  "delegator_shares": "string",
  "description": {
    "moniker": "string",
    "identity": "string",
    "website": "string",
    "security_contact": "string",
    "details": "string"
  },
  "unbonding_height": "string",
  "unbonding_time": "2019-08-24T14:15:22Z",
  "commission": {
    "commission_rates": {
      "rate": "string",
      "max_rate": "string",
      "max_change_rate": "string"
    },
    "update_time": "2019-08-24T14:15:22Z"
  },
  "min_self_delegation": "string",
  "unbonding_on_hold_ref_count": "string",
  "unbonding_ids": [
    "string"
  ]
}

```

Validator defines a validator, together with the total amount of the
Validator's bond shares and their exchange rate to coins. Slashing results in
a decrease in the exchange rate, allowing correct calculation of future
undelegations without iterating over delegators. When coins are delegated to
this validator, the validator is credited with a delegation whose number of
bond shares is based on the amount of coins delegated divided by the current
exchange rate. Voting power can be calculated as total bonded shares
multiplied by exchange rate.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|operator_address|string|false|none|operator_address defines the address of the validator's operator; bech encoded in JSON.|
|consensus_pubkey|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|jailed|boolean|false|none|jailed defined whether the validator has been jailed from bonded status or not.|
|status|string|false|none|status is the validator status (bonded/unbonding/unbonded).|
|tokens|string|false|none|tokens define the delegated tokens (incl. self-delegation).|
|delegator_shares|string|false|none|delegator_shares defines total shares issued to a validator's delegators.|
|description|object|false|none|description defines the description terms for the validator.|
|» moniker|string|false|none|moniker defines a human-readable name for the validator.|
|» identity|string|false|none|identity defines an optional identity signature (ex. UPort or Keybase).|
|» website|string|false|none|website defines an optional website link.|
|» security_contact|string|false|none|security_contact defines an optional email for security contact.|
|» details|string|false|none|details define other optional details.|
|unbonding_height|string(int64)|false|none|unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.|
|unbonding_time|string(date-time)|false|none|unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.|
|commission|object|false|none|commission defines the commission parameters.|
|» commission_rates|object|false|none|commission_rates defines the initial commission rates to be used for creating a validator.|
|»» rate|string|false|none|rate is the commission rate charged to delegators, as a fraction.|
|»» max_rate|string|false|none|max_rate defines the maximum commission rate which validator can ever charge, as a fraction.|
|»» max_change_rate|string|false|none|max_change_rate defines the maximum daily increase of the validator commission, as a fraction.|
|» update_time|string(date-time)|false|none|update_time is the last time the commission rate was changed.|
|min_self_delegation|string|false|none|min_self_delegation is the validator's self declared minimum self delegation.<br /><br />Since: cosmos-sdk 0.46|
|unbonding_on_hold_ref_count|string(int64)|false|none|none|
|unbonding_ids|[string]|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|status|BOND_STATUS_UNSPECIFIED|
|status|BOND_STATUS_UNBONDED|
|status|BOND_STATUS_UNBONDING|
|status|BOND_STATUS_BONDED|

## tendermint.types.BlockID

<a id="schematendermint.types.blockid"></a>
<a id="schema_tendermint.types.BlockID"></a>
<a id="tocStendermint.types.blockid"></a>
<a id="tocstendermint.types.blockid"></a>

```json
{
  "hash": "string",
  "part_set_header": {
    "total": 0,
    "hash": "string"
  }
}

```

BlockID

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|hash|string(byte)|false|none|none|
|part_set_header|object|false|none|none|
|» total|integer(int64)|false|none|none|
|» hash|string(byte)|false|none|none|

## tendermint.types.Header

<a id="schematendermint.types.header"></a>
<a id="schema_tendermint.types.Header"></a>
<a id="tocStendermint.types.header"></a>
<a id="tocstendermint.types.header"></a>

```json
{
  "version": {
    "block": "string",
    "app": "string"
  },
  "chain_id": "string",
  "height": "string",
  "time": "2019-08-24T14:15:22Z",
  "last_block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "last_commit_hash": "string",
  "data_hash": "string",
  "validators_hash": "string",
  "next_validators_hash": "string",
  "consensus_hash": "string",
  "app_hash": "string",
  "last_results_hash": "string",
  "evidence_hash": "string",
  "proposer_address": "string"
}

```

Header defines the structure of a block header.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|» block|string(uint64)|false|none|none|
|» app|string(uint64)|false|none|none|
|chain_id|string|false|none|none|
|height|string(int64)|false|none|none|
|time|string(date-time)|false|none|none|
|last_block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|last_commit_hash|string(byte)|false|none|none|
|data_hash|string(byte)|false|none|none|
|validators_hash|string(byte)|false|none|none|
|next_validators_hash|string(byte)|false|none|none|
|consensus_hash|string(byte)|false|none|none|
|app_hash|string(byte)|false|none|none|
|last_results_hash|string(byte)|false|none|none|
|evidence_hash|string(byte)|false|none|none|
|proposer_address|string(byte)|false|none|none|

## tendermint.types.PartSetHeader

<a id="schematendermint.types.partsetheader"></a>
<a id="schema_tendermint.types.PartSetHeader"></a>
<a id="tocStendermint.types.partsetheader"></a>
<a id="tocstendermint.types.partsetheader"></a>

```json
{
  "total": 0,
  "hash": "string"
}

```

PartsetHeader

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|total|integer(int64)|false|none|none|
|hash|string(byte)|false|none|none|

## tendermint.version.Consensus

<a id="schematendermint.version.consensus"></a>
<a id="schema_tendermint.version.Consensus"></a>
<a id="tocStendermint.version.consensus"></a>
<a id="tocstendermint.version.consensus"></a>

```json
{
  "block": "string",
  "app": "string"
}

```

Consensus captures the consensus rules for processing a block in the blockchain,
including all blockchain data structures and the rules of the application's
state transition machine.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block|string(uint64)|false|none|none|
|app|string(uint64)|false|none|none|

## cosmos.base.abci.v1beta1.ABCIMessageLog

<a id="schemacosmos.base.abci.v1beta1.abcimessagelog"></a>
<a id="schema_cosmos.base.abci.v1beta1.ABCIMessageLog"></a>
<a id="tocScosmos.base.abci.v1beta1.abcimessagelog"></a>
<a id="tocscosmos.base.abci.v1beta1.abcimessagelog"></a>

```json
{
  "msg_index": 0,
  "log": "string",
  "events": [
    {
      "type": "string",
      "attributes": [
        {
          "key": "string",
          "value": "string"
        }
      ]
    }
  ]
}

```

ABCIMessageLog defines a structure containing an indexed tx ABCI message log.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|msg_index|integer(int64)|false|none|none|
|log|string|false|none|none|
|events|[object]|false|none|Events contains a slice of Event objects that were emitted during some<br />execution.|
|» type|string|false|none|none|
|» attributes|[object]|false|none|none|
|»» key|string|false|none|none|
|»» value|string|false|none|none|

## cosmos.base.abci.v1beta1.Attribute

<a id="schemacosmos.base.abci.v1beta1.attribute"></a>
<a id="schema_cosmos.base.abci.v1beta1.Attribute"></a>
<a id="tocScosmos.base.abci.v1beta1.attribute"></a>
<a id="tocscosmos.base.abci.v1beta1.attribute"></a>

```json
{
  "key": "string",
  "value": "string"
}

```

Attribute defines an attribute wrapper where the key and value are
strings instead of raw bytes.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|key|string|false|none|none|
|value|string|false|none|none|

## cosmos.base.abci.v1beta1.GasInfo

<a id="schemacosmos.base.abci.v1beta1.gasinfo"></a>
<a id="schema_cosmos.base.abci.v1beta1.GasInfo"></a>
<a id="tocScosmos.base.abci.v1beta1.gasinfo"></a>
<a id="tocscosmos.base.abci.v1beta1.gasinfo"></a>

```json
{
  "gas_wanted": "string",
  "gas_used": "string"
}

```

GasInfo defines tx execution gas context.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|gas_wanted|string(uint64)|false|none|GasWanted is the maximum units of work we allow this tx to perform.|
|gas_used|string(uint64)|false|none|GasUsed is the amount of gas actually consumed.|

## cosmos.base.abci.v1beta1.Result

<a id="schemacosmos.base.abci.v1beta1.result"></a>
<a id="schema_cosmos.base.abci.v1beta1.Result"></a>
<a id="tocScosmos.base.abci.v1beta1.result"></a>
<a id="tocscosmos.base.abci.v1beta1.result"></a>

```json
{
  "data": "string",
  "log": "string",
  "events": [
    {
      "type": "string",
      "attributes": [
        {
          "key": "string",
          "value": "string",
          "index": true
        }
      ]
    }
  ],
  "msg_responses": [
    {
      "type_url": "string",
      "value": "string"
    }
  ]
}

```

Result is the union of ResponseFormat and ResponseCheckTx.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|data|string(byte)|false|none|Data is any data returned from message or handler execution. It MUST be<br />length prefixed in order to separate data from multiple message executions.<br />Deprecated. This field is still populated, but prefer msg_response instead<br />because it also contains the Msg response typeURL.|
|log|string|false|none|Log contains the log information from message or handler execution.|
|events|[object]|false|none|Events contains a slice of Event objects that were emitted during message<br />or handler execution.|
|» type|string|false|none|none|
|» attributes|[object]|false|none|none|
|»» key|string|false|none|none|
|»» value|string|false|none|none|
|»» index|boolean|false|none|none|
|msg_responses|[object]|false|none|msg_responses contains the Msg handler responses type packed in Anys.<br /><br />Since: cosmos-sdk 0.46|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.base.abci.v1beta1.StringEvent

<a id="schemacosmos.base.abci.v1beta1.stringevent"></a>
<a id="schema_cosmos.base.abci.v1beta1.StringEvent"></a>
<a id="tocScosmos.base.abci.v1beta1.stringevent"></a>
<a id="tocscosmos.base.abci.v1beta1.stringevent"></a>

```json
{
  "type": "string",
  "attributes": [
    {
      "key": "string",
      "value": "string"
    }
  ]
}

```

StringEvent defines en Event object wrapper where all the attributes
contain key/value pairs that are strings instead of raw bytes.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|type|string|false|none|none|
|attributes|[object]|false|none|none|
|» key|string|false|none|none|
|» value|string|false|none|none|

## cosmos.base.abci.v1beta1.TxResponse

<a id="schemacosmos.base.abci.v1beta1.txresponse"></a>
<a id="schema_cosmos.base.abci.v1beta1.TxResponse"></a>
<a id="tocScosmos.base.abci.v1beta1.txresponse"></a>
<a id="tocscosmos.base.abci.v1beta1.txresponse"></a>

```json
{
  "height": "string",
  "txhash": "string",
  "codespace": "string",
  "code": 0,
  "data": "string",
  "raw_log": "string",
  "logs": [
    {
      "msg_index": 0,
      "log": "string",
      "events": [
        {
          "type": "string",
          "attributes": [
            {}
          ]
        }
      ]
    }
  ],
  "info": "string",
  "gas_wanted": "string",
  "gas_used": "string",
  "tx": {
    "type_url": "string",
    "value": "string"
  },
  "timestamp": "string",
  "events": [
    {
      "type": "string",
      "attributes": [
        {
          "key": "string",
          "value": "string",
          "index": true
        }
      ]
    }
  ]
}

```

TxResponse defines a structure containing relevant tx data and metadata. The
tags are stringified and the log is JSON decoded.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|height|string(int64)|false|none|none|
|txhash|string|false|none|The transaction hash.|
|codespace|string|false|none|none|
|code|integer(int64)|false|none|Response code.|
|data|string|false|none|Result bytes, if any.|
|raw_log|string|false|none|The output of the application's logger (raw string). May be<br />non-deterministic.|
|logs|[object]|false|none|The output of the application's logger (typed). May be non-deterministic.|
|» msg_index|integer(int64)|false|none|none|
|» log|string|false|none|none|
|» events|[object]|false|none|Events contains a slice of Event objects that were emitted during some<br />execution.|
|»» type|string|false|none|none|
|»» attributes|[object]|false|none|none|
|»»» key|string|false|none|none|
|»»» value|string|false|none|none|
|info|string|false|none|Additional information. May be non-deterministic.|
|gas_wanted|string(int64)|false|none|Amount of gas requested for transaction.|
|gas_used|string(int64)|false|none|Amount of gas consumed by transaction.|
|tx|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|timestamp|string|false|none|Time of the previous block. For heights > 1, it's the weighted median of<br />the timestamps of the valid votes in the block.LastCommit. For height == 1,<br />it's genesis time.|
|events|[object]|false|none|Events defines all the events emitted by processing a transaction. Note,<br />these events include those emitted by processing all the messages and those<br />emitted from the ante. Whereas Logs contains the events, with<br />additional metadata, emitted only by processing the messages.<br /><br />Since: cosmos-sdk 0.42.11, 0.44.5, 0.45|
|» type|string|false|none|none|
|» attributes|[object]|false|none|none|
|»» key|string|false|none|none|
|»» value|string|false|none|none|
|»» index|boolean|false|none|none|

## cosmos.crypto.multisig.v1beta1.CompactBitArray

<a id="schemacosmos.crypto.multisig.v1beta1.compactbitarray"></a>
<a id="schema_cosmos.crypto.multisig.v1beta1.CompactBitArray"></a>
<a id="tocScosmos.crypto.multisig.v1beta1.compactbitarray"></a>
<a id="tocscosmos.crypto.multisig.v1beta1.compactbitarray"></a>

```json
{
  "extra_bits_stored": 0,
  "elems": "string"
}

```

CompactBitArray is an implementation of a space efficient bit array.
This is used to ensure that the encoded data takes up a minimal amount of
space after proto encoding.
This is not thread safe, and is not intended for concurrent usage.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|extra_bits_stored|integer(int64)|false|none|none|
|elems|string(byte)|false|none|none|

## cosmos.tx.signing.v1beta1.SignMode

<a id="schemacosmos.tx.signing.v1beta1.signmode"></a>
<a id="schema_cosmos.tx.signing.v1beta1.SignMode"></a>
<a id="tocScosmos.tx.signing.v1beta1.signmode"></a>
<a id="tocscosmos.tx.signing.v1beta1.signmode"></a>

```json
"SIGN_MODE_UNSPECIFIED"

```

SignMode represents a signing mode with its own security guarantees.

This enum should be considered a registry of all known sign modes
in the Cosmos ecosystem. Apps are not expected to support all known
sign modes. Apps that would like to support custom  sign modes are
encouraged to open a small PR against this file to add a new case
to this SignMode enum describing their sign mode so that different
apps have a consistent version of this enum.

 - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
rejected.
 - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
verified with raw bytes from Tx.
 - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
human-readable textual representation on top of the binary representation
from SIGN_MODE_DIRECT. It is currently experimental, and should be used
for testing purposes only, until Textual is fully released. Please follow
the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.
 - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
require signers signing over other signers' `signer_info`. It also allows
for adding Tips in transactions.

Since: cosmos-sdk 0.46
 - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
Amino JSON and will be removed in the future.
 - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
SDK. Ref: https://eips.ethereum.org/EIPS/eip-191

Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
but is not implemented on the SDK by default. To enable EIP-191, you need
to pass a custom `TxConfig` that has an implementation of
`SignModeHandler` for EIP-191. The SDK may decide to fully support
EIP-191 in the future.

Since: cosmos-sdk 0.45.2

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|SignMode represents a signing mode with its own security guarantees.<br /><br />This enum should be considered a registry of all known sign modes<br />in the Cosmos ecosystem. Apps are not expected to support all known<br />sign modes. Apps that would like to support custom  sign modes are<br />encouraged to open a small PR against this file to add a new case<br />to this SignMode enum describing their sign mode so that different<br />apps have a consistent version of this enum.<br /><br /> - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be<br />rejected.<br /> - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is<br />verified with raw bytes from Tx.<br /> - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some<br />human-readable textual representation on top of the binary representation<br />from SIGN_MODE_DIRECT. It is currently experimental, and should be used<br />for testing purposes only, until Textual is fully released. Please follow<br />the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.<br /> - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses<br />SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not<br />require signers signing over other signers' `signer_info`. It also allows<br />for adding Tips in transactions.<br /><br />Since: cosmos-sdk 0.46<br /> - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses<br />Amino JSON and will be removed in the future.<br /> - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos<br />SDK. Ref: https://eips.ethereum.org/EIPS/eip-191<br /><br />Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,<br />but is not implemented on the SDK by default. To enable EIP-191, you need<br />to pass a custom `TxConfig` that has an implementation of<br />`SignModeHandler` for EIP-191. The SDK may decide to fully support<br />EIP-191 in the future.<br /><br />Since: cosmos-sdk 0.45.2|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|SIGN_MODE_UNSPECIFIED|
|*anonymous*|SIGN_MODE_DIRECT|
|*anonymous*|SIGN_MODE_TEXTUAL|
|*anonymous*|SIGN_MODE_DIRECT_AUX|
|*anonymous*|SIGN_MODE_LEGACY_AMINO_JSON|
|*anonymous*|SIGN_MODE_EIP_191|

## cosmos.tx.v1beta1.AuthInfo

<a id="schemacosmos.tx.v1beta1.authinfo"></a>
<a id="schema_cosmos.tx.v1beta1.AuthInfo"></a>
<a id="tocScosmos.tx.v1beta1.authinfo"></a>
<a id="tocscosmos.tx.v1beta1.authinfo"></a>

```json
{
  "signer_infos": [
    {
      "public_key": {
        "type_url": "string",
        "value": "string"
      },
      "mode_info": {
        "single": {
          "mode": "["
        },
        "multi": {
          "bitarray": {},
          "mode_infos": [
            null
          ]
        }
      },
      "sequence": "string"
    }
  ],
  "fee": {
    "amount": [
      {
        "denom": "string",
        "amount": "string"
      }
    ],
    "gas_limit": "string",
    "payer": "string",
    "granter": "string"
  },
  "tip": {
    "amount": [
      {
        "denom": "string",
        "amount": "string"
      }
    ],
    "tipper": "string"
  }
}

```

AuthInfo describes the fee and signer modes that are used to sign a
transaction.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|signer_infos|[[cosmos.tx.v1beta1.SignerInfo](#schemacosmos.tx.v1beta1.signerinfo)]|false|none|signer_infos defines the signing modes for the required signers. The number<br />and order of elements must match the required signers from TxBody's<br />messages. The first element is the primary signer and the one which pays<br />the fee.|
|fee|object|false|none|Fee is the fee and gas limit for the transaction. The first signer is the<br />primary signer and the one which pays the fee. The fee can be calculated<br />based on the cost of evaluating the body and doing signature verification<br />of the signers. This can be estimated via simulation.|
|» amount|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» gas_limit|string(uint64)|false|none|none|
|» payer|string|false|none|if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.<br />the payer must be a tx signer (and thus have signed this field in AuthInfo).<br />setting this field does *not* change the ordering of required signers for the transaction.|
|» granter|string|false|none|none|
|tip|object|false|none|Tip is the optional tip used for transactions fees paid in another denom.<br /><br />This field is ignored if the chain didn't enable tips, i.e. didn't add the<br />`TipDecorator` in its posthandler.<br /><br />Since: cosmos-sdk 0.46|
|» amount|[object]|false|none|none|
|»» denom|string|false|none|none|
|»» amount|string|false|none|none|
|» tipper|string|false|none|none|

## cosmos.tx.v1beta1.BroadcastMode

<a id="schemacosmos.tx.v1beta1.broadcastmode"></a>
<a id="schema_cosmos.tx.v1beta1.BroadcastMode"></a>
<a id="tocScosmos.tx.v1beta1.broadcastmode"></a>
<a id="tocscosmos.tx.v1beta1.broadcastmode"></a>

```json
"BROADCAST_MODE_UNSPECIFIED"

```

BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
method.

 - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
 - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
 - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
for a CheckTx execution response only.
 - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
returns immediately.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC<br />method.<br /><br /> - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering<br /> - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,<br />BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.<br /> - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits<br />for a CheckTx execution response only.<br /> - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client<br />returns immediately.|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|BROADCAST_MODE_UNSPECIFIED|
|*anonymous*|BROADCAST_MODE_BLOCK|
|*anonymous*|BROADCAST_MODE_SYNC|
|*anonymous*|BROADCAST_MODE_ASYNC|

## cosmos.tx.v1beta1.BroadcastTxRequest

<a id="schemacosmos.tx.v1beta1.broadcasttxrequest"></a>
<a id="schema_cosmos.tx.v1beta1.BroadcastTxRequest"></a>
<a id="tocScosmos.tx.v1beta1.broadcasttxrequest"></a>
<a id="tocscosmos.tx.v1beta1.broadcasttxrequest"></a>

```json
{
  "tx_bytes": "string",
  "mode": "BROADCAST_MODE_UNSPECIFIED"
}

```

BroadcastTxRequest is the request type for the Service.BroadcastTxRequest
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx_bytes|string(byte)|false|none|tx_bytes is the raw transaction.|
|mode|string|false|none|BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC<br />method.<br /><br /> - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering<br /> - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,<br />BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.<br /> - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits<br />for a CheckTx execution response only.<br /> - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client<br />returns immediately.|

#### Enumerated Values

|Property|Value|
|---|---|
|mode|BROADCAST_MODE_UNSPECIFIED|
|mode|BROADCAST_MODE_BLOCK|
|mode|BROADCAST_MODE_SYNC|
|mode|BROADCAST_MODE_ASYNC|

## cosmos.tx.v1beta1.BroadcastTxResponse

<a id="schemacosmos.tx.v1beta1.broadcasttxresponse"></a>
<a id="schema_cosmos.tx.v1beta1.BroadcastTxResponse"></a>
<a id="tocScosmos.tx.v1beta1.broadcasttxresponse"></a>
<a id="tocscosmos.tx.v1beta1.broadcasttxresponse"></a>

```json
{
  "tx_response": {
    "height": "string",
    "txhash": "string",
    "codespace": "string",
    "code": 0,
    "data": "string",
    "raw_log": "string",
    "logs": [
      {
        "msg_index": 0,
        "log": "string",
        "events": [
          {
            "type": null,
            "attributes": null
          }
        ]
      }
    ],
    "info": "string",
    "gas_wanted": "string",
    "gas_used": "string",
    "tx": {
      "type_url": "string",
      "value": "string"
    },
    "timestamp": "string",
    "events": [
      {
        "type": "string",
        "attributes": [
          {
            "key": null,
            "value": null,
            "index": null
          }
        ]
      }
    ]
  }
}

```

BroadcastTxResponse is the response type for the
Service.BroadcastTx method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx_response|object|false|none|TxResponse defines a structure containing relevant tx data and metadata. The<br />tags are stringified and the log is JSON decoded.|
|» height|string(int64)|false|none|none|
|» txhash|string|false|none|The transaction hash.|
|» codespace|string|false|none|none|
|» code|integer(int64)|false|none|Response code.|
|» data|string|false|none|Result bytes, if any.|
|» raw_log|string|false|none|The output of the application's logger (raw string). May be<br />non-deterministic.|
|» logs|[object]|false|none|The output of the application's logger (typed). May be non-deterministic.|
|»» msg_index|integer(int64)|false|none|none|
|»» log|string|false|none|none|
|»» events|[object]|false|none|Events contains a slice of Event objects that were emitted during some<br />execution.|
|»»» type|string|false|none|none|
|»»» attributes|[object]|false|none|none|
|»»»» key|string|false|none|none|
|»»»» value|string|false|none|none|
|» info|string|false|none|Additional information. May be non-deterministic.|
|» gas_wanted|string(int64)|false|none|Amount of gas requested for transaction.|
|» gas_used|string(int64)|false|none|Amount of gas consumed by transaction.|
|» tx|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» timestamp|string|false|none|Time of the previous block. For heights > 1, it's the weighted median of<br />the timestamps of the valid votes in the block.LastCommit. For height == 1,<br />it's genesis time.|
|» events|[object]|false|none|Events defines all the events emitted by processing a transaction. Note,<br />these events include those emitted by processing all the messages and those<br />emitted from the ante. Whereas Logs contains the events, with<br />additional metadata, emitted only by processing the messages.<br /><br />Since: cosmos-sdk 0.42.11, 0.44.5, 0.45|
|»» type|string|false|none|none|
|»» attributes|[object]|false|none|none|
|»»» key|string|false|none|none|
|»»» value|string|false|none|none|
|»»» index|boolean|false|none|none|

## cosmos.tx.v1beta1.Fee

<a id="schemacosmos.tx.v1beta1.fee"></a>
<a id="schema_cosmos.tx.v1beta1.Fee"></a>
<a id="tocScosmos.tx.v1beta1.fee"></a>
<a id="tocscosmos.tx.v1beta1.fee"></a>

```json
{
  "amount": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "gas_limit": "string",
  "payer": "string",
  "granter": "string"
}

```

Fee includes the amount of coins paid in fees and the maximum
gas to be used by the transaction. The ratio yields an effective "gasprice",
which must be above some miminum to be accepted into the mempool.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amount|[object]|false|none|none|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|gas_limit|string(uint64)|false|none|none|
|payer|string|false|none|if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.<br />the payer must be a tx signer (and thus have signed this field in AuthInfo).<br />setting this field does *not* change the ordering of required signers for the transaction.|
|granter|string|false|none|none|

## cosmos.tx.v1beta1.GetBlockWithTxsResponse

<a id="schemacosmos.tx.v1beta1.getblockwithtxsresponse"></a>
<a id="schema_cosmos.tx.v1beta1.GetBlockWithTxsResponse"></a>
<a id="tocScosmos.tx.v1beta1.getblockwithtxsresponse"></a>
<a id="tocscosmos.tx.v1beta1.getblockwithtxsresponse"></a>

```json
{
  "txs": [
    {
      "body": {
        "messages": [
          {
            "type_url": null,
            "value": null
          }
        ],
        "memo": "string",
        "timeout_height": "string",
        "extension_options": [
          {
            "type_url": null,
            "value": null
          }
        ],
        "non_critical_extension_options": [
          {
            "type_url": null,
            "value": null
          }
        ]
      },
      "auth_info": {
        "signer_infos": [
          {
            "public_key": null,
            "mode_info": null,
            "sequence": null
          }
        ],
        "fee": {
          "amount": [
            null
          ],
          "gas_limit": "string",
          "payer": "string",
          "granter": "string"
        },
        "tip": {
          "amount": [
            null
          ],
          "tipper": "string"
        }
      },
      "signatures": [
        "string"
      ]
    }
  ],
  "block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "block": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "data": {
      "txs": [
        "string"
      ]
    },
    "evidence": {
      "evidence": [
        {
          "duplicate_vote_evidence": {},
          "light_client_attack_evidence": {}
        }
      ]
    },
    "last_commit": {
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "signatures": [
        {
          "block_id_flag": "[",
          "validator_address": "string",
          "timestamp": "2019-08-24T14:15:22Z",
          "signature": "string"
        }
      ]
    }
  },
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs
method.

Since: cosmos-sdk 0.45.2

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|txs|[[cosmos.tx.v1beta1.Tx](#schemacosmos.tx.v1beta1.tx)]|false|none|txs are the transactions in the block.|
|block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|block|object|false|none|none|
|» header|object|false|none|Header defines the structure of a block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string(byte)|false|none|none|
|» data|object|false|none|none|
|»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|» evidence|object|false|none|none|
|»» evidence|[object]|false|none|none|
|»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» validator_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»» conflicting_block|object|false|none|none|
|»»»»» signed_header|object|false|none|none|
|»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»» chain_id|string|false|none|none|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»» block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»» signature|string(byte)|false|none|none|
|»»»»» validator_set|object|false|none|none|
|»»»»»» validators|[object]|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» proposer|object|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»» common_height|string(int64)|false|none|none|
|»»»» byzantine_validators|[object]|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» signatures|[object]|false|none|none|
|»»» block_id_flag|string|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» signature|string(byte)|false|none|none|
|pagination|object|false|none|pagination defines a pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## cosmos.tx.v1beta1.GetTxResponse

<a id="schemacosmos.tx.v1beta1.gettxresponse"></a>
<a id="schema_cosmos.tx.v1beta1.GetTxResponse"></a>
<a id="tocScosmos.tx.v1beta1.gettxresponse"></a>
<a id="tocscosmos.tx.v1beta1.gettxresponse"></a>

```json
{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  },
  "tx_response": {
    "height": "string",
    "txhash": "string",
    "codespace": "string",
    "code": 0,
    "data": "string",
    "raw_log": "string",
    "logs": [
      {
        "msg_index": 0,
        "log": "string",
        "events": [
          {
            "type": null,
            "attributes": null
          }
        ]
      }
    ],
    "info": "string",
    "gas_wanted": "string",
    "gas_used": "string",
    "tx": {
      "type_url": "string",
      "value": "string"
    },
    "timestamp": "string",
    "events": [
      {
        "type": "string",
        "attributes": [
          {
            "key": null,
            "value": null,
            "index": null
          }
        ]
      }
    ]
  }
}

```

GetTxResponse is the response type for the Service.GetTx method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx|[cosmos.tx.v1beta1.Tx](#schemacosmos.tx.v1beta1.tx)|false|none|tx is the queried transaction.|
|tx_response|object|false|none|TxResponse defines a structure containing relevant tx data and metadata. The<br />tags are stringified and the log is JSON decoded.|
|» height|string(int64)|false|none|none|
|» txhash|string|false|none|The transaction hash.|
|» codespace|string|false|none|none|
|» code|integer(int64)|false|none|Response code.|
|» data|string|false|none|Result bytes, if any.|
|» raw_log|string|false|none|The output of the application's logger (raw string). May be<br />non-deterministic.|
|» logs|[object]|false|none|The output of the application's logger (typed). May be non-deterministic.|
|»» msg_index|integer(int64)|false|none|none|
|»» log|string|false|none|none|
|»» events|[object]|false|none|Events contains a slice of Event objects that were emitted during some<br />execution.|
|»»» type|string|false|none|none|
|»»» attributes|[object]|false|none|none|
|»»»» key|string|false|none|none|
|»»»» value|string|false|none|none|
|» info|string|false|none|Additional information. May be non-deterministic.|
|» gas_wanted|string(int64)|false|none|Amount of gas requested for transaction.|
|» gas_used|string(int64)|false|none|Amount of gas consumed by transaction.|
|» tx|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» timestamp|string|false|none|Time of the previous block. For heights > 1, it's the weighted median of<br />the timestamps of the valid votes in the block.LastCommit. For height == 1,<br />it's genesis time.|
|» events|[object]|false|none|Events defines all the events emitted by processing a transaction. Note,<br />these events include those emitted by processing all the messages and those<br />emitted from the ante. Whereas Logs contains the events, with<br />additional metadata, emitted only by processing the messages.<br /><br />Since: cosmos-sdk 0.42.11, 0.44.5, 0.45|
|»» type|string|false|none|none|
|»» attributes|[object]|false|none|none|
|»»» key|string|false|none|none|
|»»» value|string|false|none|none|
|»»» index|boolean|false|none|none|

## cosmos.tx.v1beta1.GetTxsEventResponse

<a id="schemacosmos.tx.v1beta1.gettxseventresponse"></a>
<a id="schema_cosmos.tx.v1beta1.GetTxsEventResponse"></a>
<a id="tocScosmos.tx.v1beta1.gettxseventresponse"></a>
<a id="tocscosmos.tx.v1beta1.gettxseventresponse"></a>

```json
{
  "txs": [
    {
      "body": {
        "messages": [
          {
            "type_url": null,
            "value": null
          }
        ],
        "memo": "string",
        "timeout_height": "string",
        "extension_options": [
          {
            "type_url": null,
            "value": null
          }
        ],
        "non_critical_extension_options": [
          {
            "type_url": null,
            "value": null
          }
        ]
      },
      "auth_info": {
        "signer_infos": [
          {
            "public_key": null,
            "mode_info": null,
            "sequence": null
          }
        ],
        "fee": {
          "amount": [
            null
          ],
          "gas_limit": "string",
          "payer": "string",
          "granter": "string"
        },
        "tip": {
          "amount": [
            null
          ],
          "tipper": "string"
        }
      },
      "signatures": [
        "string"
      ]
    }
  ],
  "tx_responses": [
    {
      "height": "string",
      "txhash": "string",
      "codespace": "string",
      "code": 0,
      "data": "string",
      "raw_log": "string",
      "logs": [
        {
          "msg_index": 0,
          "log": "string",
          "events": [
            {}
          ]
        }
      ],
      "info": "string",
      "gas_wanted": "string",
      "gas_used": "string",
      "tx": {
        "type_url": "string",
        "value": "string"
      },
      "timestamp": "string",
      "events": [
        {
          "type": "string",
          "attributes": [
            {}
          ]
        }
      ]
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  },
  "total": "string"
}

```

GetTxsEventResponse is the response type for the Service.TxsByEvents
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|txs|[[cosmos.tx.v1beta1.Tx](#schemacosmos.tx.v1beta1.tx)]|false|none|txs is the list of queried transactions.|
|tx_responses|[object]|false|none|tx_responses is the list of queried TxResponses.|
|» height|string(int64)|false|none|none|
|» txhash|string|false|none|The transaction hash.|
|» codespace|string|false|none|none|
|» code|integer(int64)|false|none|Response code.|
|» data|string|false|none|Result bytes, if any.|
|» raw_log|string|false|none|The output of the application's logger (raw string). May be<br />non-deterministic.|
|» logs|[object]|false|none|The output of the application's logger (typed). May be non-deterministic.|
|»» msg_index|integer(int64)|false|none|none|
|»» log|string|false|none|none|
|»» events|[object]|false|none|Events contains a slice of Event objects that were emitted during some<br />execution.|
|»»» type|string|false|none|none|
|»»» attributes|[object]|false|none|none|
|»»»» key|string|false|none|none|
|»»»» value|string|false|none|none|
|» info|string|false|none|Additional information. May be non-deterministic.|
|» gas_wanted|string(int64)|false|none|Amount of gas requested for transaction.|
|» gas_used|string(int64)|false|none|Amount of gas consumed by transaction.|
|» tx|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» timestamp|string|false|none|Time of the previous block. For heights > 1, it's the weighted median of<br />the timestamps of the valid votes in the block.LastCommit. For height == 1,<br />it's genesis time.|
|» events|[object]|false|none|Events defines all the events emitted by processing a transaction. Note,<br />these events include those emitted by processing all the messages and those<br />emitted from the ante. Whereas Logs contains the events, with<br />additional metadata, emitted only by processing the messages.<br /><br />Since: cosmos-sdk 0.42.11, 0.44.5, 0.45|
|»» type|string|false|none|none|
|»» attributes|[object]|false|none|none|
|»»» key|string|false|none|none|
|»»» value|string|false|none|none|
|»»» index|boolean|false|none|none|
|pagination|object|false|none|pagination defines a pagination for the response.<br />Deprecated post v0.46.x: use total instead.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|
|total|string(uint64)|false|none|none|

## cosmos.tx.v1beta1.ModeInfo

<a id="schemacosmos.tx.v1beta1.modeinfo"></a>
<a id="schema_cosmos.tx.v1beta1.ModeInfo"></a>
<a id="tocScosmos.tx.v1beta1.modeinfo"></a>
<a id="tocscosmos.tx.v1beta1.modeinfo"></a>

```json
{
  "single": {
    "mode": "SIGN_MODE_UNSPECIFIED"
  },
  "multi": {
    "bitarray": {
      "extra_bits_stored": 0,
      "elems": "string"
    },
    "mode_infos": [
      {
        "single": {
          "mode": "["
        },
        "multi": {
          "bitarray": {},
          "mode_infos": [
            null
          ]
        }
      }
    ]
  }
}

```

ModeInfo describes the signing mode of a single or nested multisig signer.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|single|object|false|none|none|
|» mode|string|false|none|SignMode represents a signing mode with its own security guarantees.<br /><br />This enum should be considered a registry of all known sign modes<br />in the Cosmos ecosystem. Apps are not expected to support all known<br />sign modes. Apps that would like to support custom  sign modes are<br />encouraged to open a small PR against this file to add a new case<br />to this SignMode enum describing their sign mode so that different<br />apps have a consistent version of this enum.<br /><br /> - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be<br />rejected.<br /> - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is<br />verified with raw bytes from Tx.<br /> - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some<br />human-readable textual representation on top of the binary representation<br />from SIGN_MODE_DIRECT. It is currently experimental, and should be used<br />for testing purposes only, until Textual is fully released. Please follow<br />the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.<br /> - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses<br />SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not<br />require signers signing over other signers' `signer_info`. It also allows<br />for adding Tips in transactions.<br /><br />Since: cosmos-sdk 0.46<br /> - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses<br />Amino JSON and will be removed in the future.<br /> - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos<br />SDK. Ref: https://eips.ethereum.org/EIPS/eip-191<br /><br />Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,<br />but is not implemented on the SDK by default. To enable EIP-191, you need<br />to pass a custom `TxConfig` that has an implementation of<br />`SignModeHandler` for EIP-191. The SDK may decide to fully support<br />EIP-191 in the future.<br /><br />Since: cosmos-sdk 0.45.2|
|multi|[cosmos.tx.v1beta1.ModeInfo.Multi](#schemacosmos.tx.v1beta1.modeinfo.multi)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|mode|SIGN_MODE_UNSPECIFIED|
|mode|SIGN_MODE_DIRECT|
|mode|SIGN_MODE_TEXTUAL|
|mode|SIGN_MODE_DIRECT_AUX|
|mode|SIGN_MODE_LEGACY_AMINO_JSON|
|mode|SIGN_MODE_EIP_191|

## cosmos.tx.v1beta1.ModeInfo.Multi

<a id="schemacosmos.tx.v1beta1.modeinfo.multi"></a>
<a id="schema_cosmos.tx.v1beta1.ModeInfo.Multi"></a>
<a id="tocScosmos.tx.v1beta1.modeinfo.multi"></a>
<a id="tocscosmos.tx.v1beta1.modeinfo.multi"></a>

```json
{
  "bitarray": {
    "extra_bits_stored": 0,
    "elems": "string"
  },
  "mode_infos": [
    {
      "single": {
        "mode": "SIGN_MODE_UNSPECIFIED"
      },
      "multi": {
        "bitarray": {
          "extra_bits_stored": 0,
          "elems": "string"
        },
        "mode_infos": [
          {
            "single": null,
            "multi": null
          }
        ]
      }
    }
  ]
}

```

Multi is the mode info for a multisig public key

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|bitarray|object|false|none|CompactBitArray is an implementation of a space efficient bit array.<br />This is used to ensure that the encoded data takes up a minimal amount of<br />space after proto encoding.<br />This is not thread safe, and is not intended for concurrent usage.|
|» extra_bits_stored|integer(int64)|false|none|none|
|» elems|string(byte)|false|none|none|
|mode_infos|[[cosmos.tx.v1beta1.ModeInfo](#schemacosmos.tx.v1beta1.modeinfo)]|false|none|[ModeInfo describes the signing mode of a single or nested multisig signer.]|

## cosmos.tx.v1beta1.ModeInfo.Single

<a id="schemacosmos.tx.v1beta1.modeinfo.single"></a>
<a id="schema_cosmos.tx.v1beta1.ModeInfo.Single"></a>
<a id="tocScosmos.tx.v1beta1.modeinfo.single"></a>
<a id="tocscosmos.tx.v1beta1.modeinfo.single"></a>

```json
{
  "mode": "SIGN_MODE_UNSPECIFIED"
}

```

Single is the mode info for a single signer. It is structured as a message
to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
future

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|mode|string|false|none|SignMode represents a signing mode with its own security guarantees.<br /><br />This enum should be considered a registry of all known sign modes<br />in the Cosmos ecosystem. Apps are not expected to support all known<br />sign modes. Apps that would like to support custom  sign modes are<br />encouraged to open a small PR against this file to add a new case<br />to this SignMode enum describing their sign mode so that different<br />apps have a consistent version of this enum.<br /><br /> - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be<br />rejected.<br /> - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is<br />verified with raw bytes from Tx.<br /> - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some<br />human-readable textual representation on top of the binary representation<br />from SIGN_MODE_DIRECT. It is currently experimental, and should be used<br />for testing purposes only, until Textual is fully released. Please follow<br />the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.<br /> - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses<br />SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not<br />require signers signing over other signers' `signer_info`. It also allows<br />for adding Tips in transactions.<br /><br />Since: cosmos-sdk 0.46<br /> - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses<br />Amino JSON and will be removed in the future.<br /> - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos<br />SDK. Ref: https://eips.ethereum.org/EIPS/eip-191<br /><br />Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,<br />but is not implemented on the SDK by default. To enable EIP-191, you need<br />to pass a custom `TxConfig` that has an implementation of<br />`SignModeHandler` for EIP-191. The SDK may decide to fully support<br />EIP-191 in the future.<br /><br />Since: cosmos-sdk 0.45.2|

#### Enumerated Values

|Property|Value|
|---|---|
|mode|SIGN_MODE_UNSPECIFIED|
|mode|SIGN_MODE_DIRECT|
|mode|SIGN_MODE_TEXTUAL|
|mode|SIGN_MODE_DIRECT_AUX|
|mode|SIGN_MODE_LEGACY_AMINO_JSON|
|mode|SIGN_MODE_EIP_191|

## cosmos.tx.v1beta1.OrderBy

<a id="schemacosmos.tx.v1beta1.orderby"></a>
<a id="schema_cosmos.tx.v1beta1.OrderBy"></a>
<a id="tocScosmos.tx.v1beta1.orderby"></a>
<a id="tocscosmos.tx.v1beta1.orderby"></a>

```json
"ORDER_BY_UNSPECIFIED"

```

OrderBy defines the sorting order

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|OrderBy defines the sorting order|string|false|none|- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults<br />to ASC in this case.<br /> - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order<br /> - ORDER_BY_DESC: ORDER_BY_DESC defines descending order|

#### Enumerated Values

|Property|Value|
|---|---|
|OrderBy defines the sorting order|ORDER_BY_UNSPECIFIED|
|OrderBy defines the sorting order|ORDER_BY_ASC|
|OrderBy defines the sorting order|ORDER_BY_DESC|

## cosmos.tx.v1beta1.SignerInfo

<a id="schemacosmos.tx.v1beta1.signerinfo"></a>
<a id="schema_cosmos.tx.v1beta1.SignerInfo"></a>
<a id="tocScosmos.tx.v1beta1.signerinfo"></a>
<a id="tocscosmos.tx.v1beta1.signerinfo"></a>

```json
{
  "public_key": {
    "type_url": "string",
    "value": "string"
  },
  "mode_info": {
    "single": {
      "mode": "SIGN_MODE_UNSPECIFIED"
    },
    "multi": {
      "bitarray": {
        "extra_bits_stored": 0,
        "elems": "string"
      },
      "mode_infos": [
        {
          "single": {},
          "multi": {}
        }
      ]
    }
  },
  "sequence": "string"
}

```

SignerInfo describes the public key and signing mode of a single top-level
signer.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|public_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|mode_info|[cosmos.tx.v1beta1.ModeInfo](#schemacosmos.tx.v1beta1.modeinfo)|false|none|ModeInfo describes the signing mode of a single or nested multisig signer.|
|sequence|string(uint64)|false|none|sequence is the sequence of the account, which describes the<br />number of committed transactions signed by a given address. It is used to<br />prevent replay attacks.|

## cosmos.tx.v1beta1.SimulateRequest

<a id="schemacosmos.tx.v1beta1.simulaterequest"></a>
<a id="schema_cosmos.tx.v1beta1.SimulateRequest"></a>
<a id="tocScosmos.tx.v1beta1.simulaterequest"></a>
<a id="tocscosmos.tx.v1beta1.simulaterequest"></a>

```json
{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  },
  "tx_bytes": "string"
}

```

SimulateRequest is the request type for the Service.Simulate
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx|[cosmos.tx.v1beta1.Tx](#schemacosmos.tx.v1beta1.tx)|false|none|tx is the transaction to simulate.<br />Deprecated. Send raw tx bytes instead.|
|tx_bytes|string(byte)|false|none|tx_bytes is the raw transaction.<br /><br />Since: cosmos-sdk 0.43|

## cosmos.tx.v1beta1.SimulateResponse

<a id="schemacosmos.tx.v1beta1.simulateresponse"></a>
<a id="schema_cosmos.tx.v1beta1.SimulateResponse"></a>
<a id="tocScosmos.tx.v1beta1.simulateresponse"></a>
<a id="tocscosmos.tx.v1beta1.simulateresponse"></a>

```json
{
  "gas_info": {
    "gas_wanted": "string",
    "gas_used": "string"
  },
  "result": {
    "data": "string",
    "log": "string",
    "events": [
      {
        "type": "string",
        "attributes": [
          {
            "key": null,
            "value": null,
            "index": null
          }
        ]
      }
    ],
    "msg_responses": [
      {
        "type_url": "string",
        "value": "string"
      }
    ]
  }
}

```

SimulateResponse is the response type for the
Service.SimulateRPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|gas_info|object|false|none|gas_info is the information about gas used in the simulation.|
|» gas_wanted|string(uint64)|false|none|GasWanted is the maximum units of work we allow this tx to perform.|
|» gas_used|string(uint64)|false|none|GasUsed is the amount of gas actually consumed.|
|result|object|false|none|result is the result of the simulation.|
|» data|string(byte)|false|none|Data is any data returned from message or handler execution. It MUST be<br />length prefixed in order to separate data from multiple message executions.<br />Deprecated. This field is still populated, but prefer msg_response instead<br />because it also contains the Msg response typeURL.|
|» log|string|false|none|Log contains the log information from message or handler execution.|
|» events|[object]|false|none|Events contains a slice of Event objects that were emitted during message<br />or handler execution.|
|»» type|string|false|none|none|
|»» attributes|[object]|false|none|none|
|»»» key|string|false|none|none|
|»»» value|string|false|none|none|
|»»» index|boolean|false|none|none|
|» msg_responses|[object]|false|none|msg_responses contains the Msg handler responses type packed in Anys.<br /><br />Since: cosmos-sdk 0.46|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.tx.v1beta1.Tip

<a id="schemacosmos.tx.v1beta1.tip"></a>
<a id="schema_cosmos.tx.v1beta1.Tip"></a>
<a id="tocScosmos.tx.v1beta1.tip"></a>
<a id="tocscosmos.tx.v1beta1.tip"></a>

```json
{
  "amount": [
    {
      "denom": "string",
      "amount": "string"
    }
  ],
  "tipper": "string"
}

```

Tip is the tip used for meta-transactions.

Since: cosmos-sdk 0.46

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amount|[object]|false|none|none|
|» denom|string|false|none|none|
|» amount|string|false|none|none|
|tipper|string|false|none|none|

## cosmos.tx.v1beta1.Tx

<a id="schemacosmos.tx.v1beta1.tx"></a>
<a id="schema_cosmos.tx.v1beta1.Tx"></a>
<a id="tocScosmos.tx.v1beta1.tx"></a>
<a id="tocscosmos.tx.v1beta1.tx"></a>

```json
{
  "body": {
    "messages": [
      {
        "type_url": "string",
        "value": "string"
      }
    ],
    "memo": "string",
    "timeout_height": "string",
    "extension_options": [
      {
        "type_url": "string",
        "value": "string"
      }
    ],
    "non_critical_extension_options": [
      {
        "type_url": "string",
        "value": "string"
      }
    ]
  },
  "auth_info": {
    "signer_infos": [
      {
        "public_key": {
          "type_url": "string",
          "value": "string"
        },
        "mode_info": {
          "single": {},
          "multi": {}
        },
        "sequence": "string"
      }
    ],
    "fee": {
      "amount": [
        {
          "denom": "string",
          "amount": "string"
        }
      ],
      "gas_limit": "string",
      "payer": "string",
      "granter": "string"
    },
    "tip": {
      "amount": [
        {
          "denom": "string",
          "amount": "string"
        }
      ],
      "tipper": "string"
    }
  },
  "signatures": [
    "string"
  ]
}

```

Tx is the standard type used for broadcasting transactions.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|body|object|false|none|TxBody is the body of a transaction that all signers sign over.|
|» messages|[object]|false|none|messages is a list of messages to be executed. The required signers of<br />those messages define the number and order of elements in AuthInfo's<br />signer_infos and Tx's signatures. Each required signer address is added to<br />the list only the first time it occurs.<br />By convention, the first required signer (usually from the first message)<br />is referred to as the primary signer and pays the fee for the whole<br />transaction.|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» memo|string|false|none|memo is any arbitrary note/comment to be added to the transaction.<br />WARNING: in clients, any publicly exposed text should not be called memo,<br />but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).|
|» timeout_height|string(uint64)|false|none|none|
|» extension_options|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» non_critical_extension_options|[object]|false|none|none|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|auth_info|[cosmos.tx.v1beta1.AuthInfo](#schemacosmos.tx.v1beta1.authinfo)|false|none|AuthInfo describes the fee and signer modes that are used to sign a<br />transaction.|
|signatures|[string]|false|none|signatures is a list of signatures that matches the length and order of<br />AuthInfo's signer_infos to allow connecting signature meta information like<br />public key and signing mode by position.|

## cosmos.tx.v1beta1.TxBody

<a id="schemacosmos.tx.v1beta1.txbody"></a>
<a id="schema_cosmos.tx.v1beta1.TxBody"></a>
<a id="tocScosmos.tx.v1beta1.txbody"></a>
<a id="tocscosmos.tx.v1beta1.txbody"></a>

```json
{
  "messages": [
    {
      "type_url": "string",
      "value": "string"
    }
  ],
  "memo": "string",
  "timeout_height": "string",
  "extension_options": [
    {
      "type_url": "string",
      "value": "string"
    }
  ],
  "non_critical_extension_options": [
    {
      "type_url": "string",
      "value": "string"
    }
  ]
}

```

TxBody is the body of a transaction that all signers sign over.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|messages|[object]|false|none|messages is a list of messages to be executed. The required signers of<br />those messages define the number and order of elements in AuthInfo's<br />signer_infos and Tx's signatures. Each required signer address is added to<br />the list only the first time it occurs.<br />By convention, the first required signer (usually from the first message)<br />is referred to as the primary signer and pays the fee for the whole<br />transaction.|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|memo|string|false|none|memo is any arbitrary note/comment to be added to the transaction.<br />WARNING: in clients, any publicly exposed text should not be called memo,<br />but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).|
|timeout_height|string(uint64)|false|none|none|
|extension_options|[object]|false|none|none|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|non_critical_extension_options|[object]|false|none|none|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.tx.v1beta1.TxDecodeAminoRequest

<a id="schemacosmos.tx.v1beta1.txdecodeaminorequest"></a>
<a id="schema_cosmos.tx.v1beta1.TxDecodeAminoRequest"></a>
<a id="tocScosmos.tx.v1beta1.txdecodeaminorequest"></a>
<a id="tocscosmos.tx.v1beta1.txdecodeaminorequest"></a>

```json
{
  "amino_binary": "string"
}

```

TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino
RPC method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amino_binary|string(byte)|false|none|none|

## cosmos.tx.v1beta1.TxDecodeAminoResponse

<a id="schemacosmos.tx.v1beta1.txdecodeaminoresponse"></a>
<a id="schema_cosmos.tx.v1beta1.TxDecodeAminoResponse"></a>
<a id="tocScosmos.tx.v1beta1.txdecodeaminoresponse"></a>
<a id="tocscosmos.tx.v1beta1.txdecodeaminoresponse"></a>

```json
{
  "amino_json": "string"
}

```

TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino
RPC method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amino_json|string|false|none|none|

## cosmos.tx.v1beta1.TxDecodeRequest

<a id="schemacosmos.tx.v1beta1.txdecoderequest"></a>
<a id="schema_cosmos.tx.v1beta1.TxDecodeRequest"></a>
<a id="tocScosmos.tx.v1beta1.txdecoderequest"></a>
<a id="tocscosmos.tx.v1beta1.txdecoderequest"></a>

```json
{
  "tx_bytes": "string"
}

```

TxDecodeRequest is the request type for the Service.TxDecode
RPC method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx_bytes|string(byte)|false|none|tx_bytes is the raw transaction.|

## cosmos.tx.v1beta1.TxDecodeResponse

<a id="schemacosmos.tx.v1beta1.txdecoderesponse"></a>
<a id="schema_cosmos.tx.v1beta1.TxDecodeResponse"></a>
<a id="tocScosmos.tx.v1beta1.txdecoderesponse"></a>
<a id="tocscosmos.tx.v1beta1.txdecoderesponse"></a>

```json
{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  }
}

```

TxDecodeResponse is the response type for the
Service.TxDecode method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx|[cosmos.tx.v1beta1.Tx](#schemacosmos.tx.v1beta1.tx)|false|none|tx is the decoded transaction.|

## cosmos.tx.v1beta1.TxEncodeAminoRequest

<a id="schemacosmos.tx.v1beta1.txencodeaminorequest"></a>
<a id="schema_cosmos.tx.v1beta1.TxEncodeAminoRequest"></a>
<a id="tocScosmos.tx.v1beta1.txencodeaminorequest"></a>
<a id="tocscosmos.tx.v1beta1.txencodeaminorequest"></a>

```json
{
  "amino_json": "string"
}

```

TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino
RPC method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amino_json|string|false|none|none|

## cosmos.tx.v1beta1.TxEncodeAminoResponse

<a id="schemacosmos.tx.v1beta1.txencodeaminoresponse"></a>
<a id="schema_cosmos.tx.v1beta1.TxEncodeAminoResponse"></a>
<a id="tocScosmos.tx.v1beta1.txencodeaminoresponse"></a>
<a id="tocscosmos.tx.v1beta1.txencodeaminoresponse"></a>

```json
{
  "amino_binary": "string"
}

```

TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino
RPC method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|amino_binary|string(byte)|false|none|none|

## cosmos.tx.v1beta1.TxEncodeRequest

<a id="schemacosmos.tx.v1beta1.txencoderequest"></a>
<a id="schema_cosmos.tx.v1beta1.TxEncodeRequest"></a>
<a id="tocScosmos.tx.v1beta1.txencoderequest"></a>
<a id="tocscosmos.tx.v1beta1.txencoderequest"></a>

```json
{
  "tx": {
    "body": {
      "messages": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "memo": "string",
      "timeout_height": "string",
      "extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ],
      "non_critical_extension_options": [
        {
          "type_url": "string",
          "value": "string"
        }
      ]
    },
    "auth_info": {
      "signer_infos": [
        {
          "public_key": {},
          "mode_info": {},
          "sequence": "string"
        }
      ],
      "fee": {
        "amount": [
          {}
        ],
        "gas_limit": "string",
        "payer": "string",
        "granter": "string"
      },
      "tip": {
        "amount": [
          {}
        ],
        "tipper": "string"
      }
    },
    "signatures": [
      "string"
    ]
  }
}

```

TxEncodeRequest is the request type for the Service.TxEncode
RPC method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx|[cosmos.tx.v1beta1.Tx](#schemacosmos.tx.v1beta1.tx)|false|none|tx is the transaction to encode.|

## cosmos.tx.v1beta1.TxEncodeResponse

<a id="schemacosmos.tx.v1beta1.txencoderesponse"></a>
<a id="schema_cosmos.tx.v1beta1.TxEncodeResponse"></a>
<a id="tocScosmos.tx.v1beta1.txencoderesponse"></a>
<a id="tocscosmos.tx.v1beta1.txencoderesponse"></a>

```json
{
  "tx_bytes": "string"
}

```

TxEncodeResponse is the response type for the
Service.TxEncode method.

Since: cosmos-sdk 0.47

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx_bytes|string(byte)|false|none|tx_bytes is the encoded transaction bytes.|

## tendermint.abci.Event

<a id="schematendermint.abci.event"></a>
<a id="schema_tendermint.abci.Event"></a>
<a id="tocStendermint.abci.event"></a>
<a id="tocstendermint.abci.event"></a>

```json
{
  "type": "string",
  "attributes": [
    {
      "key": "string",
      "value": "string",
      "index": true
    }
  ]
}

```

Event allows application developers to attach additional information to
ResponseFinalizeBlock and ResponseCheckTx.
Later, transactions may be queried using these events.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|type|string|false|none|none|
|attributes|[object]|false|none|none|
|» key|string|false|none|none|
|» value|string|false|none|none|
|» index|boolean|false|none|none|

## tendermint.abci.EventAttribute

<a id="schematendermint.abci.eventattribute"></a>
<a id="schema_tendermint.abci.EventAttribute"></a>
<a id="tocStendermint.abci.eventattribute"></a>
<a id="tocstendermint.abci.eventattribute"></a>

```json
{
  "key": "string",
  "value": "string",
  "index": true
}

```

EventAttribute is a single key-value pair, associated with an event.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|key|string|false|none|none|
|value|string|false|none|none|
|index|boolean|false|none|none|

## tendermint.crypto.PublicKey

<a id="schematendermint.crypto.publickey"></a>
<a id="schema_tendermint.crypto.PublicKey"></a>
<a id="tocStendermint.crypto.publickey"></a>
<a id="tocstendermint.crypto.publickey"></a>

```json
{
  "ed25519": "string",
  "secp256k1": "string"
}

```

PublicKey defines the keys available for use with Validators

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ed25519|string(byte)|false|none|none|
|secp256k1|string(byte)|false|none|none|

## tendermint.types.Block

<a id="schematendermint.types.block"></a>
<a id="schema_tendermint.types.Block"></a>
<a id="tocStendermint.types.block"></a>
<a id="tocstendermint.types.block"></a>

```json
{
  "header": {
    "version": {
      "block": "string",
      "app": "string"
    },
    "chain_id": "string",
    "height": "string",
    "time": "2019-08-24T14:15:22Z",
    "last_block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "last_commit_hash": "string",
    "data_hash": "string",
    "validators_hash": "string",
    "next_validators_hash": "string",
    "consensus_hash": "string",
    "app_hash": "string",
    "last_results_hash": "string",
    "evidence_hash": "string",
    "proposer_address": "string"
  },
  "data": {
    "txs": [
      "string"
    ]
  },
  "evidence": {
    "evidence": [
      {
        "duplicate_vote_evidence": {
          "vote_a": {},
          "vote_b": {},
          "total_voting_power": "string",
          "validator_power": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        },
        "light_client_attack_evidence": {
          "conflicting_block": {},
          "common_height": "string",
          "byzantine_validators": [
            null
          ],
          "total_voting_power": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      }
    ]
  },
  "last_commit": {
    "height": "string",
    "round": 0,
    "block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "signatures": [
      {
        "block_id_flag": "BLOCK_ID_FLAG_UNKNOWN",
        "validator_address": "string",
        "timestamp": "2019-08-24T14:15:22Z",
        "signature": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|header|object|false|none|Header defines the structure of a block header.|
|» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»» block|string(uint64)|false|none|none|
|»» app|string(uint64)|false|none|none|
|» chain_id|string|false|none|none|
|» height|string(int64)|false|none|none|
|» time|string(date-time)|false|none|none|
|» last_block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» last_commit_hash|string(byte)|false|none|none|
|» data_hash|string(byte)|false|none|none|
|» validators_hash|string(byte)|false|none|none|
|» next_validators_hash|string(byte)|false|none|none|
|» consensus_hash|string(byte)|false|none|none|
|» app_hash|string(byte)|false|none|none|
|» last_results_hash|string(byte)|false|none|none|
|» evidence_hash|string(byte)|false|none|none|
|» proposer_address|string(byte)|false|none|none|
|data|object|false|none|none|
|» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|evidence|object|false|none|none|
|» evidence|[object]|false|none|none|
|»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»» height|string(int64)|false|none|none|
|»»»» round|integer(int32)|false|none|none|
|»»»» block_id|object|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»»»» part_set_header|object|false|none|none|
|»»»»»» total|integer(int64)|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» validator_index|integer(int32)|false|none|none|
|»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»» height|string(int64)|false|none|none|
|»»»» round|integer(int32)|false|none|none|
|»»»» block_id|object|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»»»» part_set_header|object|false|none|none|
|»»»»»» total|integer(int64)|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» validator_index|integer(int32)|false|none|none|
|»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»» total_voting_power|string(int64)|false|none|none|
|»»» validator_power|string(int64)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»» conflicting_block|object|false|none|none|
|»»»» signed_header|object|false|none|none|
|»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»» app|string(uint64)|false|none|none|
|»»»»»» chain_id|string|false|none|none|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» time|string(date-time)|false|none|none|
|»»»»»» last_block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» signatures|[object]|false|none|none|
|»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»» signature|string(byte)|false|none|none|
|»»»» validator_set|object|false|none|none|
|»»»»» validators|[object]|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» proposer|object|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»» common_height|string(int64)|false|none|none|
|»»» byzantine_validators|[object]|false|none|none|
|»»»» address|string(byte)|false|none|none|
|»»»» pub_key|object|false|none|none|
|»»»»» ed25519|string(byte)|false|none|none|
|»»»»» secp256k1|string(byte)|false|none|none|
|»»»» voting_power|string(int64)|false|none|none|
|»»»» proposer_priority|string(int64)|false|none|none|
|»»» total_voting_power|string(int64)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|» height|string(int64)|false|none|none|
|» round|integer(int32)|false|none|none|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» signatures|[object]|false|none|none|
|»» block_id_flag|string|false|none|none|
|»» validator_address|string(byte)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|
|»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.BlockIDFlag

<a id="schematendermint.types.blockidflag"></a>
<a id="schema_tendermint.types.BlockIDFlag"></a>
<a id="tocStendermint.types.blockidflag"></a>
<a id="tocstendermint.types.blockidflag"></a>

```json
"BLOCK_ID_FLAG_UNKNOWN"

```

BlockIdFlag indicates which BlockID the signature is for

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|BlockIdFlag indicates which BlockID the signature is for|string|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|BlockIdFlag indicates which BlockID the signature is for|BLOCK_ID_FLAG_UNKNOWN|
|BlockIdFlag indicates which BlockID the signature is for|BLOCK_ID_FLAG_ABSENT|
|BlockIdFlag indicates which BlockID the signature is for|BLOCK_ID_FLAG_COMMIT|
|BlockIdFlag indicates which BlockID the signature is for|BLOCK_ID_FLAG_NIL|

## tendermint.types.Commit

<a id="schematendermint.types.commit"></a>
<a id="schema_tendermint.types.Commit"></a>
<a id="tocStendermint.types.commit"></a>
<a id="tocstendermint.types.commit"></a>

```json
{
  "height": "string",
  "round": 0,
  "block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "signatures": [
    {
      "block_id_flag": "BLOCK_ID_FLAG_UNKNOWN",
      "validator_address": "string",
      "timestamp": "2019-08-24T14:15:22Z",
      "signature": "string"
    }
  ]
}

```

Commit contains the evidence that a block was committed by a set of validators.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|height|string(int64)|false|none|none|
|round|integer(int32)|false|none|none|
|block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|signatures|[object]|false|none|none|
|» block_id_flag|string|false|none|none|
|» validator_address|string(byte)|false|none|none|
|» timestamp|string(date-time)|false|none|none|
|» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.CommitSig

<a id="schematendermint.types.commitsig"></a>
<a id="schema_tendermint.types.CommitSig"></a>
<a id="tocStendermint.types.commitsig"></a>
<a id="tocstendermint.types.commitsig"></a>

```json
{
  "block_id_flag": "BLOCK_ID_FLAG_UNKNOWN",
  "validator_address": "string",
  "timestamp": "2019-08-24T14:15:22Z",
  "signature": "string"
}

```

CommitSig is a part of the Vote included in a Commit.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_id_flag|string|false|none|none|
|validator_address|string(byte)|false|none|none|
|timestamp|string(date-time)|false|none|none|
|signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.Data

<a id="schematendermint.types.data"></a>
<a id="schema_tendermint.types.Data"></a>
<a id="tocStendermint.types.data"></a>
<a id="tocstendermint.types.data"></a>

```json
{
  "txs": [
    "string"
  ]
}

```

Data contains the set of transactions included in the block

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|

## tendermint.types.DuplicateVoteEvidence

<a id="schematendermint.types.duplicatevoteevidence"></a>
<a id="schema_tendermint.types.DuplicateVoteEvidence"></a>
<a id="tocStendermint.types.duplicatevoteevidence"></a>
<a id="tocstendermint.types.duplicatevoteevidence"></a>

```json
{
  "vote_a": {
    "type": "SIGNED_MSG_TYPE_UNKNOWN",
    "height": "string",
    "round": 0,
    "block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "timestamp": "2019-08-24T14:15:22Z",
    "validator_address": "string",
    "validator_index": 0,
    "signature": "string",
    "extension": "string",
    "extension_signature": "string"
  },
  "vote_b": {
    "type": "SIGNED_MSG_TYPE_UNKNOWN",
    "height": "string",
    "round": 0,
    "block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "timestamp": "2019-08-24T14:15:22Z",
    "validator_address": "string",
    "validator_index": 0,
    "signature": "string",
    "extension": "string",
    "extension_signature": "string"
  },
  "total_voting_power": "string",
  "validator_power": "string",
  "timestamp": "2019-08-24T14:15:22Z"
}

```

DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|» height|string(int64)|false|none|none|
|» round|integer(int32)|false|none|none|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» timestamp|string(date-time)|false|none|none|
|» validator_address|string(byte)|false|none|none|
|» validator_index|integer(int32)|false|none|none|
|» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|» height|string(int64)|false|none|none|
|» round|integer(int32)|false|none|none|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» timestamp|string(date-time)|false|none|none|
|» validator_address|string(byte)|false|none|none|
|» validator_index|integer(int32)|false|none|none|
|» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|total_voting_power|string(int64)|false|none|none|
|validator_power|string(int64)|false|none|none|
|timestamp|string(date-time)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|

## tendermint.types.Evidence

<a id="schematendermint.types.evidence"></a>
<a id="schema_tendermint.types.Evidence"></a>
<a id="tocStendermint.types.evidence"></a>
<a id="tocstendermint.types.evidence"></a>

```json
{
  "duplicate_vote_evidence": {
    "vote_a": {
      "type": "SIGNED_MSG_TYPE_UNKNOWN",
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "timestamp": "2019-08-24T14:15:22Z",
      "validator_address": "string",
      "validator_index": 0,
      "signature": "string",
      "extension": "string",
      "extension_signature": "string"
    },
    "vote_b": {
      "type": "SIGNED_MSG_TYPE_UNKNOWN",
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "timestamp": "2019-08-24T14:15:22Z",
      "validator_address": "string",
      "validator_index": 0,
      "signature": "string",
      "extension": "string",
      "extension_signature": "string"
    },
    "total_voting_power": "string",
    "validator_power": "string",
    "timestamp": "2019-08-24T14:15:22Z"
  },
  "light_client_attack_evidence": {
    "conflicting_block": {
      "signed_header": {
        "header": {
          "version": null,
          "chain_id": null,
          "height": null,
          "time": null,
          "last_block_id": null,
          "last_commit_hash": null,
          "data_hash": null,
          "validators_hash": null,
          "next_validators_hash": null,
          "consensus_hash": null,
          "app_hash": null,
          "last_results_hash": null,
          "evidence_hash": null,
          "proposer_address": null
        },
        "commit": {
          "height": null,
          "round": null,
          "block_id": null,
          "signatures": null
        }
      },
      "validator_set": {
        "validators": [
          {}
        ],
        "proposer": {
          "address": null,
          "pub_key": null,
          "voting_power": null,
          "proposer_priority": null
        },
        "total_voting_power": "string"
      }
    },
    "common_height": "string",
    "byzantine_validators": [
      {
        "address": "string",
        "pub_key": {
          "ed25519": "string",
          "secp256k1": "string"
        },
        "voting_power": "string",
        "proposer_priority": "string"
      }
    ],
    "total_voting_power": "string",
    "timestamp": "2019-08-24T14:15:22Z"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|
|»» validator_address|string(byte)|false|none|none|
|»» validator_index|integer(int32)|false|none|none|
|»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|
|»» validator_address|string(byte)|false|none|none|
|»» validator_index|integer(int32)|false|none|none|
|»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|» total_voting_power|string(int64)|false|none|none|
|» validator_power|string(int64)|false|none|none|
|» timestamp|string(date-time)|false|none|none|
|light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|» conflicting_block|object|false|none|none|
|»» signed_header|object|false|none|none|
|»»» header|object|false|none|Header defines the structure of a block header.|
|»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»» block|string(uint64)|false|none|none|
|»»»»» app|string(uint64)|false|none|none|
|»»»» chain_id|string|false|none|none|
|»»»» height|string(int64)|false|none|none|
|»»»» time|string(date-time)|false|none|none|
|»»»» last_block_id|object|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»»»» part_set_header|object|false|none|none|
|»»»»»» total|integer(int64)|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»» last_commit_hash|string(byte)|false|none|none|
|»»»» data_hash|string(byte)|false|none|none|
|»»»» validators_hash|string(byte)|false|none|none|
|»»»» next_validators_hash|string(byte)|false|none|none|
|»»»» consensus_hash|string(byte)|false|none|none|
|»»»» app_hash|string(byte)|false|none|none|
|»»»» last_results_hash|string(byte)|false|none|none|
|»»»» evidence_hash|string(byte)|false|none|none|
|»»»» proposer_address|string(byte)|false|none|none|
|»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»» height|string(int64)|false|none|none|
|»»»» round|integer(int32)|false|none|none|
|»»»» block_id|object|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»»»» part_set_header|object|false|none|none|
|»»»»»» total|integer(int64)|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»» signatures|[object]|false|none|none|
|»»»»» block_id_flag|string|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» signature|string(byte)|false|none|none|
|»» validator_set|object|false|none|none|
|»»» validators|[object]|false|none|none|
|»»»» address|string(byte)|false|none|none|
|»»»» pub_key|object|false|none|none|
|»»»»» ed25519|string(byte)|false|none|none|
|»»»»» secp256k1|string(byte)|false|none|none|
|»»»» voting_power|string(int64)|false|none|none|
|»»»» proposer_priority|string(int64)|false|none|none|
|»»» proposer|object|false|none|none|
|»»»» address|string(byte)|false|none|none|
|»»»» pub_key|object|false|none|none|
|»»»»» ed25519|string(byte)|false|none|none|
|»»»»» secp256k1|string(byte)|false|none|none|
|»»»» voting_power|string(int64)|false|none|none|
|»»»» proposer_priority|string(int64)|false|none|none|
|»»» total_voting_power|string(int64)|false|none|none|
|» common_height|string(int64)|false|none|none|
|» byzantine_validators|[object]|false|none|none|
|»» address|string(byte)|false|none|none|
|»» pub_key|object|false|none|none|
|»»» ed25519|string(byte)|false|none|none|
|»»» secp256k1|string(byte)|false|none|none|
|»» voting_power|string(int64)|false|none|none|
|»» proposer_priority|string(int64)|false|none|none|
|» total_voting_power|string(int64)|false|none|none|
|» timestamp|string(date-time)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.EvidenceList

<a id="schematendermint.types.evidencelist"></a>
<a id="schema_tendermint.types.EvidenceList"></a>
<a id="tocStendermint.types.evidencelist"></a>
<a id="tocstendermint.types.evidencelist"></a>

```json
{
  "evidence": [
    {
      "duplicate_vote_evidence": {
        "vote_a": {
          "type": "[",
          "height": "string",
          "round": 0,
          "block_id": {},
          "timestamp": "2019-08-24T14:15:22Z",
          "validator_address": "string",
          "validator_index": 0,
          "signature": "string",
          "extension": "string",
          "extension_signature": "string"
        },
        "vote_b": {
          "type": "[",
          "height": "string",
          "round": 0,
          "block_id": {},
          "timestamp": "2019-08-24T14:15:22Z",
          "validator_address": "string",
          "validator_index": 0,
          "signature": "string",
          "extension": "string",
          "extension_signature": "string"
        },
        "total_voting_power": "string",
        "validator_power": "string",
        "timestamp": "2019-08-24T14:15:22Z"
      },
      "light_client_attack_evidence": {
        "conflicting_block": {
          "signed_header": {},
          "validator_set": {}
        },
        "common_height": "string",
        "byzantine_validators": [
          {
            "address": null,
            "pub_key": null,
            "voting_power": null,
            "proposer_priority": null
          }
        ],
        "total_voting_power": "string",
        "timestamp": "2019-08-24T14:15:22Z"
      }
    }
  ]
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|evidence|[object]|false|none|none|
|» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» validator_index|integer(int32)|false|none|none|
|»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» validator_index|integer(int32)|false|none|none|
|»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»» total_voting_power|string(int64)|false|none|none|
|»» validator_power|string(int64)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|
|» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»» conflicting_block|object|false|none|none|
|»»» signed_header|object|false|none|none|
|»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»» block|string(uint64)|false|none|none|
|»»»»»» app|string(uint64)|false|none|none|
|»»»»» chain_id|string|false|none|none|
|»»»»» height|string(int64)|false|none|none|
|»»»»» time|string(date-time)|false|none|none|
|»»»»» last_block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»» data_hash|string(byte)|false|none|none|
|»»»»» validators_hash|string(byte)|false|none|none|
|»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»» app_hash|string(byte)|false|none|none|
|»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»» proposer_address|string(byte)|false|none|none|
|»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» signatures|[object]|false|none|none|
|»»»»»» block_id_flag|string|false|none|none|
|»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»» signature|string(byte)|false|none|none|
|»»» validator_set|object|false|none|none|
|»»»» validators|[object]|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» proposer|object|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» total_voting_power|string(int64)|false|none|none|
|»» common_height|string(int64)|false|none|none|
|»» byzantine_validators|[object]|false|none|none|
|»»» address|string(byte)|false|none|none|
|»»» pub_key|object|false|none|none|
|»»»» ed25519|string(byte)|false|none|none|
|»»»» secp256k1|string(byte)|false|none|none|
|»»» voting_power|string(int64)|false|none|none|
|»»» proposer_priority|string(int64)|false|none|none|
|»» total_voting_power|string(int64)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.LightBlock

<a id="schematendermint.types.lightblock"></a>
<a id="schema_tendermint.types.LightBlock"></a>
<a id="tocStendermint.types.lightblock"></a>
<a id="tocstendermint.types.lightblock"></a>

```json
{
  "signed_header": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "commit": {
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "signatures": [
        {
          "block_id_flag": "[",
          "validator_address": "string",
          "timestamp": "2019-08-24T14:15:22Z",
          "signature": "string"
        }
      ]
    }
  },
  "validator_set": {
    "validators": [
      {
        "address": "string",
        "pub_key": {
          "ed25519": "string",
          "secp256k1": "string"
        },
        "voting_power": "string",
        "proposer_priority": "string"
      }
    ],
    "proposer": {
      "address": "string",
      "pub_key": {
        "ed25519": "string",
        "secp256k1": "string"
      },
      "voting_power": "string",
      "proposer_priority": "string"
    },
    "total_voting_power": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|signed_header|object|false|none|none|
|» header|object|false|none|Header defines the structure of a block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string(byte)|false|none|none|
|» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» signatures|[object]|false|none|none|
|»»» block_id_flag|string|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» signature|string(byte)|false|none|none|
|validator_set|object|false|none|none|
|» validators|[object]|false|none|none|
|»» address|string(byte)|false|none|none|
|»» pub_key|object|false|none|none|
|»»» ed25519|string(byte)|false|none|none|
|»»» secp256k1|string(byte)|false|none|none|
|»» voting_power|string(int64)|false|none|none|
|»» proposer_priority|string(int64)|false|none|none|
|» proposer|object|false|none|none|
|»» address|string(byte)|false|none|none|
|»» pub_key|object|false|none|none|
|»»» ed25519|string(byte)|false|none|none|
|»»» secp256k1|string(byte)|false|none|none|
|»» voting_power|string(int64)|false|none|none|
|»» proposer_priority|string(int64)|false|none|none|
|» total_voting_power|string(int64)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.LightClientAttackEvidence

<a id="schematendermint.types.lightclientattackevidence"></a>
<a id="schema_tendermint.types.LightClientAttackEvidence"></a>
<a id="tocStendermint.types.lightclientattackevidence"></a>
<a id="tocstendermint.types.lightclientattackevidence"></a>

```json
{
  "conflicting_block": {
    "signed_header": {
      "header": {
        "version": {
          "block": null,
          "app": null
        },
        "chain_id": "string",
        "height": "string",
        "time": "2019-08-24T14:15:22Z",
        "last_block_id": {
          "hash": null,
          "part_set_header": null
        },
        "last_commit_hash": "string",
        "data_hash": "string",
        "validators_hash": "string",
        "next_validators_hash": "string",
        "consensus_hash": "string",
        "app_hash": "string",
        "last_results_hash": "string",
        "evidence_hash": "string",
        "proposer_address": "string"
      },
      "commit": {
        "height": "string",
        "round": 0,
        "block_id": {
          "hash": null,
          "part_set_header": null
        },
        "signatures": [
          {}
        ]
      }
    },
    "validator_set": {
      "validators": [
        {
          "address": "string",
          "pub_key": {},
          "voting_power": "string",
          "proposer_priority": "string"
        }
      ],
      "proposer": {
        "address": "string",
        "pub_key": {
          "ed25519": null,
          "secp256k1": null
        },
        "voting_power": "string",
        "proposer_priority": "string"
      },
      "total_voting_power": "string"
    }
  },
  "common_height": "string",
  "byzantine_validators": [
    {
      "address": "string",
      "pub_key": {
        "ed25519": "string",
        "secp256k1": "string"
      },
      "voting_power": "string",
      "proposer_priority": "string"
    }
  ],
  "total_voting_power": "string",
  "timestamp": "2019-08-24T14:15:22Z"
}

```

LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|conflicting_block|object|false|none|none|
|» signed_header|object|false|none|none|
|»» header|object|false|none|Header defines the structure of a block header.|
|»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»» block|string(uint64)|false|none|none|
|»»»» app|string(uint64)|false|none|none|
|»»» chain_id|string|false|none|none|
|»»» height|string(int64)|false|none|none|
|»»» time|string(date-time)|false|none|none|
|»»» last_block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» last_commit_hash|string(byte)|false|none|none|
|»»» data_hash|string(byte)|false|none|none|
|»»» validators_hash|string(byte)|false|none|none|
|»»» next_validators_hash|string(byte)|false|none|none|
|»»» consensus_hash|string(byte)|false|none|none|
|»»» app_hash|string(byte)|false|none|none|
|»»» last_results_hash|string(byte)|false|none|none|
|»»» evidence_hash|string(byte)|false|none|none|
|»»» proposer_address|string(byte)|false|none|none|
|»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»» height|string(int64)|false|none|none|
|»»» round|integer(int32)|false|none|none|
|»»» block_id|object|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»»»» part_set_header|object|false|none|none|
|»»»»» total|integer(int64)|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»» signatures|[object]|false|none|none|
|»»»» block_id_flag|string|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» signature|string(byte)|false|none|none|
|» validator_set|object|false|none|none|
|»» validators|[object]|false|none|none|
|»»» address|string(byte)|false|none|none|
|»»» pub_key|object|false|none|none|
|»»»» ed25519|string(byte)|false|none|none|
|»»»» secp256k1|string(byte)|false|none|none|
|»»» voting_power|string(int64)|false|none|none|
|»»» proposer_priority|string(int64)|false|none|none|
|»» proposer|object|false|none|none|
|»»» address|string(byte)|false|none|none|
|»»» pub_key|object|false|none|none|
|»»»» ed25519|string(byte)|false|none|none|
|»»»» secp256k1|string(byte)|false|none|none|
|»»» voting_power|string(int64)|false|none|none|
|»»» proposer_priority|string(int64)|false|none|none|
|»» total_voting_power|string(int64)|false|none|none|
|common_height|string(int64)|false|none|none|
|byzantine_validators|[object]|false|none|none|
|» address|string(byte)|false|none|none|
|» pub_key|object|false|none|none|
|»» ed25519|string(byte)|false|none|none|
|»» secp256k1|string(byte)|false|none|none|
|» voting_power|string(int64)|false|none|none|
|» proposer_priority|string(int64)|false|none|none|
|total_voting_power|string(int64)|false|none|none|
|timestamp|string(date-time)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.SignedHeader

<a id="schematendermint.types.signedheader"></a>
<a id="schema_tendermint.types.SignedHeader"></a>
<a id="tocStendermint.types.signedheader"></a>
<a id="tocstendermint.types.signedheader"></a>

```json
{
  "header": {
    "version": {
      "block": "string",
      "app": "string"
    },
    "chain_id": "string",
    "height": "string",
    "time": "2019-08-24T14:15:22Z",
    "last_block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "last_commit_hash": "string",
    "data_hash": "string",
    "validators_hash": "string",
    "next_validators_hash": "string",
    "consensus_hash": "string",
    "app_hash": "string",
    "last_results_hash": "string",
    "evidence_hash": "string",
    "proposer_address": "string"
  },
  "commit": {
    "height": "string",
    "round": 0,
    "block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "signatures": [
      {
        "block_id_flag": "BLOCK_ID_FLAG_UNKNOWN",
        "validator_address": "string",
        "timestamp": "2019-08-24T14:15:22Z",
        "signature": "string"
      }
    ]
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|header|object|false|none|Header defines the structure of a block header.|
|» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»» block|string(uint64)|false|none|none|
|»» app|string(uint64)|false|none|none|
|» chain_id|string|false|none|none|
|» height|string(int64)|false|none|none|
|» time|string(date-time)|false|none|none|
|» last_block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» last_commit_hash|string(byte)|false|none|none|
|» data_hash|string(byte)|false|none|none|
|» validators_hash|string(byte)|false|none|none|
|» next_validators_hash|string(byte)|false|none|none|
|» consensus_hash|string(byte)|false|none|none|
|» app_hash|string(byte)|false|none|none|
|» last_results_hash|string(byte)|false|none|none|
|» evidence_hash|string(byte)|false|none|none|
|» proposer_address|string(byte)|false|none|none|
|commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|» height|string(int64)|false|none|none|
|» round|integer(int32)|false|none|none|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» signatures|[object]|false|none|none|
|»» block_id_flag|string|false|none|none|
|»» validator_address|string(byte)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|
|»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## tendermint.types.SignedMsgType

<a id="schematendermint.types.signedmsgtype"></a>
<a id="schema_tendermint.types.SignedMsgType"></a>
<a id="tocStendermint.types.signedmsgtype"></a>
<a id="tocstendermint.types.signedmsgtype"></a>

```json
"SIGNED_MSG_TYPE_UNKNOWN"

```

SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|*anonymous*|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|

#### Enumerated Values

|Property|Value|
|---|---|
|*anonymous*|SIGNED_MSG_TYPE_UNKNOWN|
|*anonymous*|SIGNED_MSG_TYPE_PREVOTE|
|*anonymous*|SIGNED_MSG_TYPE_PRECOMMIT|
|*anonymous*|SIGNED_MSG_TYPE_PROPOSAL|

## tendermint.types.Validator

<a id="schematendermint.types.validator"></a>
<a id="schema_tendermint.types.Validator"></a>
<a id="tocStendermint.types.validator"></a>
<a id="tocstendermint.types.validator"></a>

```json
{
  "address": "string",
  "pub_key": {
    "ed25519": "string",
    "secp256k1": "string"
  },
  "voting_power": "string",
  "proposer_priority": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string(byte)|false|none|none|
|pub_key|object|false|none|none|
|» ed25519|string(byte)|false|none|none|
|» secp256k1|string(byte)|false|none|none|
|voting_power|string(int64)|false|none|none|
|proposer_priority|string(int64)|false|none|none|

## tendermint.types.ValidatorSet

<a id="schematendermint.types.validatorset"></a>
<a id="schema_tendermint.types.ValidatorSet"></a>
<a id="tocStendermint.types.validatorset"></a>
<a id="tocstendermint.types.validatorset"></a>

```json
{
  "validators": [
    {
      "address": "string",
      "pub_key": {
        "ed25519": "string",
        "secp256k1": "string"
      },
      "voting_power": "string",
      "proposer_priority": "string"
    }
  ],
  "proposer": {
    "address": "string",
    "pub_key": {
      "ed25519": "string",
      "secp256k1": "string"
    },
    "voting_power": "string",
    "proposer_priority": "string"
  },
  "total_voting_power": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|validators|[object]|false|none|none|
|» address|string(byte)|false|none|none|
|» pub_key|object|false|none|none|
|»» ed25519|string(byte)|false|none|none|
|»» secp256k1|string(byte)|false|none|none|
|» voting_power|string(int64)|false|none|none|
|» proposer_priority|string(int64)|false|none|none|
|proposer|object|false|none|none|
|» address|string(byte)|false|none|none|
|» pub_key|object|false|none|none|
|»» ed25519|string(byte)|false|none|none|
|»» secp256k1|string(byte)|false|none|none|
|» voting_power|string(int64)|false|none|none|
|» proposer_priority|string(int64)|false|none|none|
|total_voting_power|string(int64)|false|none|none|

## tendermint.types.Vote

<a id="schematendermint.types.vote"></a>
<a id="schema_tendermint.types.Vote"></a>
<a id="tocStendermint.types.vote"></a>
<a id="tocstendermint.types.vote"></a>

```json
{
  "type": "SIGNED_MSG_TYPE_UNKNOWN",
  "height": "string",
  "round": 0,
  "block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "timestamp": "2019-08-24T14:15:22Z",
  "validator_address": "string",
  "validator_index": 0,
  "signature": "string",
  "extension": "string",
  "extension_signature": "string"
}

```

Vote represents a prevote or precommit vote from validators for
consensus.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|height|string(int64)|false|none|none|
|round|integer(int32)|false|none|none|
|block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|timestamp|string(date-time)|false|none|none|
|validator_address|string(byte)|false|none|none|
|validator_index|integer(int32)|false|none|none|
|signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|

## cosmos.upgrade.v1beta1.ModuleVersion

<a id="schemacosmos.upgrade.v1beta1.moduleversion"></a>
<a id="schema_cosmos.upgrade.v1beta1.ModuleVersion"></a>
<a id="tocScosmos.upgrade.v1beta1.moduleversion"></a>
<a id="tocscosmos.upgrade.v1beta1.moduleversion"></a>

```json
{
  "name": "string",
  "version": "string"
}

```

ModuleVersion specifies a module and its consensus version.

Since: cosmos-sdk 0.43

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|false|none|none|
|version|string(uint64)|false|none|none|

## cosmos.upgrade.v1beta1.Plan

<a id="schemacosmos.upgrade.v1beta1.plan"></a>
<a id="schema_cosmos.upgrade.v1beta1.Plan"></a>
<a id="tocScosmos.upgrade.v1beta1.plan"></a>
<a id="tocscosmos.upgrade.v1beta1.plan"></a>

```json
{
  "name": "string",
  "time": "2019-08-24T14:15:22Z",
  "height": "string",
  "info": "string",
  "upgraded_client_state": {
    "type_url": "string",
    "value": "string"
  }
}

```

Plan specifies information about a planned upgrade and when it should occur.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|false|none|Sets the name for the upgrade. This name will be used by the upgraded<br />version of the software to apply any special "on-upgrade" commands during<br />the first BeginBlock method after the upgrade is applied. It is also used<br />to detect whether a software version can handle a given upgrade. If no<br />upgrade handler with this name has been set in the software, it will be<br />assumed that the software is out-of-date when the upgrade Time or Height is<br />reached and the software will exit.|
|time|string(date-time)|false|none|Deprecated: Time based upgrades have been deprecated. Time based upgrade logic<br />has been removed from the SDK.<br />If this field is not empty, an error will be thrown.|
|height|string(int64)|false|none|The height at which the upgrade must be performed.|
|info|string|false|none|none|
|upgraded_client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.upgrade.v1beta1.QueryAppliedPlanResponse

<a id="schemacosmos.upgrade.v1beta1.queryappliedplanresponse"></a>
<a id="schema_cosmos.upgrade.v1beta1.QueryAppliedPlanResponse"></a>
<a id="tocScosmos.upgrade.v1beta1.queryappliedplanresponse"></a>
<a id="tocscosmos.upgrade.v1beta1.queryappliedplanresponse"></a>

```json
{
  "height": "string"
}

```

QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|height|string(int64)|false|none|height is the block height at which the plan was applied.|

## cosmos.upgrade.v1beta1.QueryAuthorityResponse

<a id="schemacosmos.upgrade.v1beta1.queryauthorityresponse"></a>
<a id="schema_cosmos.upgrade.v1beta1.QueryAuthorityResponse"></a>
<a id="tocScosmos.upgrade.v1beta1.queryauthorityresponse"></a>
<a id="tocscosmos.upgrade.v1beta1.queryauthorityresponse"></a>

```json
{
  "address": "string"
}

```

QueryAuthorityResponse is the response type for Query/Authority

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|

## cosmos.upgrade.v1beta1.QueryCurrentPlanResponse

<a id="schemacosmos.upgrade.v1beta1.querycurrentplanresponse"></a>
<a id="schema_cosmos.upgrade.v1beta1.QueryCurrentPlanResponse"></a>
<a id="tocScosmos.upgrade.v1beta1.querycurrentplanresponse"></a>
<a id="tocscosmos.upgrade.v1beta1.querycurrentplanresponse"></a>

```json
{
  "plan": {
    "name": "string",
    "time": "2019-08-24T14:15:22Z",
    "height": "string",
    "info": "string",
    "upgraded_client_state": {
      "type_url": "string",
      "value": "string"
    }
  }
}

```

QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC
method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|plan|object|false|none|plan is the current upgrade plan.|
|» name|string|false|none|Sets the name for the upgrade. This name will be used by the upgraded<br />version of the software to apply any special "on-upgrade" commands during<br />the first BeginBlock method after the upgrade is applied. It is also used<br />to detect whether a software version can handle a given upgrade. If no<br />upgrade handler with this name has been set in the software, it will be<br />assumed that the software is out-of-date when the upgrade Time or Height is<br />reached and the software will exit.|
|» time|string(date-time)|false|none|Deprecated: Time based upgrades have been deprecated. Time based upgrade logic<br />has been removed from the SDK.<br />If this field is not empty, an error will be thrown.|
|» height|string(int64)|false|none|The height at which the upgrade must be performed.|
|» info|string|false|none|none|
|» upgraded_client_state|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|

## cosmos.upgrade.v1beta1.QueryModuleVersionsResponse

<a id="schemacosmos.upgrade.v1beta1.querymoduleversionsresponse"></a>
<a id="schema_cosmos.upgrade.v1beta1.QueryModuleVersionsResponse"></a>
<a id="tocScosmos.upgrade.v1beta1.querymoduleversionsresponse"></a>
<a id="tocscosmos.upgrade.v1beta1.querymoduleversionsresponse"></a>

```json
{
  "module_versions": [
    {
      "name": "string",
      "version": "string"
    }
  ]
}

```

QueryModuleVersionsResponse is the response type for the Query/ModuleVersions
RPC method.

Since: cosmos-sdk 0.43

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|module_versions|[object]|false|none|module_versions is a list of module names with their consensus versions.|
|» name|string|false|none|none|
|» version|string(uint64)|false|none|none|

## cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse

<a id="schemacosmos.upgrade.v1beta1.queryupgradedconsensusstateresponse"></a>
<a id="schema_cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse"></a>
<a id="tocScosmos.upgrade.v1beta1.queryupgradedconsensusstateresponse"></a>
<a id="tocscosmos.upgrade.v1beta1.queryupgradedconsensusstateresponse"></a>

```json
{
  "upgraded_consensus_state": "string"
}

```

QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState
RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|upgraded_consensus_state|string(byte)|false|none|none|

## cosmos.base.tendermint.v1beta1.ABCIQueryResponse

<a id="schemacosmos.base.tendermint.v1beta1.abciqueryresponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.ABCIQueryResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.abciqueryresponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.abciqueryresponse"></a>

```json
{
  "code": 0,
  "log": "string",
  "info": "string",
  "index": "string",
  "key": "string",
  "value": "string",
  "proof_ops": {
    "ops": [
      {
        "type": "string",
        "key": "string",
        "data": "string"
      }
    ]
  },
  "height": "string",
  "codespace": "string"
}

```

ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.

Note: This type is a duplicate of the ResponseQuery proto type defined in
Tendermint.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|code|integer(int64)|false|none|none|
|log|string|false|none|none|
|info|string|false|none|none|
|index|string(int64)|false|none|none|
|key|string(byte)|false|none|none|
|value|string(byte)|false|none|none|
|proof_ops|object|false|none|ProofOps is Merkle proof defined by the list of ProofOps.<br /><br />Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.|
|» ops|[object]|false|none|none|
|»» type|string|false|none|none|
|»» key|string(byte)|false|none|none|
|»» data|string(byte)|false|none|none|
|height|string(int64)|false|none|none|
|codespace|string|false|none|none|

## cosmos.base.tendermint.v1beta1.Block

<a id="schemacosmos.base.tendermint.v1beta1.block"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.Block"></a>
<a id="tocScosmos.base.tendermint.v1beta1.block"></a>
<a id="tocscosmos.base.tendermint.v1beta1.block"></a>

```json
{
  "header": {
    "version": {
      "block": "string",
      "app": "string"
    },
    "chain_id": "string",
    "height": "string",
    "time": "2019-08-24T14:15:22Z",
    "last_block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "last_commit_hash": "string",
    "data_hash": "string",
    "validators_hash": "string",
    "next_validators_hash": "string",
    "consensus_hash": "string",
    "app_hash": "string",
    "last_results_hash": "string",
    "evidence_hash": "string",
    "proposer_address": "string"
  },
  "data": {
    "txs": [
      "string"
    ]
  },
  "evidence": {
    "evidence": [
      {
        "duplicate_vote_evidence": {
          "vote_a": {},
          "vote_b": {},
          "total_voting_power": "string",
          "validator_power": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        },
        "light_client_attack_evidence": {
          "conflicting_block": {},
          "common_height": "string",
          "byzantine_validators": [
            null
          ],
          "total_voting_power": "string",
          "timestamp": "2019-08-24T14:15:22Z"
        }
      }
    ]
  },
  "last_commit": {
    "height": "string",
    "round": 0,
    "block_id": {
      "hash": "string",
      "part_set_header": {
        "total": 0,
        "hash": "string"
      }
    },
    "signatures": [
      {
        "block_id_flag": "BLOCK_ID_FLAG_UNKNOWN",
        "validator_address": "string",
        "timestamp": "2019-08-24T14:15:22Z",
        "signature": "string"
      }
    ]
  }
}

```

Block is tendermint type Block, with the Header proposer address
field converted to bech32 string.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|header|object|false|none|Header defines the structure of a Tendermint block header.|
|» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»» block|string(uint64)|false|none|none|
|»» app|string(uint64)|false|none|none|
|» chain_id|string|false|none|none|
|» height|string(int64)|false|none|none|
|» time|string(date-time)|false|none|none|
|» last_block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» last_commit_hash|string(byte)|false|none|none|
|» data_hash|string(byte)|false|none|none|
|» validators_hash|string(byte)|false|none|none|
|» next_validators_hash|string(byte)|false|none|none|
|» consensus_hash|string(byte)|false|none|none|
|» app_hash|string(byte)|false|none|none|
|» last_results_hash|string(byte)|false|none|none|
|» evidence_hash|string(byte)|false|none|none|
|» proposer_address|string|false|none|proposer_address is the original block proposer address, formatted as a Bech32 string.<br />In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string<br />for better UX.|
|data|object|false|none|none|
|» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|evidence|object|false|none|none|
|» evidence|[object]|false|none|none|
|»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»» height|string(int64)|false|none|none|
|»»»» round|integer(int32)|false|none|none|
|»»»» block_id|object|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»»»» part_set_header|object|false|none|none|
|»»»»»» total|integer(int64)|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» validator_index|integer(int32)|false|none|none|
|»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»» height|string(int64)|false|none|none|
|»»»» round|integer(int32)|false|none|none|
|»»»» block_id|object|false|none|none|
|»»»»» hash|string(byte)|false|none|none|
|»»»»» part_set_header|object|false|none|none|
|»»»»»» total|integer(int64)|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»»» validator_address|string(byte)|false|none|none|
|»»»» validator_index|integer(int32)|false|none|none|
|»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»» total_voting_power|string(int64)|false|none|none|
|»»» validator_power|string(int64)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»» conflicting_block|object|false|none|none|
|»»»» signed_header|object|false|none|none|
|»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»» app|string(uint64)|false|none|none|
|»»»»»» chain_id|string|false|none|none|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» time|string(date-time)|false|none|none|
|»»»»»» last_block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»» height|string(int64)|false|none|none|
|»»»»»» round|integer(int32)|false|none|none|
|»»»»»» block_id|object|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»» signatures|[object]|false|none|none|
|»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»» signature|string(byte)|false|none|none|
|»»»» validator_set|object|false|none|none|
|»»»»» validators|[object]|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» proposer|object|false|none|none|
|»»»»»» address|string(byte)|false|none|none|
|»»»»»» pub_key|object|false|none|none|
|»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»» total_voting_power|string(int64)|false|none|none|
|»»» common_height|string(int64)|false|none|none|
|»»» byzantine_validators|[object]|false|none|none|
|»»»» address|string(byte)|false|none|none|
|»»»» pub_key|object|false|none|none|
|»»»»» ed25519|string(byte)|false|none|none|
|»»»»» secp256k1|string(byte)|false|none|none|
|»»»» voting_power|string(int64)|false|none|none|
|»»»» proposer_priority|string(int64)|false|none|none|
|»»» total_voting_power|string(int64)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|» height|string(int64)|false|none|none|
|» round|integer(int32)|false|none|none|
|» block_id|object|false|none|none|
|»» hash|string(byte)|false|none|none|
|»» part_set_header|object|false|none|none|
|»»» total|integer(int64)|false|none|none|
|»»» hash|string(byte)|false|none|none|
|» signatures|[object]|false|none|none|
|»» block_id_flag|string|false|none|none|
|»» validator_address|string(byte)|false|none|none|
|»» timestamp|string(date-time)|false|none|none|
|»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse

<a id="schemacosmos.base.tendermint.v1beta1.getblockbyheightresponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.getblockbyheightresponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.getblockbyheightresponse"></a>

```json
{
  "block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "block": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "data": {
      "txs": [
        "string"
      ]
    },
    "evidence": {
      "evidence": [
        {
          "duplicate_vote_evidence": {},
          "light_client_attack_evidence": {}
        }
      ]
    },
    "last_commit": {
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "signatures": [
        {
          "block_id_flag": "[",
          "validator_address": "string",
          "timestamp": "2019-08-24T14:15:22Z",
          "signature": "string"
        }
      ]
    }
  },
  "sdk_block": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "data": {
      "txs": [
        "string"
      ]
    },
    "evidence": {
      "evidence": [
        {
          "duplicate_vote_evidence": {},
          "light_client_attack_evidence": {}
        }
      ]
    },
    "last_commit": {
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "signatures": [
        {
          "block_id_flag": "[",
          "validator_address": "string",
          "timestamp": "2019-08-24T14:15:22Z",
          "signature": "string"
        }
      ]
    }
  }
}

```

GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|block|object|false|none|none|
|» header|object|false|none|Header defines the structure of a block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string(byte)|false|none|none|
|» data|object|false|none|none|
|»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|» evidence|object|false|none|none|
|»» evidence|[object]|false|none|none|
|»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» validator_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»» conflicting_block|object|false|none|none|
|»»»»» signed_header|object|false|none|none|
|»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»» chain_id|string|false|none|none|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»» block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»» signature|string(byte)|false|none|none|
|»»»»» validator_set|object|false|none|none|
|»»»»»» validators|[object]|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» proposer|object|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»» common_height|string(int64)|false|none|none|
|»»»» byzantine_validators|[object]|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» signatures|[object]|false|none|none|
|»»» block_id_flag|string|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» signature|string(byte)|false|none|none|
|sdk_block|object|false|none|Block is tendermint type Block, with the Header proposer address<br />field converted to bech32 string.|
|» header|object|false|none|Header defines the structure of a Tendermint block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string|false|none|proposer_address is the original block proposer address, formatted as a Bech32 string.<br />In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string<br />for better UX.|
|» data|object|false|none|none|
|»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|» evidence|object|false|none|none|
|»» evidence|[object]|false|none|none|
|»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» validator_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»» conflicting_block|object|false|none|none|
|»»»»» signed_header|object|false|none|none|
|»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»» chain_id|string|false|none|none|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»» block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»» signature|string(byte)|false|none|none|
|»»»»» validator_set|object|false|none|none|
|»»»»»» validators|[object]|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» proposer|object|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»» common_height|string(int64)|false|none|none|
|»»»» byzantine_validators|[object]|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» signatures|[object]|false|none|none|
|»»» block_id_flag|string|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## cosmos.base.tendermint.v1beta1.GetLatestBlockResponse

<a id="schemacosmos.base.tendermint.v1beta1.getlatestblockresponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.GetLatestBlockResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.getlatestblockresponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.getlatestblockresponse"></a>

```json
{
  "block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "block": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "data": {
      "txs": [
        "string"
      ]
    },
    "evidence": {
      "evidence": [
        {
          "duplicate_vote_evidence": {},
          "light_client_attack_evidence": {}
        }
      ]
    },
    "last_commit": {
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "signatures": [
        {
          "block_id_flag": "[",
          "validator_address": "string",
          "timestamp": "2019-08-24T14:15:22Z",
          "signature": "string"
        }
      ]
    }
  },
  "sdk_block": {
    "header": {
      "version": {
        "block": "string",
        "app": "string"
      },
      "chain_id": "string",
      "height": "string",
      "time": "2019-08-24T14:15:22Z",
      "last_block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "last_commit_hash": "string",
      "data_hash": "string",
      "validators_hash": "string",
      "next_validators_hash": "string",
      "consensus_hash": "string",
      "app_hash": "string",
      "last_results_hash": "string",
      "evidence_hash": "string",
      "proposer_address": "string"
    },
    "data": {
      "txs": [
        "string"
      ]
    },
    "evidence": {
      "evidence": [
        {
          "duplicate_vote_evidence": {},
          "light_client_attack_evidence": {}
        }
      ]
    },
    "last_commit": {
      "height": "string",
      "round": 0,
      "block_id": {
        "hash": "string",
        "part_set_header": {
          "total": null,
          "hash": null
        }
      },
      "signatures": [
        {
          "block_id_flag": "[",
          "validator_address": "string",
          "timestamp": "2019-08-24T14:15:22Z",
          "signature": "string"
        }
      ]
    }
  }
}

```

GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|block|object|false|none|none|
|» header|object|false|none|Header defines the structure of a block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string(byte)|false|none|none|
|» data|object|false|none|none|
|»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|» evidence|object|false|none|none|
|»» evidence|[object]|false|none|none|
|»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» validator_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»» conflicting_block|object|false|none|none|
|»»»»» signed_header|object|false|none|none|
|»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»» chain_id|string|false|none|none|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»» block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»» signature|string(byte)|false|none|none|
|»»»»» validator_set|object|false|none|none|
|»»»»»» validators|[object]|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» proposer|object|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»» common_height|string(int64)|false|none|none|
|»»»» byzantine_validators|[object]|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» signatures|[object]|false|none|none|
|»»» block_id_flag|string|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» signature|string(byte)|false|none|none|
|sdk_block|object|false|none|Block is tendermint type Block, with the Header proposer address<br />field converted to bech32 string.|
|» header|object|false|none|Header defines the structure of a Tendermint block header.|
|»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»» block|string(uint64)|false|none|none|
|»»» app|string(uint64)|false|none|none|
|»» chain_id|string|false|none|none|
|»» height|string(int64)|false|none|none|
|»» time|string(date-time)|false|none|none|
|»» last_block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» last_commit_hash|string(byte)|false|none|none|
|»» data_hash|string(byte)|false|none|none|
|»» validators_hash|string(byte)|false|none|none|
|»» next_validators_hash|string(byte)|false|none|none|
|»» consensus_hash|string(byte)|false|none|none|
|»» app_hash|string(byte)|false|none|none|
|»» last_results_hash|string(byte)|false|none|none|
|»» evidence_hash|string(byte)|false|none|none|
|»» proposer_address|string|false|none|proposer_address is the original block proposer address, formatted as a Bech32 string.<br />In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string<br />for better UX.|
|» data|object|false|none|none|
|»» txs|[string]|false|none|Txs that will be applied by state @ block.Height+1.<br />NOTE: not all txs here are valid.  We're just agreeing on the order first.<br />This means that block.AppHash does not include these txs.|
|» evidence|object|false|none|none|
|»» evidence|[object]|false|none|none|
|»»» duplicate_vote_evidence|object|false|none|DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.|
|»»»» vote_a|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» vote_b|object|false|none|Vote represents a prevote or precommit vote from validators for<br />consensus.|
|»»»»» type|string|false|none|SignedMsgType is a type of signed message in the consensus.<br /><br /> - SIGNED_MSG_TYPE_PREVOTE: Votes<br /> - SIGNED_MSG_TYPE_PROPOSAL: Proposals|
|»»»»» height|string(int64)|false|none|none|
|»»»»» round|integer(int32)|false|none|none|
|»»»»» block_id|object|false|none|none|
|»»»»»» hash|string(byte)|false|none|none|
|»»»»»» part_set_header|object|false|none|none|
|»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»» hash|string(byte)|false|none|none|
|»»»»» timestamp|string(date-time)|false|none|none|
|»»»»» validator_address|string(byte)|false|none|none|
|»»»»» validator_index|integer(int32)|false|none|none|
|»»»»» signature|string(byte)|false|none|Vote signature by the validator if they participated in consensus for the<br />associated block.|
|»»»»» extension|string(byte)|false|none|Vote extension provided by the application. Only valid for precommit<br />messages.|
|»»»»» extension_signature|string(byte)|false|none|Vote extension signature by the validator if they participated in<br />consensus for the associated block.<br />Only valid for precommit messages.|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» validator_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|»»» light_client_attack_evidence|object|false|none|LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.|
|»»»» conflicting_block|object|false|none|none|
|»»»»» signed_header|object|false|none|none|
|»»»»»» header|object|false|none|Header defines the structure of a block header.|
|»»»»»»» version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|»»»»»»»» block|string(uint64)|false|none|none|
|»»»»»»»» app|string(uint64)|false|none|none|
|»»»»»»» chain_id|string|false|none|none|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» time|string(date-time)|false|none|none|
|»»»»»»» last_block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» last_commit_hash|string(byte)|false|none|none|
|»»»»»»» data_hash|string(byte)|false|none|none|
|»»»»»»» validators_hash|string(byte)|false|none|none|
|»»»»»»» next_validators_hash|string(byte)|false|none|none|
|»»»»»»» consensus_hash|string(byte)|false|none|none|
|»»»»»»» app_hash|string(byte)|false|none|none|
|»»»»»»» last_results_hash|string(byte)|false|none|none|
|»»»»»»» evidence_hash|string(byte)|false|none|none|
|»»»»»»» proposer_address|string(byte)|false|none|none|
|»»»»»» commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»»»»»»» height|string(int64)|false|none|none|
|»»»»»»» round|integer(int32)|false|none|none|
|»»»»»»» block_id|object|false|none|none|
|»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»»» part_set_header|object|false|none|none|
|»»»»»»»»» total|integer(int64)|false|none|none|
|»»»»»»»»» hash|string(byte)|false|none|none|
|»»»»»»» signatures|[object]|false|none|none|
|»»»»»»»» block_id_flag|string|false|none|none|
|»»»»»»»» validator_address|string(byte)|false|none|none|
|»»»»»»»» timestamp|string(date-time)|false|none|none|
|»»»»»»»» signature|string(byte)|false|none|none|
|»»»»» validator_set|object|false|none|none|
|»»»»»» validators|[object]|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» proposer|object|false|none|none|
|»»»»»»» address|string(byte)|false|none|none|
|»»»»»»» pub_key|object|false|none|none|
|»»»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»»»» voting_power|string(int64)|false|none|none|
|»»»»»»» proposer_priority|string(int64)|false|none|none|
|»»»»»» total_voting_power|string(int64)|false|none|none|
|»»»» common_height|string(int64)|false|none|none|
|»»»» byzantine_validators|[object]|false|none|none|
|»»»»» address|string(byte)|false|none|none|
|»»»»» pub_key|object|false|none|none|
|»»»»»» ed25519|string(byte)|false|none|none|
|»»»»»» secp256k1|string(byte)|false|none|none|
|»»»»» voting_power|string(int64)|false|none|none|
|»»»»» proposer_priority|string(int64)|false|none|none|
|»»»» total_voting_power|string(int64)|false|none|none|
|»»»» timestamp|string(date-time)|false|none|none|
|» last_commit|object|false|none|Commit contains the evidence that a block was committed by a set of validators.|
|»» height|string(int64)|false|none|none|
|»» round|integer(int32)|false|none|none|
|»» block_id|object|false|none|none|
|»»» hash|string(byte)|false|none|none|
|»»» part_set_header|object|false|none|none|
|»»»» total|integer(int64)|false|none|none|
|»»»» hash|string(byte)|false|none|none|
|»» signatures|[object]|false|none|none|
|»»» block_id_flag|string|false|none|none|
|»»» validator_address|string(byte)|false|none|none|
|»»» timestamp|string(date-time)|false|none|none|
|»»» signature|string(byte)|false|none|none|

#### Enumerated Values

|Property|Value|
|---|---|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|type|SIGNED_MSG_TYPE_UNKNOWN|
|type|SIGNED_MSG_TYPE_PREVOTE|
|type|SIGNED_MSG_TYPE_PRECOMMIT|
|type|SIGNED_MSG_TYPE_PROPOSAL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|
|block_id_flag|BLOCK_ID_FLAG_UNKNOWN|
|block_id_flag|BLOCK_ID_FLAG_ABSENT|
|block_id_flag|BLOCK_ID_FLAG_COMMIT|
|block_id_flag|BLOCK_ID_FLAG_NIL|

## cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse

<a id="schemacosmos.base.tendermint.v1beta1.getlatestvalidatorsetresponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.getlatestvalidatorsetresponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.getlatestvalidatorsetresponse"></a>

```json
{
  "block_height": "string",
  "validators": [
    {
      "address": "string",
      "pub_key": {
        "type_url": "string",
        "value": "string"
      },
      "voting_power": "string",
      "proposer_priority": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string(int64)|false|none|none|
|validators|[object]|false|none|none|
|» address|string|false|none|none|
|» pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» voting_power|string(int64)|false|none|none|
|» proposer_priority|string(int64)|false|none|none|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.base.tendermint.v1beta1.GetNodeInfoResponse

<a id="schemacosmos.base.tendermint.v1beta1.getnodeinforesponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.GetNodeInfoResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.getnodeinforesponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.getnodeinforesponse"></a>

```json
{
  "default_node_info": {
    "protocol_version": {
      "p2p": "string",
      "block": "string",
      "app": "string"
    },
    "default_node_id": "string",
    "listen_addr": "string",
    "network": "string",
    "version": "string",
    "channels": "string",
    "moniker": "string",
    "other": {
      "tx_index": "string",
      "rpc_address": "string"
    }
  },
  "application_version": {
    "name": "string",
    "app_name": "string",
    "version": "string",
    "git_commit": "string",
    "build_tags": "string",
    "go_version": "string",
    "build_deps": [
      {
        "path": "string",
        "version": "string",
        "sum": "string"
      }
    ],
    "cosmos_sdk_version": "string"
  }
}

```

GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|default_node_info|object|false|none|none|
|» protocol_version|object|false|none|none|
|»» p2p|string(uint64)|false|none|none|
|»» block|string(uint64)|false|none|none|
|»» app|string(uint64)|false|none|none|
|» default_node_id|string|false|none|none|
|» listen_addr|string|false|none|none|
|» network|string|false|none|none|
|» version|string|false|none|none|
|» channels|string(byte)|false|none|none|
|» moniker|string|false|none|none|
|» other|object|false|none|none|
|»» tx_index|string|false|none|none|
|»» rpc_address|string|false|none|none|
|application_version|object|false|none|VersionInfo is the type for the GetNodeInfoResponse message.|
|» name|string|false|none|none|
|» app_name|string|false|none|none|
|» version|string|false|none|none|
|» git_commit|string|false|none|none|
|» build_tags|string|false|none|none|
|» go_version|string|false|none|none|
|» build_deps|[object]|false|none|none|
|»» Module is the type for VersionInfo|object|false|none|none|
|»»» path|string|false|none|none|
|»»» version|string|false|none|none|
|»»» sum|string|false|none|none|
|» cosmos_sdk_version|string|false|none|none|

## cosmos.base.tendermint.v1beta1.GetSyncingResponse

<a id="schemacosmos.base.tendermint.v1beta1.getsyncingresponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.GetSyncingResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.getsyncingresponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.getsyncingresponse"></a>

```json
{
  "syncing": true
}

```

GetSyncingResponse is the response type for the Query/GetSyncing RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|syncing|boolean|false|none|none|

## cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse

<a id="schemacosmos.base.tendermint.v1beta1.getvalidatorsetbyheightresponse"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse"></a>
<a id="tocScosmos.base.tendermint.v1beta1.getvalidatorsetbyheightresponse"></a>
<a id="tocscosmos.base.tendermint.v1beta1.getvalidatorsetbyheightresponse"></a>

```json
{
  "block_height": "string",
  "validators": [
    {
      "address": "string",
      "pub_key": {
        "type_url": "string",
        "value": "string"
      },
      "voting_power": "string",
      "proposer_priority": "string"
    }
  ],
  "pagination": {
    "next_key": "string",
    "total": "string"
  }
}

```

GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string(int64)|false|none|none|
|validators|[object]|false|none|none|
|» address|string|false|none|none|
|» pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|»» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|»» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|» voting_power|string(int64)|false|none|none|
|» proposer_priority|string(int64)|false|none|none|
|pagination|object|false|none|pagination defines an pagination for the response.|
|» next_key|string(byte)|false|none|next_key is the key to be passed to PageRequest.key to<br />query the next page most efficiently. It will be empty if<br />there are no more results.|
|» total|string(uint64)|false|none|none|

## cosmos.base.tendermint.v1beta1.Header

<a id="schemacosmos.base.tendermint.v1beta1.header"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.Header"></a>
<a id="tocScosmos.base.tendermint.v1beta1.header"></a>
<a id="tocscosmos.base.tendermint.v1beta1.header"></a>

```json
{
  "version": {
    "block": "string",
    "app": "string"
  },
  "chain_id": "string",
  "height": "string",
  "time": "2019-08-24T14:15:22Z",
  "last_block_id": {
    "hash": "string",
    "part_set_header": {
      "total": 0,
      "hash": "string"
    }
  },
  "last_commit_hash": "string",
  "data_hash": "string",
  "validators_hash": "string",
  "next_validators_hash": "string",
  "consensus_hash": "string",
  "app_hash": "string",
  "last_results_hash": "string",
  "evidence_hash": "string",
  "proposer_address": "string"
}

```

Header defines the structure of a Tendermint block header.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|version|object|false|none|Consensus captures the consensus rules for processing a block in the blockchain,<br />including all blockchain data structures and the rules of the application's<br />state transition machine.|
|» block|string(uint64)|false|none|none|
|» app|string(uint64)|false|none|none|
|chain_id|string|false|none|none|
|height|string(int64)|false|none|none|
|time|string(date-time)|false|none|none|
|last_block_id|object|false|none|none|
|» hash|string(byte)|false|none|none|
|» part_set_header|object|false|none|none|
|»» total|integer(int64)|false|none|none|
|»» hash|string(byte)|false|none|none|
|last_commit_hash|string(byte)|false|none|none|
|data_hash|string(byte)|false|none|none|
|validators_hash|string(byte)|false|none|none|
|next_validators_hash|string(byte)|false|none|none|
|consensus_hash|string(byte)|false|none|none|
|app_hash|string(byte)|false|none|none|
|last_results_hash|string(byte)|false|none|none|
|evidence_hash|string(byte)|false|none|none|
|proposer_address|string|false|none|proposer_address is the original block proposer address, formatted as a Bech32 string.<br />In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string<br />for better UX.|

## cosmos.base.tendermint.v1beta1.Module

<a id="schemacosmos.base.tendermint.v1beta1.module"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.Module"></a>
<a id="tocScosmos.base.tendermint.v1beta1.module"></a>
<a id="tocscosmos.base.tendermint.v1beta1.module"></a>

```json
{
  "path": "string",
  "version": "string",
  "sum": "string"
}

```

Module is the type for VersionInfo

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|path|string|false|none|none|
|version|string|false|none|none|
|sum|string|false|none|none|

## cosmos.base.tendermint.v1beta1.ProofOp

<a id="schemacosmos.base.tendermint.v1beta1.proofop"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.ProofOp"></a>
<a id="tocScosmos.base.tendermint.v1beta1.proofop"></a>
<a id="tocscosmos.base.tendermint.v1beta1.proofop"></a>

```json
{
  "type": "string",
  "key": "string",
  "data": "string"
}

```

ProofOp defines an operation used for calculating Merkle root. The data could
be arbitrary format, providing necessary data for example neighbouring node
hash.

Note: This type is a duplicate of the ProofOp proto type defined in Tendermint.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|type|string|false|none|none|
|key|string(byte)|false|none|none|
|data|string(byte)|false|none|none|

## cosmos.base.tendermint.v1beta1.ProofOps

<a id="schemacosmos.base.tendermint.v1beta1.proofops"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.ProofOps"></a>
<a id="tocScosmos.base.tendermint.v1beta1.proofops"></a>
<a id="tocscosmos.base.tendermint.v1beta1.proofops"></a>

```json
{
  "ops": [
    {
      "type": "string",
      "key": "string",
      "data": "string"
    }
  ]
}

```

ProofOps is Merkle proof defined by the list of ProofOps.

Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|ops|[object]|false|none|none|
|» type|string|false|none|none|
|» key|string(byte)|false|none|none|
|» data|string(byte)|false|none|none|

## cosmos.base.tendermint.v1beta1.Validator

<a id="schemacosmos.base.tendermint.v1beta1.validator"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.Validator"></a>
<a id="tocScosmos.base.tendermint.v1beta1.validator"></a>
<a id="tocscosmos.base.tendermint.v1beta1.validator"></a>

```json
{
  "address": "string",
  "pub_key": {
    "type_url": "string",
    "value": "string"
  },
  "voting_power": "string",
  "proposer_priority": "string"
}

```

Validator is the type for the validator-set.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|address|string|false|none|none|
|pub_key|object|false|none|`Any` contains an arbitrary serialized protocol buffer message along with a<br />URL that describes the type of the serialized message.<br /><br />Protobuf library provides support to pack/unpack Any values in the form<br />of utility functions or additional generated methods of the Any type.<br /><br />Example 1: Pack and unpack a message in C++.<br /><br />    Foo foo = ...;<br />    Any any;<br />    any.PackFrom(foo);<br />    ...<br />    if (any.UnpackTo(&foo)) {<br />      ...<br />    }<br /><br />Example 2: Pack and unpack a message in Java.<br /><br />    Foo foo = ...;<br />    Any any = Any.pack(foo);<br />    ...<br />    if (any.is(Foo.class)) {<br />      foo = any.unpack(Foo.class);<br />    }<br /><br />Example 3: Pack and unpack a message in Python.<br /><br />    foo = Foo(...)<br />    any = Any()<br />    any.Pack(foo)<br />    ...<br />    if any.Is(Foo.DESCRIPTOR):<br />      any.Unpack(foo)<br />      ...<br /><br />Example 4: Pack and unpack a message in Go<br /><br />     foo := &pb.Foo{...}<br />     any, err := anypb.New(foo)<br />     if err != nil {<br />       ...<br />     }<br />     ...<br />     foo := &pb.Foo{}<br />     if err := any.UnmarshalTo(foo); err != nil {<br />       ...<br />     }<br /><br />The pack methods provided by protobuf library will by default use<br />'type.googleapis.com/full.type.name' as the type URL and the unpack<br />methods only use the fully qualified type name after the last '/'<br />in the type URL, for example "foo.bar.com/x/y.z" will yield type<br />name "y.z".<br /><br /><br />JSON<br /><br />The JSON representation of an `Any` value uses the regular<br />representation of the deserialized, embedded message, with an<br />additional field `@type` which contains the type URL. Example:<br /><br />    package google.profile;<br />    message Person {<br />      string first_name = 1;<br />      string last_name = 2;<br />    }<br /><br />    {<br />      "@type": "type.googleapis.com/google.profile.Person",<br />      "firstName": <string>,<br />      "lastName": <string><br />    }<br /><br />If the embedded message type is well-known and has a custom JSON<br />representation, that representation will be embedded adding a field<br />`value` which holds the custom JSON in addition to the `@type`<br />field. Example (for message [google.protobuf.Duration][]):<br /><br />    {<br />      "@type": "type.googleapis.com/google.protobuf.Duration",<br />      "value": "1.212s"<br />    }|
|» type_url|string|false|none|A URL/resource name that uniquely identifies the type of the serialized<br />protocol buffer message. This string must contain at least<br />one "/" character. The last segment of the URL's path must represent<br />the fully qualified name of the type (as in<br />`path/google.protobuf.Duration`). The name should be in a canonical form<br />(e.g., leading "." is not accepted).<br /><br />In practice, teams usually precompile into the binary all types that they<br />expect it to use in the context of Any. However, for URLs which use the<br />scheme `http`, `https`, or no scheme, one can optionally set up a type<br />server that maps type URLs to message definitions as follows:<br /><br />* If no scheme is provided, `https` is assumed.<br />* An HTTP GET on the URL must yield a [google.protobuf.Type][]<br />  value in binary format, or produce an error.<br />* Applications are allowed to cache lookup results based on the<br />  URL, or have them precompiled into a binary to avoid any<br />  lookup. Therefore, binary compatibility needs to be preserved<br />  on changes to types. (Use versioned type names to manage<br />  breaking changes.)<br /><br />Note: this functionality is not currently available in the official<br />protobuf release, and it is not used for type URLs beginning with<br />type.googleapis.com.<br /><br />Schemes other than `http`, `https` (or the empty scheme) might be<br />used with implementation specific semantics.|
|» value|string(byte)|false|none|Must be a valid serialized protocol buffer of the above specified type.|
|voting_power|string(int64)|false|none|none|
|proposer_priority|string(int64)|false|none|none|

## cosmos.base.tendermint.v1beta1.VersionInfo

<a id="schemacosmos.base.tendermint.v1beta1.versioninfo"></a>
<a id="schema_cosmos.base.tendermint.v1beta1.VersionInfo"></a>
<a id="tocScosmos.base.tendermint.v1beta1.versioninfo"></a>
<a id="tocscosmos.base.tendermint.v1beta1.versioninfo"></a>

```json
{
  "name": "string",
  "app_name": "string",
  "version": "string",
  "git_commit": "string",
  "build_tags": "string",
  "go_version": "string",
  "build_deps": [
    {
      "path": "string",
      "version": "string",
      "sum": "string"
    }
  ],
  "cosmos_sdk_version": "string"
}

```

VersionInfo is the type for the GetNodeInfoResponse message.

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|name|string|false|none|none|
|app_name|string|false|none|none|
|version|string|false|none|none|
|git_commit|string|false|none|none|
|build_tags|string|false|none|none|
|go_version|string|false|none|none|
|build_deps|[object]|false|none|none|
|» Module is the type for VersionInfo|object|false|none|none|
|»» path|string|false|none|none|
|»» version|string|false|none|none|
|»» sum|string|false|none|none|
|cosmos_sdk_version|string|false|none|none|

## tendermint.p2p.DefaultNodeInfo

<a id="schematendermint.p2p.defaultnodeinfo"></a>
<a id="schema_tendermint.p2p.DefaultNodeInfo"></a>
<a id="tocStendermint.p2p.defaultnodeinfo"></a>
<a id="tocstendermint.p2p.defaultnodeinfo"></a>

```json
{
  "protocol_version": {
    "p2p": "string",
    "block": "string",
    "app": "string"
  },
  "default_node_id": "string",
  "listen_addr": "string",
  "network": "string",
  "version": "string",
  "channels": "string",
  "moniker": "string",
  "other": {
    "tx_index": "string",
    "rpc_address": "string"
  }
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|protocol_version|object|false|none|none|
|» p2p|string(uint64)|false|none|none|
|» block|string(uint64)|false|none|none|
|» app|string(uint64)|false|none|none|
|default_node_id|string|false|none|none|
|listen_addr|string|false|none|none|
|network|string|false|none|none|
|version|string|false|none|none|
|channels|string(byte)|false|none|none|
|moniker|string|false|none|none|
|other|object|false|none|none|
|» tx_index|string|false|none|none|
|» rpc_address|string|false|none|none|

## tendermint.p2p.DefaultNodeInfoOther

<a id="schematendermint.p2p.defaultnodeinfoother"></a>
<a id="schema_tendermint.p2p.DefaultNodeInfoOther"></a>
<a id="tocStendermint.p2p.defaultnodeinfoother"></a>
<a id="tocstendermint.p2p.defaultnodeinfoother"></a>

```json
{
  "tx_index": "string",
  "rpc_address": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|tx_index|string|false|none|none|
|rpc_address|string|false|none|none|

## tendermint.p2p.ProtocolVersion

<a id="schematendermint.p2p.protocolversion"></a>
<a id="schema_tendermint.p2p.ProtocolVersion"></a>
<a id="tocStendermint.p2p.protocolversion"></a>
<a id="tocstendermint.p2p.protocolversion"></a>

```json
{
  "p2p": "string",
  "block": "string",
  "app": "string"
}

```

### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|p2p|string(uint64)|false|none|none|
|block|string(uint64)|false|none|none|
|app|string(uint64)|false|none|none|

